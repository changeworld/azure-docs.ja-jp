<properties
   pageTitle="API 設計ガイダンス | Microsoft Azure"
   description="適切に設計された API の作成方法についてのガイダンス。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="rest-api"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# API 設計ガイダンス

![](media/best-practices-api-design/pnp-logo.png)

このガイダンスの一部のトピックは審議中であり、今後変更される場合があります。ご意見をお待ちしております。


## 概要

現代の多くの Web ベース ソリューションでは、Web サーバーによりホストされる Web サービスを使用することで、リモート クライアント アプリケーションの機能を提供します。Web サービスにより公開される操作によって Web API が構成されています。適切に設計された Web API には、次をサポートする目的があります。

- **プラットフォームの独立**。クライアント アプリケーションは、API により公開されるデータや操作の物理的な実装方法を要求することなく、Web サービスが提供する API を利用できる必要があります。そのためには、API が共通基準を順守し、クライアント アプリケーションおよび Web サービスが、使用するデータ形式や、クライアント アプリケーションと Web サービスの間で交換されるデータ構造に同意できるようにする必要があります。

- **サービスの進化**。Web サービスはクライアント アプリケーションから独立して進化し、機能を追加 (または削除) できる必要があります。Web サービスにより提供される機能は変化するため、既存のクライアント アプリケーションは変化せずに操作を継続できる必要があります。すべての機能も検出可能で、クライアント アプリケーションで十分に利用できるようにする必要があります。

このガイダンスでは、Web API を設計するときに考慮する問題について説明します。

## Representational State Transfer (REST) の概要

ロイ・フィールディングは 2000 年に著した論文で、Web サービスにより公開される操作を構築する、代わりとなるアーキテクチャ アプローチを提唱しました。それが REST です。REST はハイパーメディアに基づき分散システムを構築するアーキテクチャ スタイルです。REST モデルの主な利点は、オープン スタンダードに基づいており、それにアクセスするモデルやクライアント アプリケーションの実装を、特定の実装に結びつけないという点です。たとえば、REST Web サービスは Microsoft ASP.NET Web API を使用して実装でき、クライアント アプリケーションは任意の言語および HTTP 要求の生成と HTTP 応答の解析を行うことができるツールセットを使用して開発できます。

> [AZURE.NOTE]実際、REST は基盤となるプロトコルに一切依存せず、必ずしも HTTP と結び付けられていません。とはいえ、REST に基づくシステムを実装する際には、要求を送受信するアプリケーション プロトコルとして HTTP を利用するのが最も一般的です。本文書では、HTTP を使用して操作するように設計されているシステムに REST の原則をマッピングすることに重点を置いて説明します。

REST モデルでは、ネットワーク経由のオブジェクトおよびサービスを表すために、ナビゲーション スキームを使用します (_リソース_ と呼ばれる)。通常、REST を実装する多くのシステムでは、これらのリソースにアクセスするための要求を送信するのに HTTP プロトコルを使用します。これらのシステムでクライアント アプリケーションは、リソースを識別する URI、およびそのリソースで実行する操作を示す HTTP メソッド (最も一般的なのは GET、POST、PUT、DELETE) の形式で要求を送信します。HTTP 要求の本文には、操作を実行するのに必要なデータが含まれています。REST はステートレスの要求モデルを定義することを理解することは重要です。HTTP 要求は独立している必要があり、任意の順序で起こる場合があります。そのため、要求間の遷移状態の情報を保持しようとすることはできません。情報の格納場所はリソース自体のみであり、それぞれの要求はアトミックな操作である必要があります。実用上、REST モデルは Finite State Machine を実装し、要求によって、リソースは適切に定義された非遷移状態から別の状態に切り替えられます。

> [AZURE.NOTE]REST モデルの個々の要求はステートレスであるため、これらの原則に従って構築されたシステムには非常に高い拡張性を持たせることができます。一連の要求を行うクライアント アプリケーションと、それらの要求を処理する特定の Web サーバーの関係を保持する必要は一切ありません。

効率的な REST モデルを実装するうえで他にも重要な点は、モデルによりアクセスが提供されるさまざまなリソース間のリレーションシップを理解することです。通常、これらのリソースはコレクションおよびリレーションシップとして構成されます。たとえば、電子商取引システムの迅速な分析により、クライアント アプリケーションが関心を持つ可能性の高い、注文と顧客という 2 つのコレクションがあることが示されると想定してください。それぞれの注文と顧客には、特定するための独自の一意なキーがある必要があります。注文のコレクションにアクセスする URI は、_/orders_ のように単純に記述でき、同様にすべての顧客を取得する URI は _/customers_ のように単純に記述できます。_/orders_ URI に HTTP GET 要求を発行すると、HTTP 応答としてエンコードされたコレクションのすべての注文を表すリストが返されます。

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

以下に示す応答は、注文を XML リスト構造でエンコードします。このリストには、7 件の注文が含まれています。

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<OrderList xmlns:i="..." xmlns="..."><Order><OrderID>1</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order><Order><OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order><Order><OrderID>3</OrderID><OrderValue>16.60</OrderValue><ProductID>2</ProductID><Quantity>4</Quantity></Order><Order><OrderID>4</OrderID><OrderValue>25.90</OrderValue><ProductID>3</ProductID><Quantity>1</Quantity></Order><Order><OrderID>7</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order></OrderList>
```
個々 の注文を取得するには、注文の識別子を _/orders/2_ などの _orders_ リソースから指定する必要があります。

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<Order xmlns:i="..." xmlns="...">
<OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order>
```

> [AZURE.NOTE]わかりやすくするため、これらの例では XML テキスト データとして返される応答の情報が表示されています。ただし、バイナリ情報や暗号化情報など HTTP によりサポートされている他の種類のデータをリソースに一切含めるべきでない理由はありません。HTTP 応答の content-type では種類を指定する必要があります。また、REST モデルは XML や JSON など、異なる形式の同じデータを返すことができる場合があります。この場合、Web サービスは要求を行うクライアントとのコンテント ネゴシエーションを実行できる必要があります。要求にはクライアントが受け取る優先形式を指定する _Accept_ ヘッダーを含めることができ、Web サービスは可能な限りこの形式を使用しようとする必要があります。

REST 要求からの応答では標準 HTTP 状態 コードが使用されていることに注意してください。たとえば、有効なデータを返す要求には HTTP 応答コード 200 (OK) を含める必要があり、指定したリソースの確認および削除に失敗した要求は HTTP 状態コード 404 (Not Found) を含む応答を返す必要があります。

## RESTful Web API の設計と構造

正常な Web API を設計するポイントは、単純さと一貫性です。Web API がこれらの 2 つの要素を備えていると、API を消費する必要があるクライアント アプリケーションを簡単に構築できます。

RESTful Web API は一連の接続されたリソースを公開し、アプリケーションがこれらのリソースを操作してリソース間を簡単にナビゲートできるようにするコア操作を提供することに重点を置いています。このため、一般的な RESTful Web API を構成する URI は、公開するデータ指向でなければならず、このデータを操作するために HTTP により提供される機能を使用する必要があります。オブジェクトおよびクラスの動作に促される傾向がある オブジェクト指向 API の一連のクラスを設計する場合、このアプローチには一般的に採用されている考え方とは異なる考え方が必要です。さらに、RESTful Web API はステートレスで、特定のシーケンスで呼び出される操作に依存しない必要があります。次のセクションでは、RESTful Wb API を設計するときに考慮する必要があるポイントをまとめます。

### リソースに関係する Web API の構成

> [AZURE.TIP]REST Web サービスにより公開される URI は名詞 (Web API プロバイダーがアクセスするデータ) に基づくものであり、動詞 (データを使用してアプリケーションが行うことができること) に基づくものにはできません。

Web API が公開するビジネス エンティティに注目して説明します。たとえば、前に説明した電子商取引システムをサポートするために設計された Web API で、主エンティティは顧客と注文です。発注行為などのプロセスは、注文情報を取り込み、それを顧客の注文リストに追加する HTTP POST 操作を指定することで行うことができます。内部ではこの POST 操作により、在庫レベルの確認や顧客への請求などのタスクを実行できます。HTTP 応答は、発注が正常に行われたかどうかを示すことができます。リソースは単一の物理データ項目に基づく必要はないことにも注意してください。たとえば注文リソースは、リレーショナル データベースの複数のテーブルに分散する多くの行から集計した情報を使用して内部的に実装されるものの、クライアントには単一のエンティティとして表示される場合があります。

> [AZURE.TIP]設計する REST インターフェイスが、公開するデータの内部構造をミラーリングしたり、それに依存しないようにしてください。REST は、リレーショナル データベースの個別のテーブルに対して単純な CRUD (作成、取得、更新、削除) 操作を実行するだけのものではありません。REST の目的は、ビジネス エンティティおよびアプリケーションがそれらのエンティティに実行できる操作を、それらのエンティティの物理実装にマッピングすることですが、これらの物理的詳細をクライアントに公開すべきではありません。

個々のビジネス エンティティはまれに分離して存在していますが (ただし、いくつかのシングルトン オブジェクトが存在する場合があります)、むしろ共にコレクションにグループ化される傾向にあります。REST 用語では、各エンティティおよび各コレクションはリソースです。RESTful web API で、各コレクションには Web サービス内に独自の URIがあり、コレクションの URI に対して HTTP GET 要求を実行することで、そのコレクションの項目の一覧を取得します。個々の項目にも独自の URI があり、アプリケーションはその URI を使用して別の HTTP GET 要求を送信することで、その項目の詳細を取得できます。コレクションと項目の URI は階層的に整理してください。電子商取引システムでは、URI _/customers_ は顧客のコレクションを表し、_/customers/5_ はこのコレクションから ID 5 の単一顧客に関する詳細を取得します。この方法は、Web API を直感的に保つのに役立ちます。

> [AZURE.TIP]URI で一貫性のある命名規則を使用します。一般的に、コレクションを参照する URI で複数形名詞を使用するのに役立ちます。

異なる種類のリソース間のリレーションシップ、およびこの関連を公開する方法を検討する必要もあります。たとえば、顧客の発注が 0 またはそれ以上である場合があります。このリレーションシップを表す自然な方法は、_/customers/5/orders_ などの URI より顧客 5 のすべての注文を検索することです。注文 99 の顧客を検索するには、_/orders/99/customer_ などの URI より、注文から特定の顧客への逆の関連を表すことも検討できます。とはいえ、このモデルをあまりにも拡張すると、実装が煩雑になる可能性があります。より優れたソリューションは、注文のクエリを実行するときに返される HTTP 応答メッセージの本文に、顧客など関連するリソースに誘導できるリンクを記載することです。このメカニズムの詳細については、本ガイダンスの「関連リソースへのナビゲーションを可能にする HATEOAS アプローチの使用」のセクションで後に説明します。

より複雑なシステムでは、さらに多くの種類のエンティティが存在する場合があり、クライアント アプリケーションがさまざまなレベルのリレーションシップをナビゲートするのを可能にする URI を提供するように促すことができます。たとえば、_/customers/1/orders/99/products_ は顧客 1 が発注した注文 99 の製品リストを取得します。ただし、将来的にリソース間のリレーションシップが変わる場合、このレベルの複雑さを維持するのは難しく、柔軟性がありません。むしろ、URI を比較的シンプルに維持するようにします。一度アプリケーションもリソースへの参照が備わると、この参照を使用してそのリソースに関連する項目を検索できることに注意してください。上記のクエリは URI _/customers/1/orders_ と置き換えると顧客 1 のすべての注文を検索でき、URI _/orders/99/products_ のクエリを実行するとこの注文の製品を検索できます (注文 99 は顧客 1 により発注されたと仮定)。

> [AZURE.TIP]_コレクション/項目/コレクション_よりも複雑なリソース URI を要求しないでください。

考慮すべき別の点は、すべての Web 要求は Web サーバーに負荷を与えるため、要求回数が多くなるほど負荷も大きくなることです。定義するリソースが、大量の小さなリソースを公開する「おしゃべりな」Web API にならないようにしてください。そのような API では、クライアント アプリケーションが必要なすべてのデータを検索するために、複数の要求を送信する必要がある場合があります。データを非正規化し、1 回の要求を発行して取得できる大きなリソースに関連情報を一緒に組み合わせることが有益な場合があります。ただし、このアプローチでは、クライアントが頻繁には必要としないデータ取得のオーバーヘッドに対してバランスを取る必要があります。ラージ オブジェクトを取得すると、追加データをあまり使用しない場合は要求の待機時間が延長し、追加の帯域幅コストが発生する可能性があり、メリットはほとんどありません。

Web API と、構造、種類、または基となるデータ ソースの間の依存性を導入しないようにしてください。たとえば、データがリレーショナル データベースにある場合、Web API はそれぞれのテーブルをリソースのコレクションとして公開する必要はありません。Web API をデータベースの抽象化と捉え、必要に応じてデータベースと Web API 間のマッピング レイヤーを導入します。この方法により、データベースの設計や実装が変更されても (正規化されたテーブルのコレクションを含むリレーショナル データベースから、ドキュメント データベースなどの非正規化された NoSQL ストレージ システムへの移行など)、クライアント アプリケーションはこれらの変更による影響を受けません。
> [AZURE.TIP]Web API を支えるデータのソースがデータ ストアである必要はありません。別のサービスや基幹業務アプリケーション、または組織内でオンプレミスで実行している従来のアプリケーションの場合さえあります。

最後に、Web API により実装されるすべての操作を特定のリソースにマッピングできない場合があります。1 つの機能を呼び出し、結果を HTTP 応答メッセージとして返す HTTP GET 応答により、そのような _non-resource_ シナリオを処理できます。加算や減算などの単純な電卓スタイルの操作を実装する Web API は、これらの操作を疑似リソースとして公開し、クエリ文字列を使用して必要なパラメーターを指定する URI を提供できます。たとえば、URI _/add?operand1=99&operand2=1_ に対する GET 要求により、値 100 を含む本文の応答メッセージを返し、URI _/subtract?operand1=50&operand2=20_ に対する GET 要求により、値 30 を含む本文の応答メッセージを返すことができます。ただし、これらの形式の URI は常に慎重に使用してください。

### HTTP メソッドに関する操作の定義

HTTP プロトコルにより、要求にセマンティックな意味を割り当てる多くのメソッドが定義されます。ほとんどの RESTful Web API により使用される一般的な HTTP メソッドは次のとおりです。

- **GET**、指定した URI のリソースのコピーを取得します。応答メッセージの本文には、要求されたリソースの詳細が含まれています。

- **POST**、指定された URI で新しいリソースを作成します。応答メッセージの本文には、新しいリソースの詳細が記載されています。POST は実際にはリソースを作成しない操作をトリガーするのにも使用できます。

- **PUT**、指定した URI のリソースを置き換える、または更新します。応答メッセージの本文では、変更するリソースおよび適用する値が指定されています。

- **DELETE**、指定した URI のリソースを削除します。

> [AZURE.NOTE]HTTP プロトコルではそれほど一般的に使用されない他のメソッドも定義されます。たとえば、リソースへの選択的更新を要求するのに使用される PATCH、リソースの説明を要求するのに使用される HEAD、サーバーによりサポートされる通信オプションについての情報をクライアント情報が取得できるようにする OPTIONS、テストや診断目的で使用可能な情報をクライアントが要求できるようにする TRACE などです。

特定の要求に対する影響は、適用されるリソースがコレクションまたは個別 の項目であるかによって異なります。以下の表では、電子商取引の例を使用しながら、ほとんどの RESTful の実装で使用される一般的な規則をまとめています。これらの要求がすべて実装されない場合があります。具体的なシナリオにより異なります。

| **リソース** | **POST** | **GET** | **PUT** | **DELETE** |
|--------------|----------|---------|---------|------------|
| /customers | 新しい顧客を作成 | すべての顧客を取得 | 顧客を一括更新 (_if implemented_) | すべての顧客を削除 |
| /customers/1 | エラー | 顧客 1 の詳細を取得 | 存在する場合に顧客 1 の詳細を更新。その他の場合はエラーを返す | 顧客 1 を削除 |
| /customers/1/orders | 顧客 1 の新しい注文を作成 | 顧客 1 のすべての注文を取得 | 顧客 1 の注文を一括更新 (_if implemented_) | 顧客 1 のすべての注文を削除 (_if implemented_) |

GET および DELETE 要求の目的は比較的単純ですが、POST および PUT 要求の目的および影響については混乱するかもしれません。

POST 要求は、要求の本文に含まれるデータで新しいリソースを作成します。REST モデルでは、コレクションであるリソースに POST 要求を適用することがよくあります。新しいリソースがコレクションに追加されます。

> [AZURE.NOTE]一部の機能をトリガーする (また、必ずしもデータを返さない) POST 要求を定義することもでき、これらの種類の要求はコレクションに適用できます。たとえば POST 要求を使用することで、給与支払い処理サービスにタイムシートを渡し、計算した税金が応答として返されます。

PUT 要求は既存のリソースを変更します。指定されたリソースが存在しない場合、PUT 要求はエラーを返すことができます (場合によっては、実際にリソースを作成することがあります)。PUT 要求は、個々の項目 (特定の顧客や注文など) であるリソースに適用されることが最も多いとはいえ、実装の頻度は低いもののコレクションに適用できます。PUT 要求はべき等ですが、POST 要求はそうでないことに注意してください。あるアプリケーションが同じ PUT 要求を複数回送信すると結果は常に同じになるはずですが (同じリソースが同じ値で変更される)、あるアプリケーションが同じ POST 要求を繰り返しても、複数のリソースが作成されます。

> [AZURE.NOTE]厳密に言えば、HTTP PUT 要求は既存のリソースを、要求の本文で指定されているリソースと置き換えます。リソースのプロパティの選択を変更するものの、他のプロパティは変更しない場合は、HTTP PATCH 要求を使用して実装します。とはいえ、多くの RESTful の実装ではこの規則が緩和され、どちらの状況でも PUT が使用されます。

### HTTP 要求の処理
多くの HTTP 要求でクライアント アプリケーションにより含められるデータや、Web サーバーからの対応する応答メッセージは、さまざまな形式 (またはメディアの種類) で表示できます。たとえば、顧客または注文の詳細を指定するデータは、XML、JSON、または他のエンコードおよび圧縮された形式として提供できます。要求を送信するクライアント アプリケーションの要求に従い、RESTful Web API は異なるメディアの種類をサポートします。

クライアント アプリケーションがメッセージの本文でデータを返す要求を送信する場合、要求の Accept ヘッダーで処理可能なメディアの種類を指定できます。次のコードは顧客 1 の詳細を取得し、結果が JSON として返されることを要求する HTTP GET 要求を示しています (クライアントは引き続き、応答に含まれるデータのメディアの種類を確認し、返されるデータの形式を確認する必要があります)。

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

Web サーバーがこのメディアの種類をサポートしている場合、メッセージの本文にデータの形式を指定する Content-Type ヘッダーを含む応答により、応答できます。

> [AZURE.NOTE]相互運用性を最大にするため、Accept および Content-Type ヘッダーで参照されるメディアの種類は、一部のカスタム メディアの種類ではなく MIME の種類として認識される必要があります。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":2,"ProductID":4,"Quantity":2,"OrderValue":10.00}
```

Web サーバーが要求されたメディアの種類をサポートしていない場合、異なる形式でデータを送信できます。すべての場合で、Content-Type ヘッダーでメディアの種類を指定する必要があります (_text/xml_ など)。応答メッセージを解析し、メッセージ本文内の結果を適切に解釈することはクライアント アプリケーションの役割です。

この例では、Web サーバーが要求されたデータを正常に取得し、応答ヘッダーで状態コード 200 を渡すことで成功を示しています。一致するデータが見つからない場合は、代わりに状態コード 404 (見つかりません) が返され、応答メッセージの本文には追加情報を含めることができます。この情報の形式は、次の例で示されるように Content-Type ヘッダーにより指定されます。

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

注文 222 が存在しないため、応答メッセージは次のようになります。

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"Message":"No such order"}
```

アプリケーションがリソースを更新するために HTTP PUT 要求を送信すると、リソースの URI が指定され、要求メッセージの本文で変更されるデータが提供されます。Content-Type ヘッダーを使用して、このデータの形式を指定する必要もあります。テキスト ベースの情報で使用される一般的な形式は _application/x-www-form-urlencoded_ で、& の文字で区切られた一連の名前/値のペアで構成されています。次の例は、注文 1 の情報を変更する HTTP PUT 要求を示しています。

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

正常に変更が行われる場合、プロセスが正常に処理されたものの、応答本文にはそれ以上の情報が含まれないことを示す HTTP 204 状態コードで応答するのが理想的です。応答の Location ヘッダーには、新しく更新されたリソースの URI が含まれています。

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [AZURE.TIP]HTTP PUT 要求メッセージ内のデータに日付および時刻の情報が含まれる場合、お使いの Web サービスが、ISO 8601 標準に従って書式設定された日付および時刻を受け入れるようにしてください。

更新するリソースが存在しない場合、Web サーバーは前に説明したように、Not Found 応答により応答できます。または、サーバーが実際にはオブジェクト自体を作成する場合、状態コード HTTP 200 (OK) または HTTP 201 (Created) が返され、応答本文には新しいリソースのデータが含まれます。要求の Content-Type ヘッダーが Web サーバーで処理できないデータ形式を指定する場合は、HTTP 状態コード 415 (Unsupported Media Type) で応答します。

> [AZURE.TIP]コレクションの複数のリソースの更新をバッチ処理できる一括 HTTP PUT 操作の実装を検討してください。PUT 要求はコレクションの URI を指定し、要求本文は変更するリソースの詳細を指定する必要があります。この方法によりおしゃべりを減らし、パフォーマンスを向上させることができます。

新しいリソースを作成する HTTP POST 要求の形式は PUT 要求と類似しています。メッセージ本文に、追加する新しいリソースの詳細が含まれています。ただし、URI は通常、リソースの追加先となるコレクションを指定します。以下の例では新しい注文を作成し、注文コレクションにそれを追加しています。

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=5&Quantity=15&OrderValue=400
```

要求が成功する場合、Web サーバーは HTTP 状態コード 201 (Created) を含むメッセージ コードで応答します。Location ヘッダーには新しく作成されたリソースの URI が含まれ、応答の本文には新しいリソースのコピーが含まれます。Content-Type ヘッダーは次のデータの形式を指定します。

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":99,"ProductID":5,"Quantity":15,"OrderValue":400}
```

> [AZURE.TIP]PUT または POST 要求によって提供されたデータが無効な場合、Web サーバーは HTTP 状態コード 400 (Bad Request) を含むメッセージで応答します。このメッセージの本文には、要求の問題および想定される形式に関する追加情報を含めるか、詳細が記載された URL のリンクを含めることができます。

リソースを削除するには、HTTP DELETE 要求によって、削除するリソースの URI を単に提供します。次の例では注文 99 を削除しようとしています。

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

削除操作が成功すると、Web サーバーは HTTP 状態コード 204 で応答します。このコードは、プロセスが正常に処理されたものの、応答本文にはそれ以上の情報が含まれないことを示します (これは正常な PUT 操作によって返されるのと同じ応答ですが、リソースがもう存在しないため Location ヘッダーがありません)。 削除が非同期的に実行される場合、DELETE 要求で HTTP 状態コード 200 (OK) または 202 (Accepted) を返すこともできます。

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

リソースが見つからない場合、Web サーバーは代わりに 404 (Not Found) メッセージを返します。

> [AZURE.TIP]コレクションに含まれるすべてのリソースを削除する必要がある場合は、強制的にアプリケーションでコレクションから各リソースを順番に削除するのではなく、コレクションの URI を指定した HTTP DELETE 要求を有効にします。

### データのフィルター処理と改ページ

URI をシンプルで直感的に保つように努める必要があります。この点で単一の URI を使用してリソースのコレクションを公開することは役に立ちますが、情報のサブセットしか必要ではないときに、アプリケーションが大量のデータを取得する可能性があります。膨大な量のトラフィックを生成することは Web サーバーのパフォーマンスおよび拡張性に影響を与えるだけでなく、データを要求しているクライアント アプリケーションの応答性にも悪影響を与えます。

たとえば、注文に、注文に対して支払った料金が含まれている場合、特定の値に対してコストがかかるすべての注文を取得する必要があるクライアント アプリケーションは、_/orders_ URI からすべての注文を取得し、これらの注文をローカルでフィルター処理する必要がある場合があります。明らかにこのプロセスの効率はあまり良くありません。Web API をホストするサーバー上のネットワーク帯域幅および処理能力を無駄にします。

1 つの解決策は _/orders/ordervalue\_greater\_than\_n_ などの URI スキームを使用することで、_n_ は注文価格です。とはいえ、この方法は限られた料金を除きどの料金でも現実的ではありません。さらに、他の条件に基づいて注文のクエリを実行する必要がある場合、直感的でない可能性がある名前が記載された長い URI リストが最終的に提供されます。

データをフィルター処理するより良い方法は、_/orders?ordervaluethreshold=n_ など、Web API に渡されるクエリ文字列でフィルター条件を指定することです。この例では、Web API の対応する操作はクエリ文字列の `ordervaluethreshold` パラメーターの解析および処理を行い、HTTP 応答でフィルター処理された結果を返します。

コレクション リソースに対する一部の単純な HTTP GET 要求では、多数の項目が返される可能性があります。これが起こる可能性を解決するため、任意の単一な要求により返されるデータの量を制限するように Web API を設計する必要があります。これを実現するには、取得する項目の最大数 (それ自体が、サービス拒否の攻撃を防ぐのに役立つ上限に依存) と、コレクションへの開始オフセットをユーザーが指定できるようにするクエリ文字列をサポートします。たとえば、URI _/orders?limit=25&offset=50_ のクエリ文字列は、注文コレクションで見つかる 50 番目の注文から始まる 25 件の注文を取得します。データのフィルター処理と同様、Web API で GET 要求を実装する操作は、クエリ文字列の `limit` および `offset` パラメーターの解析および処理を担います。クライアント アプリケーションを支援するには、改ページ調整されたデータを返す GET 要求に、コレクションで利用できるリソースの合計を示す何らかの形式のメタデータも含まれるようにします。他のインテリジェントなページング方法も検討するかもしれません。詳細については、「[API の設計に関する注記: スマート ページング](http://bizcoder.com/api-design-notes-smart-paging)」を参照してください。

取得される時の同様のデータ並べ替え方法に従うことができます。_/orders?sort=ProductID_ など、フィールド名を値として使用する並べ替えパラメーターを指定できます。とはいえ、この方法はキャッシュに有害な影響を与える可能性があることに注意してください (クエリ文字列パラメーターは、キャッシュされたデータのキーとして多くのキャッシュ実装により使用されるリソース識別子の一部を形成します)。

単一のリソース項目に大量のデータが含まれる場合、返されるフィールドを制限 (計画) するように、この方法を拡張できます。たとえば、_/orders?fields=ProductID,Quantity_ など、コンマ区切りのフィールド一覧を受け取るクエリ文字列パラメーターを使用することができます。

> [AZURE.TIP]クエリ文字列内の省略可能なすべてのパラメーターに、意味のある既定値を設定します。たとえば、改ページ調整を実装する場合は `limit` パラメーターを 10、`offset` パラメーターを 0 に設定し、順序付けを実装する場合はリソースのキーに並べ替えパラメーターを設定し、プロジェクションをサポートする場合は`fields` パラメーターをリソースのすべてのフィールドに設定します。

### 大きなバイナリ リソースの処理

単一のリソースに、ファイルやイメージなど、大きなバイナリ フィールドが含まれている可能性があります。信頼性が低く断続的な接続であることが原因となっている伝送の問題を克服し、応答時間を向上させるには、そのようなリソースをクライアント アプリケーションがチャンクで取得できるようにする操作を提供することを検討してください。そのためには、Web API が大きなリソースの GET 要求で Accept-Ranges ヘッダーをサポートし、理想的にはこれらのリソースの HTTP HEAD 要求を実装するようにします。Accept-Ranges ヘッダーは、GET 操作が一部の結果をサポートし、クライアント アプリケーションがバイト数の範囲として指定されたリソースのサブセットを返す GET 要求を送信できることを示します。HEAD 要求は GET 要求に似ていますが、リソースおよび空のメッセージ本文を記述するヘッダーのみを返す点が異なります。クライアント アプリケーションは HEAD 要求を発行し、部分的 GET 要求を使用して、リソースを取得するかどうかを判断します。次の例は、製品イメージに関する情報を取得する HEAD 要求を示しています。

```HTTP
HEAD http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
...
```

応答メッセージには、リソースのサイズ (4,580 バイト) が含まれるヘッダー、および対応する GET 操作が部分的な結果をサポートする Accept-Ranges ヘッダーが含まれます。

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

クライアント アプリケーションはこの情報を使用して、より小さいチャンクのイメージを取得する一連の GET 要求を作成できます。最初の要求では、Range ヘッダーを使用して最初の 2,500 バイトを取得します。

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=0-2499
...
```

応答メッセージは、HTTP 状態コード 206 を返すことで、これが部分的な応答であることを示します。Content-Length ヘッダーはメッセージ本文で返される実際のバイト数を指定し (リソースのサイズではない)、Content-Range ヘッダーはこれがどの部分のリソースであるかを示します (4,580 のうち 0 ～ 2499 バイト):

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

クライアント アプリケーションのその後の要求により、適切な Range ヘッダーを使用することで残りのリソースを取得できます。

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=2500-
...
```

対応する結果メッセージは、次のように表示されます。

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## 関連リソースへのナビゲーションを可能にする HATEOAS アプローチの使用

REST の背後にある主な動機の 1 つは、URI スキームの事前知識を必要とせずに、リソースのセット全体を移動できることです。各 HTTP GET 要求は応答に含まれるハイパーリンクより、要求したオブジェクトに直接関連するリソースを検索するのに必要な情報を返し、これらの各リソースで使用可能な操作を記述する情報も提供されます。この原則は HATEOAS、つまり アプリケーション状態のエンジンとしてのハイパーテキストとして知られます。システムは効率的に Finite State Machine であり、各要求への応答には、ある状態を別の状態に移すのに必要な情報が含まれています。他の情報は必要ありません。

> [AZURE.NOTE]現在、HATEOAS の原則をモデル化する方法を定義する標準や仕様はありません。このセクションで示されている例は、可能性のある一つのソリューションを示しています。

例として、顧客と注文のリレーションシップを処理するには、特定の注文の応答で返されるデータに、注文を行った顧客を識別するハイパーリンク形式の URI、およびその顧客に対して実行できる操作 を含めます。

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

応答メッセージの本文には、リレーションシップの性質を指定する `Links` アレイ (コード例で強調表示されている) (_Customer_)、顧客の URI (\__http://adventure-works.com/customers/3_)、この顧客の詳細を取得する方法 (_GET_)、この情報を取得するのに Web サーバーがサポートする MIME の種類 (_text/xml_ と _application/json_) が含まれます。クライアント アプリケーションが顧客の詳細を取得するのに必要な情報はこれですべてです。さらに Links アレイには、PUT (Web サーバーがクライアントに提供を期待する形式とともに顧客を変更する) や DELETE など、実行可能な他の操作のリンクも含まれます。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[(some links omitted){"Relationship":"customer","HRef":" http://adventure-works.com/customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":"
customer","HRef":" http://adventure-works.com /customers/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"customer","HRef":" http://adventure-works.com /customers/3","Action":"DELETE","LinkedResourceMIMETypes":[]}]}
```

完全を期すために、Links アレイには取得したリソースに関する自己参照型の情報も含めるようにします。これらのリンクは、以前の例から省略されていますが、次のコードでは強調表示されています。これらのリンクで、これが操作により返されるリソースの参照であるのを示すために、リレーションシップ _self_ が使用されることに注意してください。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[{"Relationship":"self","HRef":" http://adventure-works.com/orders/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" self","HRef":" http://adventure-works.com /orders/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"self","HRef":" http://adventure-works.com /orders/3", "Action":"DELETE","LinkedResourceMIMETypes":[]},{"Relationship":"customer",
"HRef":" http://adventure-works.com /customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" customer" (customer links omitted)}]}
```

この方法を効率的にするために、クライアント アプリケーションでこの追加情報を取得および解析する準備を行う必要があります。

## RESTful Web API のバージョン管理

最も単純な状況を除き、すべての状況では Web API が静的であることはほとんどありません。ビジネスの要求は変化するため、新しいリソースのコレクションが加わり、リソース間のリレーションシップが変化し、リソース内のデータ構造が修正される可能性があります。新しいまたは異なる要件を処理するために Web API を更新することは比較的簡単なプロセスですが、そのような変化が Web API を消費するクライアント アプリケーションに対して与える影響を考慮する必要があります。問題なのは、Web API を設計および実装している開発者はその API を完全に制御できるものの、リモートで操作しているサードパーティの組織により構築されたクライアント アプリケーションを、その開発者が同程度には制御できないことです。まず必要なのは、新しいクライアント アプリケーションが新しい機能やリソースを活用できるようにしながら、既存のアプリケーションに変更なく機能を続行させることです。

バージョン管理により Web API は公開する機能およびリソースを示すことができ、クライアント アプリケーションは特定のバージョンの機能またはリソースへの要求を送信できます。次のセクションではいくつかの方法について説明しますが、それぞれに独自の利点とトレードオフがあります。

### バージョン管理なし

これは最も単純な方法で、一部の内部 API で許容されます。大きな変更は新しいリソースまたは新しいリンクとして示されます。既存のリソースにコンテンツを追加しても、このコンテンツの表示を想定していないクライアント アプリケーションはそれを無視するだけであるため、重大な変更はありません。

たとえば、URI \__http://adventure-works.com/customers/3_ への要求により、次のクライアント アプリケーションにより期待される `Id`、`Name`、および `Address` フィールドを含む単一の顧客に関する詳細が返されます。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

> [AZURE.NOTE]簡潔でわかりやすくするために、このセクションで示す応答例には HATEOAS リンクは含まれません。

`DateCreated` フィールドが顧客リソースのスキーマに追加される場合、応答は次のようになります。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":"1 Microsoft Way Redmond WA 98053"}]
```

既存のクライアント アプリケーションが認識されていないフィールドを無視できる場合は、正常に機能を続行する場合がありますが、新しいクライアント アプリケーションではこの新しいフィールドを処理するように設計できます。とはいえ、リソースのスキーマにさらに重大な変更があるか (フィールドの削除や名前の変更など)、リソース間のリレーションシップが変更される場合、これらは既存のクライアント アプリケーションが正常に機能できなくなる重大な変更となる可能性があります。このような状況では、次の方法のいずれかを検討してください。

### URI のバージョン管理

Web API を変更するか、リソースのスキーマを変更するたびに、バージョン番号を各リソースの URI に追加します。既存の URI はこれまでと同様に動作を続け、元のスキーマに準拠するリソースを返します。

前の例を拡張し、`Address` フィールドをアドレスの各構成部分 (`StreetAddress`、`City`、`State`、`ZipCode` など) を含むサブフィールドに再構築する場合、このバージョンのリソースは http://adventure-works.com/v2/customers/3 などのバージョン番号を含む URI より公開できます:

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

このバージョン管理メカニズムは非常に単純ですが、適切なエンドポイントに要求をルーティングするサーバーにより変わります。とはいえ、Web API は何度も繰り返すことで成熟し、サーバーは多くの異なるバージョンをサポートする必要があるため、扱いにくくなる可能性があります。また、純正主義者の観点からすると、すべての場合でクライアント アプリケーションは同じデータを取得しているため (顧客 3)、URI はバージョンによってそれほど異なるべきではありません。すべてのリンクで URI にバージョン番号が含まれる必要があるため、このスキームによっても HATEOAS の実装が複雑になります。

### クエリ文字列のバージョン管理

複数の URI を提供するのではなく、\__http://adventure-works.com/customers/3?version=2_ など、HTTP 要求に追加されたクエリ文字列内のパラメーターを使用してリソースのバージョンを指定できます。バージョン パラメーターがより古いクライアント アプリケーションで省略される場合、1 などの有効な値を既定にします。

この方法には同じリソースからは常に同じ URI が取得されるというセマンティックな利点がありますが、クエリ文字列を解析し、適切な HTTP 応答を返送する要求を処理するコードにより異なります。この方法は、URI のバージョン管理メカニズムとして HATEOAS を実装する同様の複雑さによっても影響されます。

> [AZURE.NOTE]一部の古い Web ブラウザーおよび Web プロキシは、URL にクエリ文字列を含む要求の応答をキャッシュしません。これは、Web API を使用し、そのような Web ブラウザー内から実行する Web アプリケーションのパフォーマンスに悪影響を与える可能性があります。

### ヘッダーのバージョン管理

バージョン番号をクエリ文字列パラメーターとして追加するのではなく、リソースのバージョンを示すカスタム ヘッダーを実装できます。この方法ではクライアント アプリケーションにより任意の要求に適切なヘッダーを追加する必要がありますが、バージョン ヘッダーが省略されている場合、クライアントの要求を処理するコードは既定値 (バージョン 1) を使用できます。次の例では、_Custom-Header_ という名前のカスタム ヘッダーを使用します。このヘッダーの値は、Web API のバージョンを示します。

バージョン 1:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

バージョン 2:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

前の 2 つの方法と同様、HATEOAS の実装では任意のリンクに適切なカスタム ヘッダーを追加することが必要です。

### メディアの種類のバージョン管理

クライアント アプリケーションが Web サーバーに HTTP GET 要求を送信する場合、このガイダンスで既に説明したように、Accept ヘッダーを使用して処理できるコンテンツの書式を指定する必要があります。多くの場合、_Accept_ ヘッダーの目的は、応答の本文が XML、JSON、またはクライアントが解析可能な他の一般的な形式であるかどうかをクライアント アプリケーションが指定できるようにすることです。とはいえ、想定しているリソースのバージョンをクライアント アプリケーションが示すことができるようにする情報を含むカスタム メディアの種類を定義できます。次の例は、_application/vnd.adventure-works.v1+json_ の値を含む _Accept_ ヘッダーを指定する要求を示します。_vnd.adventure-works.v1_ 要素は Web サーバーに対し、バージョン 1 のリソースを返すように指示しますが、_json_ 要素は応答本文の形式が JSON であるように指定します。

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

要求を処理しているコードは、_Accept_ ヘッダーを処理し、可能な限りそれを使用します (クライアント アプリケーションは複数の形式を _Accept_ ヘッダーで指定する場合があり、その場合 Web サーバーは最も適切な形式を応答本文に選択できます)。Web サーバーは次のように Content-Type ヘッダーを使用することで、応答本文のデータの形式を確認します。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Accept ヘッダーにより既知のメディアの種類が指定されない場合、Web サーバーは HTTP 406 (Not Acceptable) 応答メッセージを生成するか、既定のメディアの種類でメッセージを返すことができます。

この方法が最も純粋と思われるバージョン管理メカニズムで、当然ながら HATEOAS で役立ち、リソース リンクの関連データの MIME の種類を含めることができます。

> [AZURE.NOTE]バージョン管理の方法を選択すると、パフォーマンスに対する影響、特に Web サーバーでのキャッシュについて検討する必要もあります。同じ URI/クエリ文字列の組み合わせは同じデータを毎回参照するため、URI バージョン管理および Query String バージョン管理スキームはキャッシュに適しています。

> 通常、Header バージョン管理および Media Type バージョン管理メカニズムでは、カスタム ヘッダーまたは Accept ヘッダーの値を確認するのに追加のロジックが必要です。大規模な環境では、多くのクライアントで異なるバージョンの Web API が使用されているため、サーバー側のキャッシュの重複データ量が著しく増加します。この問題が深刻になるのは、クライアント アプリケーションがキャッシュを実装するプロキシを経由して Web サーバーと通信する場合です。また、キャッシュに要求されたデータのコピーが現在保持されていない場合は Web サーバーに要求の転送のみ行います。

## 詳細

- [RESTful Cookbook](http://restcookbook.com/) では、RESTful API の構築に関する概要が説明されています。
- Web [API Checklist](https://mathieu.fenniak.net/the-api-checklist/) には、Web API を設計および実装するときに検討する、役立つ項目の一覧が含まれています。

<!---HONumber=August15_HO6-->