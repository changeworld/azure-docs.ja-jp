<properties
   pageTitle="可用性のチェックリスト |Microsoft Azure"
   description="設計時の可用性に関する問題のガイダンスを提供するチェックリスト。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/01/2016"
   ms.author="masashin"/>

# 可用性のチェックリスト

![](media/best-practices-availability-checklist/pnp-logo.png)

## アプリケーションの設計

- **すべての単一障害点を回避します。** 単一障害点が可用性に影響することを防ぐため、すべてのコンポーネント、サービス、リソース、およびコンピューティング インスタンスを複数のインスタンスとして展開する必要があります。これには認証メカニズムが含まれます。複数のインスタンスを使用するための構成ができるように、そして自動的にエラーを検出して要求をエラーのないインスタンスにリダイレクトする (これはプラットフォームでは自動的に行われません) ようにアプリケーションを設計します。
- **ワークロードを異なるサービス レベル アグリーメントごとに分解します。** サービスが重要なワークロードとあまり重要ではないワークロードで構成されている場合は、それらを異なる方法で管理し、それぞれの可用性の要件を満たすようにサービスの機能とインスタンスの数を指定します。
- **サービスの依存関係を最少化し、把握します。** 可能な限り、使用するサービスの数を最小化し、システムに存在するすべての機能とサービスの依存関係を把握しておきます。これには、それぞれの依存関係の性質、および各アプリケーションのエラーまたはパフォーマンス低下が全体に与える影響が含まれます。Microsoft はほとんどのサービスで 99.9% 以上の可用性を保証しますが、これはあるアプリケーションが依存するどの追加サービスでもシステム全体の可用性の SLA を 0.1% 低下させる可能性があることを意味します。
- 重複した要求による問題が発生しないように、**可能な限り、タスクとメッセージがべき等になる (安全に繰り返しできる) ように設計します**。たとえば、サービスはプロデューサーとして動作するシステムの他の部分から要求として送信されたメッセージを処理する、コンシューマーとして動作することができます。メッセージが処理された後、その処理が確認される前にコンシューマーでエラーが発生した場合、プロデューサーがコンシューマーの別のインスタンスが処理できる繰り返しの要求を送信する場合があります。このため、前に実行された操作を繰り返すことで結果が無効と表示されないように、コンシューマーとコンシューマーが実行する操作がべき等である必要があります。これは、重複したメッセージの検出、または競合処理のためのオプティミスティックな方法を使用した一貫性の確認を意味する場合があります。
- **重要なトランザクションの高可用性を実装する、メッセージ ブローカーを使用します。** タスクを開始したり、リモート サービスにアクセスしたりする多くのシナリオは、メッセージングを使用してアプリケーションとターゲット サービスの間の指示を渡します。最適なパフォーマンスのため、アプリケーションはメッセージを送信してから、応答を待つことなくより別の要求の処理に戻ることができる必要があります。メッセージの配信を保証するために、このメッセージング システムは高可用性を実現する必要があります。Azure Service Bus のメッセージ キューは、_少なくとも 1 回_セマンティクスを実装します。つまり、キューに投稿された各メッセージは失われますが、特定の状況では重複したコピーが配信される可能性があります。メッセージの処理がべき等である場合 (前の項目を参照)、繰り返しの配信は問題にはなりません。
- **適切に機能が低下するアプリケーションを設計します**。たとえば、リソースの制限に達すると、ユーザーへの影響を最小限に抑える適切なアクションを取るようにします。アプリケーションの負荷が 1 つ以上の部分の容量を超え、これによって可用性が低下し、接続エラーが発生する可能性もあります。これを軽減するにはスケーリングが役立ちますが、リソースの可用性やコストなどのその他の要因によって制限に到達する可能性があります。この場合に、自動的に機能が適切に低下するようにアプリケーションを設計します。たとえば、電子商取引システムの注文処理サブシステムに負荷がかかっている (または完全にエラーが発生している) 場合、それを一時的に無効にして、他の機能 (製品カタログの参照など) を続行することができます。エラーが発生しているサブシステムへの要求を遅らせることが適切な場合があります。たとえば、顧客が注文を送信し、その注文を注文サブシステムが再度使用可能になったら後で処理できるように保存することができます。
- **急速なバースト イベントを適切に処理します。** ほとんどのアプリケーションは、朝一番のビジネス アプリケーションのピークや新製品が電子商取引のサイトでリリースされたときなど、時間の経過と共に変化するワークロードを処理する必要があります。自動スケールは負荷の処理に役立ちますが、追加のインスタンスがオンラインになり、要求を処理するまでに時間がかかる場合があります。アクティビティで突然、予期しないバーストが発生してもアプリケーションで過負荷が発生しないようにします。これには、キューが容量に近づいたら使用するサービスに要求のキューを入れ、適切に機能が低下するように設計します。バーストしない条件下で、キューを排出して未処理の要求を処理するために十分なパフォーマンスと容量を確保できることを確認します。詳細については、「[キュー ベースの負荷平準化パターン](https://msdn.microsoft.com/library/dn589783.aspx)」を参照してください。

## 展開と保守

- **各サービスのロールの複数のインスタンスを展開します。** Microsoft は作成して展開するサービスの可用性を保証しますが、このような保証はサービス内の各ロールの少なくとも 2 つのインスタンスを展開する場合にのみ有効です。これにより、一方のロールをアクティブにしたまま、もう一方を使用不可にすることができます。これはクライアントの活動を中断せずにライブ システムに更新を展開する必要がある場合に特に重要です。一部のインスタンスをオンラインにしたまま、他のインスタンスを停止して個別にアップグレードすることができます。
- **複数のデータ センターでアプリケーションをホストします。** めったにありませんが、自然災害やインターネット障害などの事象により、データ センター全体がオフラインになる可能性があります。最大限の可用性を提供するため、重要なビジネス アプリケーションは複数のデータ センターでホストする必要があります。これにより、ローカル ユーザーの待機時間が短縮され、アプリケーションの更新時に柔軟性が向上する可能性もあります。
- **展開および保守のタスクを自動化してテストします。** 分散アプリケーションは、連携して動作する必要がある、複数の部分で構成されます。したがって、スクリプトやデプロイ アプリケーションなど、テスト済みで実証済みのメカニズムを使用してデプロイを自動化する必要があります。これらのメカニズムでは、構成を更新および検証し、デプロイ プロセスを自動化することができます。アプリケーションのすべてまたは一部の更新も実行するには、自動化された手法も使用する必要があります。エラーによってさらにダウンタイムが発生しないように、このすべてのプロセスを完全にテストすることが不可欠です。すべての展開ツールには展開されたアプリケーションを保護するための、適切なセキュリティ制限が必要です。展開ポリシーは慎重に定義して適用し、人間の介入は最小限に抑えてください。
- **プラットフォームのステージングおよび運用機能の使用を検討します** (使用できる場合)。たとえば、Azure Cloud Services のステージングおよび運用環境を使用すると、仮想 IP アドレス スワップ (VIP スワップ) によってアプリケーションを簡単に切り替えることができます。ただし、内部設置型でのステージングや、異なるバージョンのアプリケーションの同時展開によってユーザーを段階的に移行する場合は、VIP スワップの操作を使用できない場合があります。
- 可能な場合はインスタンスを**再利用せずに、構成の変更を適用**します。多くの場合、ロールを再起動することなく、Azure アプリケーションまたはサービスの構成設定を変更できます。ロールは、構成の変更を検出し、それをアプリケーション内のコンポーネントに適用できるイベントを公開します。ただし、コア プラットフォーム設定に対する一部の変更では、ロールの再起動が必要になります。コンポーネントとサービスを構築する場合は、アプリケーション全体を再起動せずに構成設定に変更を適用できるように設計することで、可用性を最大化し、ダウンタイムを最小限に抑えてください。
- **更新中のダウンタイムをゼロにするためのアップグレード ドメインを使用します。** アップグレード ドメインには Web や worker ロールなどの Azure コンピュート ユニットが割り当てられます。ローリング アップデートの実行時にアップグレード ドメイン内の各ロールが順番に停止し、更新され、起動するように、アップグレード ドメインはロール インスタンスをグループ化します。これにより、アプリケーションの可用性への影響が最小限に抑えられます。サービスを展開するときにサービスに対していくつのアップグレード ドメインを作成するかを指定することができます。

	> [AZURE.NOTE] すべてのロール インスタンスに影響するエラーがなるべく発生しないようにするため、ロールは障害ドメイン全体にも分散され、それぞれがサーバー ラック、処理能力、冷却に関して他の障害ドメインと適切に独立しています。この分散は自動的に行われるため、制御することはできません。

- **Azure の仮想マシンの可用性セットを構成します。** 同じ可用性セットに 2 つ以上の仮想マシンを配置することで、これらの仮想マシンが同じ障害ドメインに展開されることがなくなります。可用性を最大化するには、システムで使用される重要な各仮想マシンに複数のインスタンスを作成し、そのインスタンスを同じ可用性セットに配置する必要があります。さまざまな目的に合う複数の仮想マシンを実行している場合は、仮想マシンごとに可用性セットを作成してください。各仮想マシンのインスタンスを各可用性セットに追加します。たとえば、Web サーバーおよびレポート サーバーとして機能する別個の仮想マシンを作成した場合は、Web サーバーに対して可用性セットを 1 つ作成し、レポート サーバーに対して別の可用性セットを作成します。Web サーバーの可用性セットには Web サーバーの仮想マシンのインスタンスを追加し、レポート サーバーの可用性セットにはレポート サーバーの仮想マシンのインスタンスを追加します。

## データ管理

- ローカルおよび地理的な冗長性による**データ レプリケーションを利用します**。Azure Storage 内のデータは、インフラストラクチャの障害発生時の損失を防ぐために自動的にレプリケートされ、このレプリケーションの一部の側面を構成することができます。たとえば、データの読み取り専用コピーを複数の地理的地域 (Read-Access Geo Redundant Storage または RA-GRS と呼ばれます) にレプリケートすることができます。RA-GRS を使用すると、追加料金が課されることに注意してください。詳細については、「[Azure Storage 料金](https://azure.microsoft.com/pricing/details/storage/)」をご覧ください。
- 可能な限り、**オプティミスティック同時実行制御、および結果整合性を使用します**。ロックによってリソースへのアクセスをブロックするトランザクション (ペシミスティック同時実行制御) では、パフォーマンスが低下し、可用性も大幅に低下する場合があります。これらの問題は、分散システムで特に深刻になります。多くの場合、パーティション分割などの入念な設計や技法によって、更新プログラムの競合が発生する可能性を最小限に抑えることができます。データがレプリケートされたり、個別に更新されたスコアから読み取られたりすると、最終段階でのみ、データの一貫性が確保されます。ただし、通常、その利点は、即座に一貫性を確保するトランザクションを使用できることに対する効果を大きく上回ります。
- **定期的なバックアップとポイントインタイム リストアを使用**し、回復ポイントの目標 (RPO) を満たしていることを確認します。他の場所には保存されないデータを定期的に自動でバックアップして、障害発生時でもデータとアプリケーション自体の両方を安全に復元できることを確認します。障害、エラー、または悪意のある操作によって発生するエラーと不整合はすべてのストア間でレプリケートされるため、データ レプリケーションはバックアップ機能ではありません。バックアップ プロセスは、転送中のデータと格納中のデータを保護するため、セキュリティで保護する必要があります。データベースまたはデータ ストアの一部は通常、トランザクション ログを使用して前の時点まで回復することができます。Microsoft Azure は、Azure SQL Database に格納されたデータのバックアップ機能を提供します。データは、Azure Blob Storage 上のバックアップ パッケージにエクスポートされるため、セキュリティで保護されたオンプレミスの場所にダウンロードして格納することができます。
- **Azure Redis Cache のセカンダリ コピーを保守するため、高可用性オプションを有効にします。** Azure Redis Cache を使用する場合は、標準のオプションを選択して内容のセカンダリ コピーを保守します。詳細については、「[キャッシュの作成](https://msdn.microsoft.com/library/dn690516.aspx)」を参照してください。

## エラーと障害

- **タイムアウトの概念を紹介します。** サービスとリソースが使用不可能になり、要求が失敗する原因となる場合があります。適用するタイムアウトが各サービスまたはリソースに加え、それらにアクセスしているクライアントに適切であるかどうかを確認します (コンテキストやクライアントが実行しているアクションによっては、クライアントの特定のインスタンスのタイムアウトを長くした方が適している場合もあります)。 タイムアウトが短すぎると、待機時間が非常に長いサービスとリソースで過剰な再試行操作が発生する可能性があります。また、タイムアウトが長すぎると、大量の要求がキューにあり、サービスまたはリソースの応答を待機している場合にブロックが発生する可能性があります。
- **一時的な障害により失敗した操作を再試行します。** 本来は自動的な接続再試行をサポートしていないすべてのサービスおよびリソースにアクセスするための再試行戦略を設計します。リソースのオーバーロードを防ぎ、キューに登録されている要求を適切に復元して処理できるように、障害の数が増えるにつれて再試行の間の遅延が増加するような戦略を使用します。非常に短い遅延の再試行が連続すると、問題が悪化する可能性があります。
- リモート サービスが使用できない場合は**連鎖的な障害を回避するため、要求の送信を停止します**。 一時的またはその他の障害で、接続の部分的な損失からサービス全体の障害まで重要度が多岐にわたる場合、通常の状態に戻るまでに予想よりも時間がかかる場合があります。さらに、サービスが非常にビジーな状態で、メモリ、スレッド、データベース接続などの重要なシステム リソースが使用されていると、システムの 1 つの部分の障害が連鎖的な障害に発展し、多くの操作がブロックされる場合があります。アプリケーションは、成功の見込みのない操作を継続的に再試行するのではなく、操作が失敗していることを迅速に受け入れ、このエラーを適切に処理する必要があります。Circuit Breaker パターンを使用して、指定した期間の特定の操作の要求を拒否することができます。詳細については、「[Circuit Breaker Pattern (Circuit Breaker パターン)](https://msdn.microsoft.com/library/dn589784.aspx)」を参照してください。
- **複数のコンポーネントを構成またはフォールバックして**、特定のサービスがオフラインや使用不可になる影響を軽減します。なるべく操作や既存の接続に影響を与えずに複数のインスタンスを活用するようなアプリケーションを設計します。可用性を最大化するため、複数のインスタンスを使用してそれらの間に要求を分散し、失敗したインスタンスへの要求の送信を検出して回避します。
- 可能な限り、**別のサービスまたはワークフローにフォールバックします**。たとえば、SQL Database への書き込みに失敗した場合は、一時的にデータを Blob Storage に格納してください。サービスが利用可能になったら、Blob Storage への書き込みを SQL Database に再実行する機能を提供します。失敗した操作には、コンポーネントまたはサービスが失敗してもアプリケーションが動作し続けられるような代替の操作がある場合もあります。可能であれば、エラーを検出し、適切な代替機能を提供できる他のサービスか、プライマリ サービスがオフラインの間もコアな操作を維持できるバックアップ機能または制限された機能のインスタンスに要求をリダイレクトします。

## 監視と障害復旧

- 運用スタッフに状況を報告するため、**可能性の高い障害や障害イベントの豊富なインストルメンテーションを提供します**。可能性が高いがまだ発生していない障害については、運用スタッフが原因を判別し、状況を緩和し、システムが引き続き使用できるようにするための十分なデータを提供します。既に発生している障害については、アプリケーションがユーザーに適切なエラー メッセージを返しながらも、機能が制限された状態で実行を続行しようとする必要があります。どの場合も、監視システムは運用スタッフが迅速な回復が行えるように包括的な詳細をキャプチャし、必要に応じてデザイナーと開発者が状況の再発を防ぐため、システムを修正する必要があります。
- **チェック機能を実装することでシステム正常性を監視します。** アプリケーションの正常性とパフォーマンスは、時間の経過と共に低下し、障害が発生するまで気づかない場合があります。アプリケーションの外部から定期的に実行されるプローブやチェック機能を実装してください。これらのチェックは、アプリケーション全体、アプリケーションの個々 の部分、アプリケーションが使用する個々 のサービス、または個々 のコンポーネントの応答時間を測定するのと同じくらい単純にすることができます。チェック機能はプロセスを実行することで、有効な結果が生成され、待機時間とチェック機能が測定され、システムから情報が抽出されていることを確認できます。
- **すべてのフェールオーバーおよびフォールバック システムを定期的にテストすることで**、期待どおりに使用でき、動作することを確認します。システムおよび操作の変更はフェールオーバーおよびフォールバック機能に影響を与える可能性がありますが、その影響はメインのシステムで障害が発生するか、オーバーロードが発生するまで検出されない場合があります。実行時に、発生中の問題を補正しなければならなくなる前にテストしてください。
- **監視システムをテストします。** 自動フェールオーバーとフォールバック システム、およびダッシュボードを使用したシステム正常性とパフォーマンスの手動の視覚化はすべて、正常に機能している監視およびインストルメンテーションに依存しています。これらの要素で障害、重要な情報の不足、不適切なデータの報告が発生すると、オペレーターはシステムが正常でないことやシステムで障害が発生していることに気付かない可能性があります。
- **実行時間の長いワークフローの進行状況を追跡し**、障害発生時に再試行します。実行時間の長いワークフローは多くの場合、複数の手順で構成されています。各手順が独立していること、および各手順の再試行によってワークフロー全体のロールバックや、複数の補正トランザクションを実行しなければならない事態が最小限に抑えられることを確認します。[Scheduler Agent Supervisor パターン](https://msdn.microsoft.com/library/dn589780.aspx)などのパターンを実装して、実行時間の長いワークフローの進行状況を監視し、管理します。
- **障害復旧を計画します。** メイン システムの一部またはすべてが使用できなくなる可能性のある、あらゆる種類の障害から回復するための文書化され、合意され、完全にテストされた計画があることを確認します。手順を定期的にテストし、すべての運用スタッフがプロセスについて理解していることを確認します。

<!---HONumber=AcomDC_0406_2016-->