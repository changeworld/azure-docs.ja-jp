<properties
   pageTitle="Service Fabric の正常性モニタリングの概要"
   description="この記事では、正常性エンティティ、レポート、および評価を含む、 Azure Service Fabric 正常性監視モデルについて説明します。"
   services="service-fabric"
   documentationCenter=".net"
   authors="oanapl"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="06/16/2015"
   ms.author="oanapl"/>

# Service Fabric の正常性モニタリングの概要
Service Fabric に導入している正常性モデルは、機能が豊富で、柔軟性と拡張可能性を備えた正常性評価とレポートを提供します。これには、クラスターの状態とその内部で実行されているサービスの状態をほぼリアルタイムで監視する機能が含まれます。正常性の情報を取得し、潜在的な問題の解決手段を事前に講じることで、問題が連鎖的に発生して大規模なシステム停止を引き起こす事態を防げます。一般的なモデルでは、サービスがローカルのビューに基づくレポートを送信し、その情報が集計されて、クラスター レベル全体のビューが提供されます。

Service Fabric のコンポーネントは、この正常性モデルを使用して現在の状態を報告します。アプリケーションからの正常性レポートにも同じメカニズムを使用できます。設定条件に応じた正常性レポートの品質と機能の多様性によって、実行アプリケーションの問題点の検出と修正がどれほどスムーズに行えるかが決まります。

> [AZURE.NOTE]正常性サブシステムは、そもそも監視付きアップグレードの必要性から生まれました。Service Fabric は、ダウン タイムなしで、ユーザーの介入は最小限か皆無に抑え、かつクラスターとアプリケーションの可用性を完全に維持しつつ、クラスターやアプリケーションの監視付きアップグレードを実現します。そのために、アップグレードは構成済みアップグレード ポリシーに照らして正常性をチェックし、正常性が希望のしきい値を満たす場合のみアップグレードの続行を認めます。それ以外の場合、アップグレードは自動的にロールバックするか、一時停止して管理者に問題を解決する機会を提供します。アプリケーションのアップグレードの詳細については、[この記事](service-fabric-application-upgrade.md)を参照してください。

## 正常性ストア
クラスターのエンティティに関する正常性関連の情報は、容易に取得して評価できるように、正常性ストアに保持されています。これは、Service Fabric の永続的ステートフル サービスとして、高可用性とスケーラビリティを確保するために実装されています。これは、ファブリック:/システム アプリケーションの一部であり、クラスターが稼動し始めると、すぐに使用可能になります。

## 正常性エンティティと階層
正常性エンティティは異なるエンティティ間の相互作用と依存関係をキャプチャする論理階層に整理されます。このエンティティと階層は、Service Fabric のコンポーネントから受信したレポートに基づき、正常性ストアによって自動的に構築されます。

正常性エンティティは、Service Fabric エンティティを反映します (例: 正常性アプリケーション エンティティはクラスターにデプロイされているアプリケーション インスタンスと一致し、正常性ノード エンティティは Service Fabric クラスター ノードと一致します)。正常性の階層は、システム エンティティの相互作用をキャプチャしており、高度な正常性評価の基盤になります。主要な Service Fabric の概念については、「[Service Fabric の技術概要](service-fabric-technical-overview.md)」を参照してください。アプリケーションに関する詳細については、「[Service Fabric アプリケーション モデル](service-fabric-application-model.md)」を参照してください。

正常性エンティティと階層により、クラスターとアプリケーションのレポート作成、デバッグ、および監視が効果的に行えます。正常性モデルにより、クラスター内にある数多くの変動要素の正常性に関する、正確かつ**粒度の細かい**レポートが可能になります。

![正常性エンティティ。][1] 正常性エンティティは、親子関係に基づいて、階層に整理されます。

[1]: ./media/service-fabric-health-introduction/servicefabric-health-hierarchy.png

正常性エンティティは、次のとおりです。

- **クラスター**。Service Fabric クラスターの正常性を表します。クラスターの正常性レポートには、クラスター全体に影響を与え、1 つまたは複数の異常な子には絞ることのできない条件が記述されます。例: ネットワーク パーティション分割または通信の問題による、クラスターのスプリット ブレイン。

- **ノード**。Service Fabric ノードの正常性を表します。ノードの正常性レポートには、ノードの機能に影響を与え、通常はノード上で実行中のデプロイされたエンティティすべてに影響を与える条件が記述されます。例: ノードのディスク領域 (または、メモリや接続など、他のコンピューター全体のプロパティ) が不足している、あるいはノードが停止している。ノードのエンティティは、ノード名 (文字列) で識別されます。

- **アプリケーション**クラスターで実行されているアプリケーション インスタンスの正常性を表します。アプリケーションの正常性レポートには、アプリケーションの全体的な正常性に影響を与え、個々の子 (サービスまたはデプロイされたアプリケーション) に絞ることができない条件が記述されます。例: アプリケーション内の異なるサービス間のエンド ツー エンド対話。アプリケーション エンティティは、アプリケーション名 (URI) で識別されます。

- **サービス**。クラスターで実行中のサービスの正常性を表します。サービスの正常性レポートには、サービスの全体的な正常性に影響を与え、パーティションまたはレプリカに絞ることができない条件が記述されます。例: すべてのパーティションに問題を引き起こしているサービス構成 (ポートまたは外部ファイルの共有など)。サービス エンティティは、サービス名 (URI) で識別されます。

- **パーティション**。サービス パーティションの正常性を表します。パーティションの正常性レポートには、レプリカ セット全体に影響を与える条件が記述されます。例: レプリカ数がターゲット数を下回るか、パーティションがクォーラム損失の状態にある。パーティション エンティティは、パーティション ID (GUID) で識別されます。

- **レプリカ**。ステートフル サービス レプリカ、またはステートレス サービス インスタンスの正常性を表します。これは最小単位のウォッチドッグであり、システム コンポーネントはアプリケーションに関するレポートを行えます。例: ステートフル サービスでは、プライマリ レプリカがセカンダリに操作をレプリケートできない場合、もしくはレプリケーションが予期したペースで進展しない場合、プライマリ レプリカはレポートを行います。ステートレス インスタンスは、リソースが不足するか、接続の問題が発生した場合、レポートを行います。レプリカ エンティティは、パーティション ID (GUID) およびレプリカまたはインスタンスの ID (Long 型) によって識別されます。

- **DeployedApplication**。*ノードで実行されているアプリケーション*の正常性を表します。デプロイされたアプリケーションの正常性レポートには、ノード上のアプリケーションに固有で、同じノードにデプロイされているサービス パッケージには絞ることができない条件が記述されます。例: アプリケーション パッケージをそのノードにダウンロードすることができない。あるいは、アプリケーションのセキュリティ プリンシパルをノードに設定する際に問題が発生する。デプロイされたアプリケーションは、アプリケーション名 (URI) とノード名 (文字列) で識別されます。

- **DeployedServicePackage**。クラスター内のノードで実行されているアプリケーションのサービス パッケージの正常性を表します。これには、特定のサービス パッケージに固有で、同じアプリケーションの同じノードにある他のサービス パッケージには影響を与えない条件が記述されます。例: サービス パッケージのコード パッケージを起動できない。あるいは、構成パッケージを読み取ることができない。デプロイされたサービス パッケージは、アプリケーション名 (URI)、ノード名 (文字列)、およびサービス マニフェスト名 (文字列) で識別されます。

正常性モデルの粒度により、問題の検出と修正が容易になります。たとえば、サービスが応答していない場合、アプリケーション インスタンスが異常であると報告することも可能ですが、これは理想的とは言えません。問題がアプリケーション内のすべてのサービスに影響を与えているわけではない場合もあるからです。レポートは異常なサービスに適用される必要があります。あるいは、特定の子パーティションを指定できるだけの情報がある場合は、そのパーティションに適用される必要があります。このデータは、自動的に階層を通過して表面化します。たとえば、異常なパーティションは、サービスおよびアプリケーションのレベルで視覚化されます。このことは、問題の根本原因を素早く特定し解決するのに役立ちます。

正常性の階層は親子関係で構成されています。クラスターはノードとアプリケーションで構成され、アプリケーションはサービスとデプロイされたアプリケーションを含んでおり、デプロイされたアプリケーションはデプロイされたサービス パッケージを含んでいます。サービスはパーティションを含んでおり、各パーティションは 1 つまたは複数のレプリカを含んでいます。ノードとデプロイされたエンティティの間には特別な関係があります。ノード対して権限を持つシステム コンポーネント (Failover Manager サービス) によってノードの異常が報告された場合、デプロイされたアプリケーション、サービス パッケージ、そのノード上にデプロイされるレプリカに影響が及びます。

正常性の階層は、最新の正常性レポートに基づくシステムの最新の状態を表します。この情報は、ほぼリアルタイムの情報です。内部および外部のウォッチドッグは、アプリケーション固有のロジックまたはカスタム監視付き条件に基づいて、同じエンティティに関して報告する場合があります。ユーザー レポートはシステム レポートと共存します。

サービスの設計にあたり、正常性の報告方法およびその対応方法について時間を割いて計画するなら、大規模なクラウド サービスのデバッグ、監視が容易になり、結果としてその運用が容易になります。

## 正常性状態
Service Fabric は 3 つの正常性状態を使用してエンティティが正常な状態であるかどうかどうかを記述します。その 3 つとは、"OK"、"警告"、および "エラー" です。正常性ストアに送信されるすべてのレポートには、必ずこれらの状態のいずれかが指定されています。正常性の評価結果は、これらの状態のいずれかです。

正常性状態の種類は、次のとおりです。

- OK: エンティティは正常です。そのエンティティ、およびその子 (該当する場合) に関して報告されている既知の問題はありません。

- 警告: エンティティでいくつかの問題が発生しているが、異常な状態にまでは至っていません (つまり、機能上の問題を生じない予期しない遅延)。特別な介入をせずに警告状態が解消する場合があり、発生現象を可視化することは有益です。その他の場合、ユーザーが介入しないと、"警告" 状態からより深刻な問題に悪化する可能性があります。

- エラー: エンティティは異常です。エンティティが正しく機能していないため、その状態を修正するようなアクションを取る必要があります。

- 不明: そのエンティティは正常性ストアに存在しません。この結果は、Service Fabric ノードまたはアプリケーションの取得などの、分散クエリの結果として取得する場合があります。これらのクエリは、複数のシステム コンポーネントからの結果をマージします。別のシステム コンポーネントが正常性ストアに到達していないエンティティか、正常性ストアからクリーン アップされているエンティティを含む場合、マージされたクエリは正常性の結果を "不明" な正常性状態に設定します。

## 正常性ポリシー
正常性ストアは、正常性ポリシーを適用し、エンティティが正常かどうかをそのエンティティのレポートとその子に基づいて判断します。

> [AZURE.NOTE]正常性ポリシーは、クラスター マニフェスト (クラスターおよびノードの正常性評価用) またはアプリケーション マニフェスト (アプリケーション評価およびその任意の子用) で指定できます。正常性評価要求では、その評価にのみ使用される、カスタムの正常性評価ポリシーを渡すこともできます。

既定では、Service Fabric は、親子階層関係に厳密なルール (すべて正常でなければならない) を適用します。子の 1 つに 1 つの異常なイベントがある限り、親は異常と見なされます。

### クラスターの正常性ポリシー
クラスターの正常性ポリシーは、クラスターの正常性状態とノードの正常性状態を評価するために使用されます。これは、クラスター マニフェストで定義できます。存在しない場合は、既定のポリシー (許容エラー数: 0) が既定値に設定されます。以下のパラメーターが含まれます。

- **ConsiderWarningAsError**。"警告" の正常性レポートを正常性の評価中にエラーとして処理するかどうかを指定します。既定値は False です。

- **MaxPercentUnhealthyApplications**。異常な可能性のあるアプリケーションの最大許容パーセンテージ。この値を超えるとクラスターは "エラー" の状態と見なされます。

- **MaxPercentUnhealthyNodes**。異常な可能性のあるノードの最大許容パーセンテージ。この値を超えるとクラスターは "エラー" の状態と見なされます。大規模なクラスターでは、ダウンしているか修復を必要とするノードは必ず存在するため、それが許容されるようにこのパーセンテージを構成する必要があります。

クラスター マニフェストからの抜粋を次に示します。

```xml
<FabricSettings>
  <Section Name="HealthManager/ClusterHealthPolicy">
    <Parameter Name="ConsiderWarningAsError" Value="False" />
    <Parameter Name="MaxPercentUnhealthyApplications" Value="0" />
    <Parameter Name="MaxPercentUnhealthyNodes" Value="20" />
  </Section>
</FabricSettings>
```

### アプリケーションの正常性ポリシー
アプリケーションの正常性ポリシーは、アプリケーションとその子に関して、イベントの評価方法および子の状態の集計方法を記述します。これは、アプリケーション パッケージにある、アプリケーション マニフェストの ApplicationManifest.xml ファイルで定義できます。指定しない場合、正常性状態が "警告" もしくは "エラー" の正常性レポートか子が見つかれば、Service Fabric はエンティティを異常と判断します。構成可能なポリシーは、次のとおりです。

- **ConsiderWarningAsError**。"警告" の正常性レポートを正常性の評価中にエラーとして処理するかどうかを指定します。既定値は False です。

- **MaxPercentUnhealthyDeployedApplications**。異常な可能性のあるデプロイされたアプリケーションの最大許容パーセンテージ。この値を超えるとアプリケーションは "エラー" の状態と見なされます。この数値は、デプロイされた異常なアプリケーションの数を、クラスター内でそのアプリケーションが現在デプロイしているノードの数で除算した結果です。切り上げ計算が実行され、少数のノードに対する 1 つのエラーは許容されます。既定値は 0% です。

- **DefaultServiceTypeHealthPolicy**。アプリケーション内のすべてのサービスの種類の既定の正常性ポリシーに代わる、既定のサービスの種類の正常性ポリシーを指定します。

- **ServiceTypeHealthPolicyMap**。指定されたサービスの種類に関して、既定のサービスの種類の正常性ポリシーに代わる、サービスの種類ごとのサービス正常性ポリシーをマップします。たとえば、ステートレスなゲートウェイ サービスの種類とステートフルなエンジン サービスの種類を含むアプリケーションでは、ステートレス サービスとステートフル サービスの正常性ポリシーを別個に構成できます。サービスの種類ごとにポリシーを指定することで、サービスに対して、より粒度の細かい正常性制御が可能になります。

### サービスの種類の正常性ポリシー
サービスの種類の正常性ポリシーは、サービスの子を評価する方法および集計する方法を指定します。以下のパラメーターが含まれます。

- **MaxPercentUnhealthyPartitionsPerService**。異常なパーティションの最大許容パーセンテージ。この値を超えるとサービスは異常と見なされます。既定値は 0% です。

- **MaxPercentUnhealthyReplicasPerPartition**。異常なレプリカの最大許容パーセンテージ。この値を超えるとパーティションは異常と見なされます。既定値は 0% です。

- **MaxPercentUnhealthyServices**。異常なサービスの最大許容パーセンテージ。この値を超えるとアプリケーションは異常と見なされます。既定値は 0% です

アプリケーション マニフェストからの抜粋を次に示します。

```xml
    <Policies>
        <HealthPolicy ConsiderWarningAsError="true" MaxPercentUnhealthyDeployedApplications="20">
            <DefaultServiceTypeHealthPolicy
                   MaxPercentUnhealthyServices="0"
                   MaxPercentUnhealthyPartitionsPerService="10"
                   MaxPercentUnhealthyReplicasPerPartition="0"/>
            <ServiceTypeHealthPolicy ServiceTypeName="FrontEndServiceType"
                   MaxPercentUnhealthyServices="0"
                   MaxPercentUnhealthyPartitionsPerService="20"
                   MaxPercentUnhealthyReplicasPerPartition="0"/>
            <ServiceTypeHealthPolicy ServiceTypeName="BackEndServiceType"
                   MaxPercentUnhealthyServices="20"
                   MaxPercentUnhealthyPartitionsPerService="0"
                   MaxPercentUnhealthyReplicasPerPartition="0">
            </ServiceTypeHealthPolicy>
        </HealthPolicy>
    </Policies>
```

## 正常性評価
ユーザーもしくは自動化されたサービスにより、任意の時点で任意のエンティティの正常性を評価できます。エンティティの正常性を評価するため、正常性ストアは、エンティティに関するすべての正常性レポートを集計し、そのすべての子 (該当する場合) を評価します。正常性の集計アルゴリズムでは、正常性レポートの評価方法と、子の正常性状態の集計方法 (該当する場合) を指定する正常性ポリシーを使用します。

### 正常性レポートの集計
1 つのエンティティに、さまざまなプロパティのさまざまなレポーター (システム コンポーネントやウォッチドッグ) から送信される複数の正常性レポートが含まれる場合があります。集計には、関連付けられている正常性ポリシー、特にアプリケーションまたはクラスターの正常性ポリシーの ConsiderWarningAsError メンバーを使用します。これは、警告の評価方法を指定します。

集計された正常性状態は、 エンティティの**最悪**の正常性レポートによってトリガーされます。1 つでも "エラー" の正常性レポートがある場合は、集計された正常性状態は "エラー" になります。

!["エラー" のレポートがある正常性レポートの集計。][2]

"エラー" の正常性レポートは、正常性のエンティティを "エラー" 状態にするトリガーとなります。

[2]: ./media/service-fabric-health-introduction/servicefabric-health-report-eval-error.png

"エラー" のレポートがなく、1 つまたは複数の "警告" がある場合、集計された正常性状態は "警告" または "エラー" のいずれかであり、これは ConsiderWarningAsError ポリシーのフラグによって決まります。

!["警告" のレポートがあり、ConsiderWarningAsError が False に設定されている場合の正常性レポートの集計。][3]

"警告" のレポートがあり、ConsiderWarningAsError が False に設定されている場合 (既定値) の正常性レポートの集計。

[3]: ./media/service-fabric-health-introduction/servicefabric-health-report-eval-warning.png

### 子の正常性の集計
エンティティの集計された正常性状態は、子の正常性状態を反映します (該当する場合)。子の正常性状態を集計するためのアルゴリズムには、エンティティの種類に基づいて適用可能な正常性ポリシーが使用されます。

![子エンティティの正常性集計。][4]

正常性ポリシーに基づく子の集計。

[4]: ./media/service-fabric-health-introduction/servicefabric-health-hierarchy-eval.png

すべての子を評価した後、正常性ストアはその正常性状態を集計します。これは、エンティティと子の種類を基に決定するポリシーから取得する、異常の構成最大パーセントに基づいています。

- すべての子が "OK" の状態である場合は、子の集計正常性状態は "OK" です。

- "OK" の状態と "警告" の状態の子がある場合は、子の集計正常性状態は "警告" です。

- "エラー" の状態の子が、異常な子の最大許容パーセンテージを超える場合、集計正常性状態は "エラー" です。

- "エラー" の状態の子が、異常な子の最大許容パーセンテージ内である場合は、集計正常性状態は "警告" です。

## 正常性の報告
システム コンポーネント、および内部/外部のウォッチドッグが、Service Fabric エンティティに対して報告をする場合があります。*レポーター*は、監視対象のエンティティの正常性を、いくつかの監視条件に基づいて**ローカル**に判定します。これらは、グローバル状態や集計データを参照する必要がありません。これは望ましいことではありません。レポーターが複雑な構造体になり、送信すべき情報を推定するために、さまざまな対象を確認することが必要になるからです。

正常性データを正常性ストアに送信するには、レポーターは影響を受けるエンティティを特定し、正常性レポートを作成する必要があります。その後、レポートは Powershell または REST を介して、FabricClient.HealthManager.ReportHealth を使用する API で送信することができます。

### 正常性レポート
クラスターの各エンティティに関する正常性レポートには、次の情報が含まれています。

- SourceId。正常性イベントのレポーターを一意に識別する文字列。

- エンティティ識別子。レポートを適用するエンティティを識別します。この値は[エンティティ型](service-fabric-health-introduction.md#health-entities-and-hierarchy)に応じて異なります:

  - クラスター: なし

  - ノード: ノード名 (文字列)。

  - アプリケーション: アプリケーション名 (URI)。クラスターにデプロイされているアプリケーション インスタンスの名前を表します。

  - サービス: サービス名 (URI)。クラスターにデプロイされているサービス インスタンスの名前を表します。

  - パーティション: パーティション ID (GUID)。パーティションの一意の識別子を表します。

  - レプリカ: ステートフル サービス レプリカ ID、またはステートレス サービス インスタンス ID (Int64)。

  - DeployedApplication: アプリケーション名 (URI)、およびノード名 (文字列)。

  - DeployedServicePackage: アプリケーション名 (URI)、ノード名 (文字列)、およびサービス マニフェスト名 (文字列)。

- プロパティ。これは*文字列* (固定値列挙型ではない) で、レポーターはこれによってエンティティの特定のプロパティの正常性イベントを分類できます。たとえば、レポーター A は Node01 の "ストレージ" プロパティに関する正常性を報告し、レポーター B は Node01 の "接続" プロパティに関する正常性を報告できます。これらのレポートは Node01 エンティティの正常性ストアで別個の正常性イベントとして扱われます。

- 説明。これは文字列で、レポーターはこれによって正常性イベントに関する詳細情報を提供できます。SourceId、プロパティ、および HealthState は、レポートを完全に記述する必要があります。"説明" には、管理者とユーザーが理解できるよう、レポートに関する可読形式の情報が追加されます。

- HealthState。[列挙型](service-fabric-health-introduction.md#health-states)で、レポートの正常性状態を説明します。有効な値は、"OK"、"警告"、および "エラー" です。

- TimeToLive。TimeSpan 型で、正常性レポートの有効期間を示します。RemoveWhenExpired とセットで、期限切れイベントの評価方法を正常性ストアに通知します。既定値は "infinite" で、レポートは永久に有効です。

- RemoveWhenExpired。ブール値。True に設定されている場合、有効期限切れの正常性レポートは自動的に正常性ストアから削除され、エンティティの正常性評価に影響しません。これは、レポートが一定時間のみ有効で、レポーターがレポートを明示的に消去する必要がない場合に使用されます。また、正常性ストアからレポートを削除する場合にも使用されます。例: ウォッチドッグが変更され、以前のソースとプロパティを使用したレポート送信を停止した場合。小さな TTL と RemoveWhenExpired を使用してレポートを送信し、正常性ストアから以前の任意の状態をクリアできます。False に設定した場合は、有効期限が切れたレポートは正常性評価でエラーとして扱われます。このプロパティに関するソースからの定期的な報告が必要であることを示す信号を正常性ストアに送ります。信号が送られない場合は、ウォッチドッグに何らかの問題があります。ウォッチドッグの正常性は、このイベントをエラーと見なすことによりキャプチャされます。

- SequenceNumber。正の整数値です。レポートの順序を表すものであるため、順次増加する必要があります。正常性ストアにより、古いレポート、つまりネットワークの遅延やその他の問題のために受信が遅れたものを検出するのに使用されます。レポートのシーケンス番号が、同じエンティティ、ソース、およびプロパティに適用されている最新のシーケンス番号以下である場合、レポートは拒否されます。シーケンス番号は、指定しない場合は自動生成されます。状態遷移を報告する場合に唯一必要なのは、シーケンス番号を挿入することです。ソースに必要なのは、送信したレポートを記憶し、フェールオーバーの際の復旧用にその情報を保存することです。

SourceId、エンティティ識別子、プロパティおよび正常性状態は、すべての正常性レポートに必要です。SourceId 文字列は、先頭に "System." というプレフィックスを使用することはできません。これはシステム レポート専用です。同じエンティティの場合、同じソースとプロパティに対するレポートは 1 つだけ存在します。複数のレポートが同じソースとプロパティに対して生成された場合、正常性クライアント側 (バッチ処理されている場合) か正常性ストア側で互いに上書きされ合います。置換はシーケンス番号に基づいて行われます。新しいレポート (シーケンス番号が大きい方) が古いレポートを置換します。

### 正常性イベント
内部的には、正常性ストアは正常性イベントを保持しており、これにはレポートからのすべての情報に加え、レポートが正常性クライアントに送信された日時やレポートがサーバー側で変更された日時など、追加のメタデータも含まれます。正常性イベントは、[正常性クエリ](service-fabric-view-entities-aggregated-health.md#health-queries)によって返されます。

追加のメタデータは、次のとおりです。

- SourceUtcTimestamp: レポートが正常性クライアントに送信された時刻 (UTC)

- LastModifiedUtcTimestamp: レポートがサーバー側で最終変更された時刻 (UTC)

- IsExpired: 正常性ストアでクエリが実行された時点でレポートが期限切れになるかどうかを示すフラグ。イベントが期限切れになるのは、RemoveWhenExpired が false の場合のみです。それ以外は、イベントはクエリによって返されずに、ストアから削除されます。

- LastOkTransitionAt、LastWarningTransitionAt、LastErrorTransitionAt: "OK"/"警告"/"エラー" の最終遷移時刻。これらのフィールドは、イベントの正常性状態の遷移に関する履歴を提供します。

この状態遷移フィールドは、よりスマートな警告表示や正常性イベント情報の "履歴" に使用できます。次のようなシナリオが可能です。

- プロパティが X 分間以上 "警告" または "エラー" 状態の場合は、通知する。こうすることで、一時的な状況に基づく通知を回避できます。例: 「"警告" の正常性状態で 5 分経過すると通知する」は以下のように記述できます (HealthState == Warning and Now - LastWarningTransitionTime
> 

- 最後の X 分間に変更した条件にのみ基づいて通知します。それ以前から "エラー" の状態にあったレポートは無視されます (信号が既に送られてしまっているため)。

- プロパティが "警告" と "エラー" の状態を行き来している場合、異常とする時間 (つまり "OK" ではない時間) を決定します。例: 「正常以外のプロパティで 5 分経過すると通知する」は以下のように記述できます: (HealthState != Ok and Now - LastOkTransitionTime > 5 minutes)。

## 例: アプリケーションの正常性を報告し評価する
次の例では、Powershell を使用して、fabric:/WordCount という名前のアプリケーションの正常性レポートを MyWatchdog というソースから送信します。正常性レポートには、"エラー" の正常性状態の正常性プロパティ Availability に関する情報が、無限に設定された TTL と共に含まれています。次いで、アプリケーションの正常性がクエリされ、集計された正常性状態のエラーおよび報告された正常性イベントが、正常性イベントの一覧の一部として返されます。

```powershell
PS C:\> Send-ServiceFabricApplicationHealthReport –ApplicationName fabric:/WordCount –SourceId "MyWatchdog" –HealthProperty "Availability" –HealthState Error

PS C:\> Get-ServiceFabricApplicationHealth fabric:/WordCount

ApplicationName                 : fabric:/WordCount
AggregatedHealthState           : Error
UnhealthyEvaluations            :
                                  Error event: SourceId='MyWatchdog', Property='Availability'.

ServiceHealthStates             :
                                  ServiceName           : fabric:/WordCount/WordCount.Service
                                  AggregatedHealthState : Warning

                                  ServiceName           : fabric:/WordCount/WordCount.WebService
                                  AggregatedHealthState : Ok

DeployedApplicationHealthStates :
                                  ApplicationName       : fabric:/WordCount
                                  NodeName              : Node.4
                                  AggregatedHealthState : Ok

                                  ApplicationName       : fabric:/WordCount
                                  NodeName              : Node.1
                                  AggregatedHealthState : Ok

                                  ApplicationName       : fabric:/WordCount
                                  NodeName              : Node.5
                                  AggregatedHealthState : Ok

                                  ApplicationName       : fabric:/WordCount
                                  NodeName              : Node.2
                                  AggregatedHealthState : Ok

                                  ApplicationName       : fabric:/WordCount
                                  NodeName              : Node.3
                                  AggregatedHealthState : Ok

HealthEvents                    :
                                  SourceId              : System.CM
                                  Property              : State
                                  HealthState           : Ok
                                  SequenceNumber        : 5102
                                  SentAt                : 4/15/2015 5:29:15 PM
                                  ReceivedAt            : 4/15/2015 5:29:15 PM
                                  TTL                   : Infinite
                                  Description           : Application has been created.
                                  RemoveWhenExpired     : False
                                  IsExpired             : False
                                  Transitions           : ->Ok = 4/15/2015 5:29:15 PM

                                  SourceId              : MyWatchdog
                                  Property              : Availability
                                  HealthState           : Error
                                  SequenceNumber        : 130736794527105907
                                  SentAt                : 4/16/2015 5:37:32 PM
                                  ReceivedAt            : 4/16/2015 5:37:32 PM
                                  TTL                   : Infinite
                                  Description           :
                                  RemoveWhenExpired     : False
                                  IsExpired             : False
                                  Transitions           : ->Error = 4/16/2015 5:37:32 PM

```

## 正常性モデルの使用法
正常性モデルを使用することにより、監視と正常性判断がクラスター内のさまざまなモニター間に分散されるため、クラウド サービス、および基になる Service Fabric プラットフォームの拡張が可能になります。他のシステムでは、クラスター レベルで集中管理されている単一のサービスで、サービスによって生成される*潜在的に*有用な情報すべてを解析しています。これはスケーラビリティの妨げになっており、問題や潜在的な問題の根本原因を正確に識別するのに役立つ特定の情報を収集するのは困難です。

正常性モデルは、監視と診断、クラスターとアプリケーションの正常性の評価、および監視付きアップグレードに多用されます。他のサービスは、正常性データを使用して自動修復を実行し、クラスターの正常性履歴を構築し、特定の条件でアラートを通知します。

## 次のステップ
[Service Fabric の正常性レポートの確認方法](service-fabric-view-entities-aggregated-health.md)

[トラブルシューティングのためのシステム正常性レポートの使用](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)

[Service Fabric のカスタム正常性レポートの追加](service-fabric-report-health.md)

[ローカルでのサービスの監視方法と診断方法](service-fabric-diagnostics-how-to-monitor-and-diagnose-services-locally.md)

[Service Fabric アプリケーションのアップグレード](service-fabric-application-upgrade.md)
 

<!---HONumber=July15_HO4-->