
<properties
   pageTitle="Azure Service Fabric アクターのステートフル サービス構成のデザイン パターン"
   description="サービス呼び出しの間の状態を維持したり、前のサービスの結果をキャッシュしたりするための、ステートフル アクターを使用する Service Fabric アクターのデザイン パターン。状態は永続化することも一時的にすることもできます。"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="04/01/2015"
   ms.author="claudioc"/>

# Service Fabric アクターのデザイン パターン: ステートフル サービスの構成
開発者は 10 年半を費やし、企業に N 階層のステートレス サービスを構築してきました。開発者はデータベースの上にサービスを構築し、他のサービスの上に上位サービスを構築し、それらのサービスを調整するためのオーケストレーション エンジンとメッセージ指向のミドルウェアを構築しました。ユーザーのワークロードが増えるにつれて、要求の厳しい対話機能や拡張性、ステートレス サービス指向のアーキテクチャの欠点が見え始めました。

## 従来の方法: SOA サービス
SOA サービスはステートレスな性質により水平方向にシームレスに拡張しましたが、ストレージ層に同時実行性とスループットというボトルネックが発生しました。ストレージへのアクセスに対するハードルがますます高くなりました。多くの開発者は、一般的な方法として、ストレージに対する要求を減らすためのソリューションにキャッシュを導入しましたが、そのソリューションにも管理が必要な別の階層の発生や、キャッシュへの同時アクセス、セマンティックの制限や変更、そして整合性などの欠点がありました。スマート キャッシュのパターンで詳しく説明したように、仮想のアクターのモデルがこれに対する完全なソリューションを提供します。

ストレージ層をレプリケートすることで問題を解決しようとした開発者もいました。しかし、このアプローチは拡張性が乏しく、すぐに上限に達してしまいました。変化する要件に伴い、2 つ目の課題が発生しました。エンドユーザーと企業の両方が必要としているのは、要求に対して常に秒ではなくミリ秒で応答するような対話型サービスなのです。これに対応するため、開発者が他のサービスの上にファサード サービスを構築し始めました。場合によってはユーザー中心のサービスを作成するため数十のサービスを構築しました。しかし、複数のダウン ストリーム サービスの構成により、すぐに待機時間の問題が発生しました。

ここでも開発者はキャッシュとメモリ内のオブジェクト ストアに注目し、状況に応じてパフォーマンスの要件に対応するためのさまざまな実装も行いました。高価なオンデマンドでのキャッシュ取り込みを最小限に抑えるため、定期的にキャッシュを作成するバックエンドのワーカー プロセスの構築を開始しました。最後には、非同期操作を同期操作から分離し、特に SOA で課題となる、状態の変化に対応するための対話的操作の領域を空けるため、ワークロードの分解を開始しました。

ソリューションをさらに複雑にするキューやワーカーなどの追加の階層を導入しました。開発者は、基本的には、"ステートフル サービス" を構築する、つまり、"状態" と "サービスの動作" を結び付けて、ユーザー中心の対話的エクスペリエンスに対処するソリューションを探し始めました。そこで目を付けたのが、サービスの置換ではなく、サービス構成階層を挿入する Azure Service Fabric アクターです。

次の図に、要点を示します。

![][1]

## アクターによる優れたソリューション
サービスを構成する場合、アクターはステートレスにもステートフルにもできます。

* ステートレス アクターは、基になるサービスのプロキシとして使用できます。このアクターは、Azure Service Fabric のクラスター間で動的に拡張でき、サービスの検出後は、そのエンドポイントなどのサービスに関連する特定の情報をキャッシュすることができます。
* ステートフル アクターは、サービス呼び出しの間の状態を維持したり、前のサービスの結果をキャッシュしたりできます。状態は永続化することも一時的にすることもできます。

このパターンは、多くのシナリオにも適用されます。ほとんどの場合、アクターは特定のサービスで操作を呼び出すための外部呼び出しを行う必要があります。最新の e コマース アプリケーションを使用した例で説明しましょう。これらのアプリケーションは、ユーザー プロファイル管理、推奨事項、買い物かごの管理、ウィッシュ リストの管理、購買などのさまざまな機能を提供するサービスで構築されます。

多くの開発者は、アーキテクチャに対してユーザー中心のアプローチを取りたいと考えています。e コマースのエクスペリエンスは主にユーザーと製品を中心に展開するため、これは彼らが開発しているソーシャルのエクスペリエンスに非常に似ています。これは通常、サービスのファサードを配布することで実現します。ほとんどの場合、パフォーマンス上の理由により、キャッシュによりサポートされます。

では、アクター ベースのアプローチについて説明します。ユーザーのアクターはユーザーの動作 (カタログの参照、製品の好み、買い物かごへのアイテムの追加、友人への製品のお勧め) だけでなく、構成済みの状態 (プロファイル、買い物かごのアイテム、友人から勧められたアイテムの一覧、購入履歴、現在の地理的な位置など) も表すことができます。

## ステートフル アクターの使用
最初に、ユーザーのアクターが複数のサービスから状態を取り込む必要がある例を見てみましょう。スマート キャッシュのパターンで説明した内容がすべてここでも適用されるため、これについてのコード サンプルは提供しません。ユーザーのアクターをログイン時にアクティブ化して、バックエンド サービスから十分なデータを取り込むことができます。もちろん、これまでの多くの状況で見てきたように、状態の全体でも一部でも、オンデマンドまたはタイマーに従って、あるいはその両方で事前に取り込んだり、アクターにキャッシュしたりできます。この例では、プロファイルとウィッシュ リストを次に示します。

![][2]

たとえば、頻繁に使用するユーザーの状態を事前に取り込んでログイン時に使用できるほか、毎月サービスを訪問するユーザーの状態をログイン時に取り込むこともできます。このパターンはスマート キャッシュのセクションで見ました。

ユーザー 23 がログイン時にまだアクティブ化されていない場合は、ユーザーのアクター (23) がアクティブ化され、関連するユーザー プロファイル情報とウィッシュ リストがバックエンド サービスからフェッチされます。ユーザーのアクターが後続の呼び出しのために情報をキャッシュする場合もあります。簡単に実装できるライト スルーまたはライト ビハインド。さらに、アイテムをウィッシュ リストに追加する必要がある場合などは、前述のようにライト ビハインドしたりライトスルーしたりできます。次に、ユーザーがその製品を気に入って "いいね!" ボタンをクリックした場合の例を見てみましょう。このアクションは、以下に示すように、"いいね!" をカタログ サービスに送信したり、他のお勧めをトリガーしたり、場合によってはソーシャル ネットワークに更新を投稿したりする複数のサービスへの複数の呼び出しを必要とする場合があります。

その例を次に示します。

![][3]

## アクターの構成と非同期通信の機能
実は、Azure Service Fabric アクターは要求/応答形式の操作と非同期操作を一緒に構成する必要がある場合に役立ちます。たとえば、製品への “いいね!” により、すぐに関連するアイテムがユーザーのウィッシュ リストに入る一方で、ソーシャル ネットワークへの投稿や他のお勧めのトリガーはバッファーとタイマーを使用して非同期操作になるようにできます。

ユーザーのアクターとサービスを使用するもう 1 つの重要な利点は、アクターがキャッシュされた状態に対する適切な場所を提供すること、とりわけ重要なのは状態の変化に非同期的に反応することです。これは、ステートレス サービスでは特に難しいシナリオです。たとえば、ユーザーが "カスタマー ジャーニー" の一環として一連のアクションを実行したとします。 このイベントをアクターがリアルタイムでキャプチャして、ストリームにまとめることができます。ストリームはイベント時に、またはタイマーで非同期的に照会して、アクターの動作を変更することができます。

エンドポイントが言語非依存のプロトコルで公開されているため、SOA の純正主義者なら、この時点でこれらがアクターのサービスでないことに間違いなく気づくでしょう。Azure Service Fabric アクターは相互運用性コンポーネントでもサービスの相互運用性のためのプラットフォームでもありません。それでもやはり、アクターをモデル化したり、同じ方法で関心の分離をモデル化したりするときに、どうしても SOA 型サービスの粒度の観点から考えてしまいます。そのようなサービスは “マイクロサービス” と呼ばれます。 同様に、REST エンドポイントまたは SOAP エンドポイントを Azure Service Fabric アクターの前の相互運用階層として配置することもできます。

ステートフル サービスの構成は、e コマースなどのトランザクションのシナリオだけでなく、ワークフローにも適用されます。Azure Service Fabric は、ワークフロー/オーケストレーション エンジンとして設計されているため、サービスの対話機能を伴うワークフローのモデル化や、これらの対話状態の維持に使用することができます。

動的なエクスペリエンスを提供するための拡張可能なサービスの構築では “ステートレス サービス” の欠点がわかります。Azure Service Fabric アクターは、基本的に状態と動作をまとめ、開発者が既存の投資の上に拡張可能で対話型のエクスペリエンスを構築できるように支援します。


## 次のステップ
[パターン: スマート キャッシュ](service-fabric-reliable-actors-pattern-smart-cache.md)

[パターン: 分散ネットワークとグラフ](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[パターン: リソースのガバナンス](service-fabric-reliable-actors-pattern-resource-governance.md)

[パターン: モノのインターネット](service-fabric-reliable-actors-pattern-internet-of-things.md)

[パターン: 分散計算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[いくつかのアンチ パターン](service-fabric-reliable-actors-anti-patterns.md)

[Service Fabric アクターの概要](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png
 

<!---HONumber=July15_HO4-->