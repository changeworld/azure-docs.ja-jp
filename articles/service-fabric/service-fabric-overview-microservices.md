---
title: "Azure でのマイクロサービスの概要 | Microsoft Docs"
description: "マイクロサービスでクラウド アプリケーションを構築することが現代のアプリケーション開発にとって重要である理由と Azure Service Fabric がそれを達成するためのプラットフォームを提供するしくみの概要"
services: service-fabric
documentationcenter: .net
author: msfussell
manager: timlt
editor: 
ms.assetid: fae2be85-0ab4-4cd3-9d1f-e0d95fe1959b
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 02/06/2017
ms.author: msfussell
translationtype: Human Translation
ms.sourcegitcommit: 7033955fa9c18b2fa1a28d488ad5268d598de287
ms.openlocfilehash: a2a72da08ccff17407fcdd98783137b091651b47


---
# <a name="why-a-microservices-approach-to-building-applications"></a>マイクロサービスの手法でアプリケーションを構築する理由は何ですか。
ソフトウェア開発者にとって、アプリケーションを構成要素化することは新しい手法ではありません。 これは、オブジェクト指向、ソフトウェア抽象化、コンポーネント化の中心的なパラダイムです。 今日、この手法では、共有ライブラリとテクノロジ層間のクラスやインターフェイスという形態が取られる傾向にあります。 通常、バックエンド ストア、ミドル層ビジネス ロジック、フロントエンド ユーザー インターフェイス (UI) による階層型のアプローチで行われています。 ここ数年で変化*した*ことは、開発者がビジネス主導のクラウドのために分散アプリケーションを構築しているということです。

変化するビジネス ニーズには次のようなものがあります。

* たとえば、新しい地理的地域の顧客にアプローチできるように、大規模なサービスを構築して運用する。
* 顧客の要望にアジャイルに応答する機能を短期間で届ける。
* リソース利用率を改善し、コストを下げる。

これらのビジネス ニーズが、アプリケーションの構築 *方法* に影響します。

マイクロサービスに対する Azure のアプローチの詳細については、「 [Microservices: An application revolution powered by the cloud (マイクロサービス: クラウドによって実現されるアプリケーションの革命)](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)」を参照してください。

## <a name="monolithic-vs-microservice-design-approach"></a>モノリシックとマイクロサービスのデザイン アプローチの比較
すべてのアプリケーションは時間の経過に伴って進化します。 成功したアプリケーションは便利であることで進化します。 失敗したアプリケーションは進化せず、最終的には廃止となります。 問題は、現在の要件についての知識と、その要件が将来どうなるかということです。 たとえば、ある部署のためにレポート アプリケーションを構築するとします。 そのアプリケーションが社内で使用され、レポートの存続期間は短いことがわかっています。 選択する手法は、たとえば、数千万の顧客にビデオ コンテンツを配信するサービスを構築する場合とは異なります。 

アプリケーションは後で再設計可能であると承知した上で、何かを概念実証として完成させることが推進要因となることがあります。 利用されることがない過剰なエンジニアリングには意味がありません。 これは、普通、エンジニアリング上の得失評価となります。 一方、企業がクラウドの構築について話す際に、成長と利用が期待されます。 問題はその成長と規模が予想できないことです。 早期に試作品を作成し、同時に、将来の成功に対処するための道を歩んでいることを確認することが望まれます。 これが、構築、測定、学習、繰り返しからなるリーン スタートアップ手法です。

クライアント/サーバーの時代には、各層で特定の技術を利用する階層型アプリケーションを構築する傾向にありました。 このような手法で、*モノリシック* アプリケーションという言葉が登場しました。 インターフェイスが階層間に置かれ、各層内のコンポーネント間ではより密接に結合した設計が使用されるようになりました。 開発者はライブラリにコンパイルするクラスを設計して要素化し、リンクしていくつかの実行可能ファイルや dll を作成していました。 

このようなモノリシック設計の手法には長所があります。 多くの場合、設計がより単純になり、プロセス間通信 (IPC) 経由となるためコンポーネント間の呼び出しが速くなります。 また、各自が&1; つの製品をテストするため、人的リソース効率が良くなります。 欠点は、階層化されたレイヤーが密接に結合されることになり、個々のコンポーネントを拡張できないことです。 修正やアップグレードを行う場合、他の開発者がテストを完了するのを待たなければなりません。 そのため、アジャイルにすることがより難しくなります。

マイクロサービスはこのような欠点に対処しており、前述のビジネス要件に合わせて調整されていますが、マイクロサービスにも利点と欠点があります。 マイクロサービスの利点は、通常は各マイクロサービスで単純なビジネス機能をカプセル化し、それぞれを独立して拡大縮小、試験、デプロイ、管理できることです。 マイクロサービス手法の重要な利点の&1; つは、チームが技術主導ではなくビジネス シナリオ主導になり、階層型の手法に適していることです。 実際には、小規模のチームが好みの技術を利用し、顧客シナリオに基づいてマイクロサービスを開発します。 

言い換えれば、組織はモノリシック アプリケーションを維持する目的で技術を標準化する必要がありません。 サービスを所有する個々のチームは、チームの専門知識に基づくチームに適したアクションや、解決する必要のある問題に最適なアクションを実行できます。 実際には、特定の NoSQL ストアや Web アプリケーション フレームワークなど、一連の推奨技術を用意することが望ましくなります。

マイクロサービスの欠点には、多数の個々のエンティティの管理、複雑化したデプロイの処理とバージョン管理などがあります。 マイクロサービス間のネットワーク トラフィックや、対応するネットワークの待ち時間も増加します。 煩雑で細かなサービスが多いことは、パフォーマンス上の悩みの種です。 依存関係を表示するための支援ツールがなければ、システム全体を "見る" ことが困難になります。 

マイクロサービス手法を機能させるには、標準が必要です。標準では、通信方法について同意し、厳密なコントラクトではなく、サービスから必要となるものだけを許容します。 サービスは互いに独立して更新されるため、設計でこうしたつながりをあらかじめ定義することが重要です。 マイクロサービス手法による設計を別の言葉で表現すると "詳細なサービス指向アーキテクチャ (SOA)" となります。

***簡単に言うと、マイクロサービスの設計手法とは、サービスの切り離されたフェデレーションであり、各サービスの変更が独立して行われ、合意に基づく通信標準が使用されます。***

生成されるクラウド アプリの数が増えるにつれ、アプリ全体を独立したシナリオ中心のサービスに分割するこの手法が、長期的には優れた手法であることがわかります。

## <a name="comparison-between-application-development-approaches"></a>アプリケーション開発手法の比較
![Service Fabric プラットフォーム アプリケーションの開発][Image1]

* モノリシック アプリにはドメイン固有の機能が含まれ、通常は、Web、ビジネス、データなどの、機能層で分割されます。
* 複数のサーバー/仮想マシン/コンテナーでクローンを作成することで、モノリシック アプリを拡張します。
* マイクロサービス アプリケーションは機能をより小規模の個別サービスに分割します。
* マイクロサービス手法では、各サービスを個別にデプロイすることで拡張し、サーバー/仮想マシン/コンテナーにわたってこれらのサービスのインスタンスを作成します。

あらゆるプロジェクトをマイクロサービス手法で設計できるわけではありませんが、前述のビジネスの目的により厳密に合わせることができます。 後で必要に応じてマイクロサービス設計用にコードを書き直せないことがわかっている場合は、モノリシック手法を最初から使用してもかまいません。 一般的には、モノリシック アプリを作成し、それを段階的に徐々に分割します。その場合、拡張性またはアジャイル性を高める必要がある機能領域から始めます。

要約すると、マイクロサービス手法とは、多数の小規模サービスからなるアプリケーションを作成することです。 各サービスは、マシンのクラスター全体にデプロイされたコンテナーで実行します。 小規模のチームが&1; つのシナリオに重点を置くサービスを開発し、個別にテスト、デプロイ、拡張するため、アプリケーション全体を進化させることができます。

## <a name="what-is-a-microservice"></a>マイクロサービスとは何か。
マイクロ サービスにはさまざまな定義があります。 インターネットを検索すると、独自の観点と定義を提供する多くの有用な情報が見つかります。 ただし、マイクロサービスの次の特性の多くは一般に受け入れられています。

* 顧客またはビジネス シナリオをカプセル化します。 どのような問題を解決していますか。
* 小規模のエンジニアリング チームが開発します。
* あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できます。
* 個別にバージョン管理、デプロイ、拡張されるコードとステート (任意) で構成されます。
* 適切に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します。
* 場所の解決に使用される一意の名前 (URL) があります。
* エラーが発生しても、一貫性を維持し、利用できます。

これらの特性は次のようにまとめることができます。

***マイクロサービス アプリケーションは、適切に定義されたインターフェイスと標準プロトコルで互いに通信する、個別にバージョン管理され、拡張可能な小規模の顧客中心サービスから構成されます。***

前のセクションでは、最初の&2; 点について説明しました。ここでは、他の点について詳しく説明します。

### <a name="written-in-any-programming-language-and-use-any-framework"></a>あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できる
開発者は、技能とサービスのニーズに合わせ、言語やフレームワークを自由に選択できなければなりません。 サービスによっては、C++ の持つパフォーマンス上の利点が他のすべてのものより重視されることがあります。 C# や Java の持つ管理開発の容易さが最も重要なサービスもあります。 場合によっては、特定のパートナー ライブラリ、データ ストレージ技術、クライアントにサービスを公開する手法が必要になります。

技術を選択した後で、サービスの運用管理またはライフサイクル管理と拡張に関する話題に移ります。

### <a name="allows-code-and-state-to-be-independently-versioned-deployed-and-scaled"></a>コードとステートを個別にバージョン管理、デプロイ、および拡張できるようにする
マイクロサービスの記述にどの言語を選択した場合でも、コードとステート (任意) を個別にデプロイ、アップグレード、拡張する必要があります。 これは、技術の選択に関わるため、実際には解決が難しい問題の&1; つです。 拡張に関しては、コードとステートの両方のパーティショニング (またはシャーディング) 方法を理解するのは困難です。 コードとステートで別々の技術が使用される場合 (今日、一般的になっています)、マイクロサービスのデプロイメント スクリプトは両方を拡張できるものでなければなりません。 また、これはアジャイル性と柔軟性にも影響するため、一部のマイクロサービスをアップグレードする場合、それらをすべて一度にアップグレードする必要はありません。

ここで、モノリシック手法とマイクロサービス手法の比較に戻り、下の図でステートの格納方法の違いを示します。

#### <a name="state-storage-between-application-styles"></a>アプリケーション スタイル間のステート ストレージ
![Service Fabric プラットフォームのステート ストレージ][Image2]

***左は、1 つのデータベースと固有のテクノロジの層からなるモノリシック手法です。***

***右はマイクロサービス手法であり、マイクロサービスが相互に接続されています。一般的にステートの対象はマイクロサービスであり、さまざまなテクノロジが利用されます。***

モノリシック手法では、通常、1 つのデータベースがアプリケーションに利用されます。 長所はこれが単一の場所であり、デプロイが簡単になることです。 各コンポーネントには、そのステートを格納するテーブルを&1; つ与えることができます。 難点は、チームが厳密にステートを分離しなければならないことです。 そのため、必然的に、既存の顧客テーブルに新しい列を追加し、テーブル間で結合を行い、ストレージ層で依存関係を作ってしまう傾向にあります。 このような場合、個々のコンポーネントを拡張することはできません。 

マイクロサービス手法では、各サービスがそのステートを管理し、格納します。 各サービスが、サービスの要求に応じてコードとステートの両方をまとめて拡張する役割を担います。 欠点は、アプリケーション データのビュー (またはクエリ) を作成する必要がある場合、さまざまなステート ストアにわたりクエリを実行しなければならないということです。 通常、この問題は、マイクロサービスの集合全体でビューを構築する個別のマイクロサービスを用意することで解決されます。 データに対して複数の即席のクエリを実行する必要がある場合、各マイクロサービスでは、オフライン分析のためにデータ ウェアハウス サービスにそのデータを書き込むことを検討する必要があります。

バージョン管理はデプロイされたバージョンのマイクロサービスに固有であるため、複数の異なるバージョンを並列でデプロイし実行できます。 バージョン管理により、アップグレード中に新しいバージョンのマイクロサービスにエラーが発生し、前のバージョンにロールバックしなければならない状況に対処できます。 バージョン管理の他のシナリオは、「異なるユーザーが異なるバージョンのサービスを試す場合に、A/B スタイルの試験を実行する」ものです。 たとえば、特定の集合の顧客に対してマイクロサービスをアップグレードし、新しい機能をテストしてからより広い範囲でロールアウトするのが一般的です。 マイクロサービスのライフサイクル管理の次は、マイクロサービス間の通信について説明します。

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a>明確に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します
この 10 年間でサービス指向アーキテクチャに関する文献が数多く公開され、通信パターンについての説明が行われているため、このトピックで取り上げることはほとんどありません。 一般的に、サービス通信には HTTP と TCP プロトコル、およびシリアル化形式として XML または JSON を適用する REST 手法を使用することになります。 インターフェイスの観点では、Web 設計手法を採用することになります。 ただし、バイナリ プロトコルや独自のデータ形式を使用しても問題はありません。 マイクロサービスが公開されたときに、ユーザーがそれを使いこなせない場合に備えておきます。

### <a name="has-a-unique-name-url-used-to-resolve-its-location"></a>場所の解決に使用される一意の名前 (URL) が与えられる
マイクロサービス手法は Web に似ていることは繰り返しお伝えしています。 Web と同様に、マイクロサービスは、実行される場所に関係なく、アドレス指定できるものでなければなりません。 どのマシンがどのマイクロサービスを実行しているのかわからないようであれば、事態はすぐに悪化します。 

DNS で特定の URL を特定のマシンに解決するのと同様に、現在地が検出できるように一意の名前をマイクロサービスに与える必要があります。 マイクロサービスにはアドレス指定可能な名前を与え、実行されているインフラストラクチャから独立させる必要があります。 これは、サービスのデプロイ方法と検出方法の間にやり取りがあることを暗示します。サービス レジストリが必要になるためです。 同様に、マシンでエラーが発生したときに、レジストリ サービスは現在の実行場所を伝える必要があります。 

それでは回復力と一貫性に関する次のトピックに移ります。

### <a name="remains-consistent-and-available-in-the-presence-of-failures"></a>エラーが発生しても、一貫性を維持し、利用できます
予期しないエラーの対処は、特に分散システムにおいて、解決が最も難しい問題の&1; つです。 開発者が記述するコードの大半は例外を処理し、テストでもこれにほとんどの時間が費やされます。 エラーを処理するコードを記述する以上に問題は複雑です。 マイクロサービスが実行されているマシンでエラーが発生した場合、どうなるでしょうか。 このマイクロサービスのエラーを検出する必要があるだけでなく (これ自体も難問ですが)、マイクロサービスを再起動する方法も必要になります。 

マイクロサービスは故障に強くなければならないため、多くの場合、別のマシンで再起動し、可用性を維持する必要があります。 また、マイクロサービスに代わって保存されたステート、マイクロサービスがこのステートを復元できる場所、マイクロサービスを正常に再起動できるかどうかが重要になります。 言い換えると、コンピューティングの回復 (プロセスの再起動) だけでなく、ステートやデータの回復も必要になります (データの損失がなく、データの一貫性が維持されます)。

回復力の問題は、アプリケーション アップグレード中にエラーが発生する場合などに、さらに複雑になります。 マイクロサービスは、デプロイ システムと連動して、回復すればいいだけではありません。 継続的に新しいバージョンに移行するか、前のバージョンにロールバックして一貫性のある状態を維持できるようにするかを決定する必要もあります。 継続的に移行できる十分なマシンがあるかどうかや、前のバージョンのマイクロサービスを復元する方法などの問題を考慮する必要があります。 このような決定を行うために、マイクロサービスは正常性情報を送信する必要があります。

### <a name="reports-health-and-diagnostics"></a>正常性と診断の報告
明白なようでいて見落とされることがよくありますが、マイクロサービスが正常性と診断について報告する必要があります。 報告しなければ、運用の観点からほとんど洞察は得られません。 一連の個別サービスで発生する診断イベントの関連付けを行い、マシンのクロック スキューを処理してイベントの発生順序を把握することは困難です。 同様に、同意したプロトコルとデータ形式でマイクロサービスと対話する場合、正常性と診断イベントのログ方法の標準化が必要になり、結局は、クエリと表示を行うためのイベント ストアが必要になります。 マイクロサービス手法では、各チームが&1; つのログ形式に同意することが重要です。 アプリケーション全体の診断イベントを表示する場合に、一貫性のある手法が必要になるためです。

正常性は診断とは異なります。 適切な措置を講じる上でマイクロサービスがその現状を報告するのが正常性です。 典型的な例としては、アップグレードとデプロイメントによる可用性の維持があります。 プロセスのクラッシュやマシンの再起動に起因し、現在、サービスの状態が正常でないとしても、サービスの動作は引き続き可能な場合があります。 この場合、アップグレードを実行して事態を悪化させてはなりません。 最初に調査するか、マイクロサービスに回復時間を与えることが最良の方法です。 マイクロサービスの正常性イベントにより、得られた十分な情報に基づいて判断することが可能になり、事実上、自己回復サービスを作成できます。

## <a name="service-fabric-as-a-microservices-platform"></a>マイクロサービス プラットフォームとしての Service Fabric
Azure Service Fabric は、Microsoft が箱入り製品 (通常、モノリシック スタイル) の提供からサービスの提供に移行する過程で生まれたものです。 Service Fabric は、Azure SQL Database や Azure DocumentDB などの大規模なサービスを構築し、運用した経験から形成されました。 プラットフォームは、これを採用するサービスが増えるにつれ、時間の経過と共に発展してきました。 重要なことは、Service Fabric は Azure だけではなく、スタンドアロン Windows Server デプロイメントでも実行できる必要があったということです。

***Service Fabric の目的は、サービスの構築と実行に伴う課題を解決し、チームがマイクロサービス手法でビジネス上の問題を解決できるようにインフラストラクチャ リソースを効率的に活用することです。***

Service Fabric では、2 つの広範領域でマイクロサービス手法を使用するアプリケーションの構築を支援します。

* デプロイ、アップグレード、障害が発生したサービスの検出と再起動、サービスが現在実行されている場所の検出、ステート管理、正常性の監視などを行うシステム サービスからなるプラットフォーム。 このようなシステム サービスにより、事実上、前述のマイクロサービスの特性の多くが実現されます。
* マイクロサービスとしてのアプリケーションの構築を支援するプログラミング API またはフレームワーク: [Reliable Actors および Reliable Services](service-fabric-choose-framework.md)。 もちろん、どのコードを選択してもマイクロサービスを構築できます。 しかし、これらの API を利用すれば、作業が単純になり、より深いレベルでプラットフォームと統合されます。 この方法では、たとえば、正常性や診断に関する情報が得ることができ、また、組み込みの高可用性を利用することができます。

***Service Fabric は、サービスの構築方法を考慮しないので、任意のテクノロジを使用することができます。ただし、マイクロサービスの構築を用意にする組み込みのプログラミング API が用意されています。***

### <a name="are-microservices-right-for-my-application"></a>私のアプリケーションにマイクロサービスは適しているでしょうか。
その可能性はあります。 経験から申し上げると、Microsoft では、ビジネス上の理由からクラウドの構築を開始するチームが増えるにつれ、チームの多くがマイクロサービスと同様の手法を利用する利点を実感しています。 たとえば、Bing では、長年にわたってマイクロサービスを開発しています。 他のチームにとって、マイクロサービス手法は新しいものでした。 チームの主要な得意分野が及ばないところに、解決しなければならない難問があることがわかりました。 そこで Service Fabric がサービス構築技術として注目されました。

Service Fabric の目的は、マイクロサービス手法によるアプリケーション構築の複雑性を減らすことです。複雑性が減れば、多くのコストがかかる再設計を繰り返す必要がなくなります。 小規模なものから始める、必要に応じて拡張する、サービスを廃止する、新しいサービスを追加する、顧客の利用状況に合わせて進化することがマイクロサービス手法です。 大部分の開発者にマイクロサービスをよりわかりやすくするために解決する必要がある問題がまだ多く残っていることもわかっています。 コンテナーとアクター プログラミング モデルはその方向に進む小さな一歩としての例です。さらに多くの革新的技術が開発され、簡易化が進むことをマイクロソフトは確信しています。
 
<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->

## <a name="next-steps"></a>次のステップ
* [Service Fabric の用語の概要](service-fabric-technical-overview.md)
* [Microservices: An application revolution powered by the cloud (マイクロサービス: クラウドによって実現されるアプリケーションの革命)](https://azure.microsoft.com/en-us/blog/microservices-an-application-revolution-powered-by-the-cloud/)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png



<!--HONumber=Jan17_HO4-->


