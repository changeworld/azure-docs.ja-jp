<properties
   pageTitle="マイクロサービスの概要 | Microsoft Azure"
   description="マイクロサービスでクラウド アプリケーションを構築することが現代のアプリケーション開発にとって重要である理由と Azure Service Fabric がそれを達成するためのプラットフォームを提供するしくみの概要"
   services="service-fabric"
   documentationCenter=".net"
   authors="msfussell"
   manager="timlt"
   editor="bscholl"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="11/18/2015"
   ms.author="mfussell"/>

# マイクロサービスの手法でアプリケーションを構築する理由は何ですか。
ソフトウェア開発者にとって、アプリケーションを構成要素に加えること新しい手法ではありません。オブジェクト指向、ソフトウェア抽象化、コンポーネント化の中心的な理論的枠組みです。今日、この手法はクラスや共有ライブラリとテクノロジ層のインターフェイスという形態を取り、一般的に、バックエンド ストア、ミドル層ビジネス ロジック、フロントエンド UI による階層型手法で行われています。ここ数年で変化したことは、開発者はビジネス主導のクラウドのために分散アプリケーションを構築しているということです。

変わりゆくビジネス ニーズには次のようなものがあります。

- 顧客基盤を拡大する、つまり、新しい地理的地域に進出することを可能にする、または顧客の場所でデプロイする必要のない規模のサービスを構築し、運用するニーズ。
- 顧客の要望にアジャイルに応答する機能を短期間で届ける。
- リソース利用率を改善し、コストを下げる。

アプリケーションの構築*方法*に影響を与えるのは以上のようなビジネス ニーズです。

## モノリシックとマイクロサービスのデザイン アプローチの比較
すべてのアプリケーションは時間の経過に伴って進化します。成功したアプリケーションは便利であることで進化します。失敗したアプリケーションは進化せず、最終的には廃止となります。問題は、現在の要件についてどれだけ知っているかとその要件は将来どうなると思うかということに集約されます。 たとえば、ある部署のためにレポート アプリケーションを構築するとき、そのアプリケーションが社内で使用され、レポートの保存期間は短いことがわかっている場合、選択する手法は、たとえば、数千万の顧客に動画コンテンツを配信するサービスを構築する場合とは異なります。アプリケーションは後に再設計可能であるという理解の下では、何かを概念実証として完成することが推進要因となることがあります。利用されることがない過剰なエンジニアリングには意味がありません。これは、普通、エンジニアリング上の得失評価となります。一方で、会社がクラウドの構築について話すとき、成長と利用率が期待値となります。問題はその成長と規模が予想できないことであり、早期に試作品を作成し、同時に、将来の成功につながる道を確認することが望まれます。これが、構築、測定、学習、繰り返しからなるリーン スタートアップ手法です。

クライアント/サーバーの時代に入り、各層で特定の技術を利用する階層型アプリケーションを構築する傾向にあります。インターフェイスは階層間となり、通常、層内では、さらに緊密に結合した設計がコンポーネント間で使用された、言い換えれば、開発者はライブラリにコンパイルしたクラスを設計し、構成要素化し、リンクしていくつかの exe や dll を作成したことから「モノリシック」アプリケーションという言葉が発生しました。このモノリシック デザインの手法には長所があります。設計が単純であり、多くの場合、IPC 経由となるため、コンポーネント間の呼び出しが速くなります。誰もが製品を 1 つ試し、人的リソース効率がよくなります。欠点は、アプリケーションが階層内で緊密に結合され、個々のコンポーネントを拡張できないことです。修正プログラムや更新を実行する場合、他の開発者がテストを完了するのを待たなければならず、アジャイルになることが難しくなります。

マイクロサービスはこのような欠点に対処しており、上記のビジネス要件に合わせて調整されますが、マイクロサービス自体にも利点と欠点があります。マイクロサービスの利点は、通常、各マイクロサービスが単純なビジネス機能をカプセル化し、独立して拡大縮小、試験、デプロイ、管理できることです。重要なことは、マイクロサービス手法の利点は、チームが技術主導ではなくビジネス シナリオ主導になる傾向があることです。技術主導であれば、階層型の手法が奨励されます。つまり、実際、小規模のチームが、選択した技術を利用し、顧客シナリオに基づいてマイクロサービスを開発します。言い換えれば、組織はモノリシックを維持する目的で技術を標準とする必要がありません。サービスを所有する個々のチームは、チームの専門知識に基づき、あるいはそのサービスで解決しようとしている問題に最適なものに基づき、チームにとって意味のある行為を実行できます。言うまでもなく、実際、たとえば、特定の NoSql ストアや Web アプリケーション フレームワークを選択する場合、一連の推奨技術を用意することが望ましくなります。マイクロサービスの欠点には、管理する個々のエンティティの数が増えること、さらに複雑なデプロイメントを扱うこと、バージョンを管理すること、マイクロサービスと該当ネットワーク レイテンシの間のネットワーク トラフィックが増えることが挙げられます。煩雑で非常に細かなサービスが多いと実行が難しくなり、依存性を表示するツールがなければ、システム全体を「見る」ことが困難になります。結局のところ、マイクロサービス手法を機能させるのは標準であり、通信方法について同意することであり、厳密なコントラクトではなく、サービスに基づいて必要となるものだけ許容することです。サービスは互いに依存せずに更新されるため、これらの接点を設計の最善に定義することが重要です。マイクロサービス手法による設計を別の言葉で表現すると「詳細な SOA」となります。


***最も簡単に説明すると、マイクロサービス手法とは、サービスを切り離されたサービスの集まりです。各サービスの変更が独立して行われ、同じ通信標準が使用されます。***


クラウド アプリの数が増えるにつれ、アプリ全体をシナリオ中心の独立サービスに分割するこの手法が長期的には優れた手法であることに気付く人が増えています。
## アプリケーション開発手法の比較

![Service Fabric プラットフォーム][Image1]

(1) モノリス アプリにはドメイン固有機能が含まれ、通常、Web、ビジネス、データなど、機能的な層により分割されます。

(2) 複数のサーバー/VM/コンテナーでクローンを作成することでモノリシック アプリを拡張します。

(3) マイクロサービス アプリケーションは機能をより小規模の個別サービスに分割します。

(4) この手法では、各サービスを非依存でデプロイすることで拡張します。サーバー/VM/コンテナーにわたってサービスのインスタンスを作成します。


あらゆるプロジェクトをマイクロサービス手法で設計できるわけではありません。しかしながら、前述のように、ビジネスの目的に合わせて調整できます。また、後で、必要に応じて、コードをマイクロサービス設計に作り直すことができるため、モノリシック手法が始めに採用されることがあります。よく行われていることですが、モノリシック アプリが用意し、それを段階的に分解します。そのとき、拡張する、またはアジャイルにする必要がある機能的領域から始めます。

要約すると、マイクロサービス手法とは、小規模のサービスをたくさん作成し、マシンのクラスター全体にデプロイされたコンテナーで実行することです。小規模のチームが 1 つのシナリオに注目して各サービスを開発し、非依存で試験し、バージョン管理し、デプロイし、拡張します。そのため、全体としてのアプリケーションが進化できます。

## マイクロサービスとは何か。

マイクロサービスにはさまざまな定義があり、インターネットを検索すれば、それぞれの視点と定義を提示する優れたリソースがいろいろ見つかります。しかしながら、多くのリソースで一致している特性は次のようになります。

- 顧客またはビジネス シナリオをカプセル化します。どのような問題を解決していますか。
- 小規模のエンジニアリング チームが開発します
- あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できます 
- 非依存でバージョン管理、デプロイ、拡張されるコードとステート (任意) で構成されます
- 明確に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します 
- 場所の解決に使用される一意の名前 (URL) が与えられる
- エラーが発生しても、一貫性を維持し、利用できます

これを次のようにまとめることができます。

***マイクロサービス アプリケーションは、明確に定義されたインターフェイスと標準プロトコルで互いに通信する、非依存でバージョン管理され、拡張可能な小規模の顧客中心サービスから構成されます。***


前のセクションでは、上記の最初の 2 点について説明しました。次に、他の点について説明します。

### あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できます
開発者は、技能とサービスのニーズに合わせ、言語やフレームワークを自由に選択できなければなりません。サービスによっては、C++ の長所が他の言語より重視されることがあれば、C# や Java の管理開発の容易さが最も重要になることがあります。場合によっては、特定のサードパーティ ライブラリ、データ ストレージ技術、クライアントにサービスを公開する手法が必要になります。

技術を選択したところで、サービスの運用管理、ライフサイクル管理、拡張に関する話題に移ります。

### 非依存でバージョン管理、デプロイ、拡張されるコードとステート  

マイクロサービスの記述方法に関係なく、各サービスのコードとステート (任意) は非依存でデプロイ、アップグレード、拡張されます。これは詰まるところ、技術の選択と、拡張に関しては、コードとステートの両方のパーティショニング (またはシャーディング) 方法の理解の問題になるため、実際、難しい問題の 1 つです。コードとステートで別々の技術が使用される場合 (今日、その傾向にあります)、マイクロサービスのデプロイメント スクリプトは両方を拡張できるものでなければなりません。一部のマイクロサービスをアップグレードするとき、それをすべて一度にアップグレードしなければならない場合、アジャイル性と柔軟性も問題になります。少しの間、モノリシックとマイクロサービスの手法比較に戻りますが、下の図はステートの格納方法の違いを示しています。

### アプリケーション スタイル間のステート ストレージ
![Service Fabric プラットフォーム][Image2]

***左は、1 つのデータベースと固有のテクノロジの層からなるモノリシック手法です。***

***右はマイクロサービス手法であり、マイクロサービスが相互接続されています。一般的にステートの対象はマイクロサービスであり、さまざまな技術が利用されます。***

モノリシック手法では、通常、1 つのデータベースがアプリケーションに利用されます。長所はこれが単一の場所となり、デプロイが簡単になります。各コンポーネントには、そのステートを格納するテーブルを 1 つ与えることができます。難しいことにチームは厳密にステートを分離しなければならず、既存の顧客テーブルに新しい列を追加し、テーブル間で結合を行い、ストレージ層で依存性を作ってしまう傾向があるのは避けられません。依存性ができると、個別コンポーネントの拡張は白紙に戻ります。マイクロサービス手法では、各サービスがそのステートを管理し、格納します。つまり、サービスの要求に対して、コードとステートの両方をまとめて拡張する役割を担います。この手法の欠点は、アプリケーション データのビュー (またはクエリ) を作成しなければならないということです。異種のステート ストアにわたりクエリを実行する必要があるためです。通常、この問題は、マイクロサービスの集合全体でビューを構築する個別のマイクロサービスを用意することで解決されます。データに対して複数のアドホック クエリを実行する必要がある場合、各マイクロサービスでは、オフライン分析のためにデータ ウェアハウス サービスにそのデータを書き込むことを検討する必要があります。


バージョン管理はデプロイされたバージョンのマイクロサービスに固有であり、複数の異なるバージョンをロールアウトし、並列で実行するために必要です。バージョン管理は、アップグレード中に新しいバージョンのマイクロサービスにエラーが発生し、前のバージョンにロールバックしなければならない状況に対処します。バージョン管理の他のシナリオとしては、「複数のユーザーが複数のバージョンのサービスを試すとき、A/B スタイルの試験を実行する」というのがあります。たとえば、特定の集合の顧客に対してマイクロサービスをアップグレードし、新しい機能を試験してからもっと広範囲でロールアウトすることが一般的に行われています。マイクロサービスのライフサイクル管理の次は、マイクロサービス間の通信の問題です。


### 明確に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します

過去 10 年間に公開された SOA に関する広範囲の文書を読む以外、このトピックで取り上げることはほとんどありません。この問題の大半は、通信パターン関連とされたためです。現状では、一般的に、REST 手法、http プロトコル、tcp プロトコルを利用し、シリアル化形式として XML または JSON を利用するということに帰着します。インターフェイスの観点では、Web 設計手法を導入するということになります。バイナリ プロトコルや独自のデータ形式を使用しても問題はありませんが、マイクロサービスが公開されたとき、ユーザーがそれを使いこなせない場合に備える必要があります。

### 場所の解決に使用される一意の名前 (URL) が与えられる

マイクロサービス手法は Web に似ているということは繰り返しお伝えしています。Web と同様に、マイクロサービスは、実行される場所に関係なく、アドレス指定できるものでなければなりません。どのマシンがどのマイクロサービスを実行しているのかわからないようであれば、じきに問題が起こります。DNS が特定の URL を特定のマシンに解決するように、現在地を検出するための一意の名前をマイクロサービスに与える必要があります。そのため、マイクロサービスには一意の名前を与え、実行されているインフラストラクチャから独立させる必要があります。これは、言うまでもなく、サービスのデプロイ方法と検出方法の間に対話があることを暗示します。サービス レジストリが必要になるためです。同様に、マシンにエラーが発生するタイミングとマイクロサービスの動作の間にも対話が必要になります。それにより、レジストリ サービスは現在位置を伝えることができます。それでは次に回復力と一貫性に関する次のトピックに移ります。
 
### エラーが発生しても、一貫性を維持し、利用できます

予期しないエラーの対処は、特に分散システムにおいて、解決しなければならない困難の 1 つです。開発者が記述するコードの大半は例外を処理し、試験でもこの例外に多くの時間が費やされます。しかしながら、エラーを処理するコードを記述する以上に問題は複雑です。マイクロサービスが実行されているマシンが故障した場合、どうなるでしょうか。 マイクロサービスの故障を検出する必要があるだけでなく (これ自体も難題ですが)、マイクロサービスを再起動する方法も必要になります。マイクロサービスは故障に強くなければなりません。別のマシンで再起動し、可用性を維持する機能が必要になります。また、マイクロサービスに代わって保存されたステートも重要になります。このステートはどこから復元できるでしょうか。問題なく再起動できるでしょうか。 言い換えると、コンピューティングに回復力が必要である (たとえば、プロセス再起動のために) のと同様に、ステートやデータ (データの紛失がなければ、データの一貫性が維持されます) にも回復力が必要になります。

回復力の問題は、アプリケーション アップグレード中にエラーが発生するなどの場合、さらに複雑になります。マイクロサービスは、デプロイメント システムと連動するとき、復元するだけでなく、今後も新しいバージョンに移行できるか、一貫性を維持するために前のバージョンにロールバックするか決定する必要もあります。続行するために必要なマシンの有無や前のバージョンのマイクロサービスを復元する方法などの問題を考慮する必要があります。このような決定を行うために、マイクロサービスは正常性情報を送信する必要があります。

### 正常性と診断の報告

多くの場合、明らかに見落とされていますが、マイクロサービスが正常性と診断を報告することは非常に重要です。報告しなければ、運用の観点から何の情報も得られません。サービスの集合に依存性がなく、各サービスのログが非依存で記録され、マシンのクロック スキューを処理しなければ診断イベントの順番がわからないような状況では、イベントの相関関係を理解することは難題です。同様に、取り決めたプロトコルとデータ形式でマイクロサービスと対話するとき、正常性と診断イベントのログ記録方法の標準化が必要になります。詰まるところ、クエリと表示が可能なイベント ストアが必要になります。マイクロサービス手法では、異なるチームが 1 つのログ記録形式で同意することが重要です。全体としてのアプリケーションで診断イベントを表示するとき、一貫性のある方法が必要になるためです。

正常性は診断とは異なります。適切な措置を講じるためにマイクロサービスがその現状を報告するのが正常性です。アップグレードとデプロイメントのメカニズムで可用性を維持するとき、その違いは明らかです。たとえば、プロセスのクラッシュやマシンの再起動に起因し、現在、サービスの状態が正常でないとしても、動作は続きます。この場合、アップグレードを強行して事態を悪化させてはなりません。先に調査するか、マイクロサービスに回復時間を与えることが賢明です。マイクロサービスが提供する正常性イベントは情報を与え、判断を可能にします。実際、自己回復サービスの構築に役立ちます。

## マイクロサービス プラットフォームとしての Service Fabric

Service Fabric は、Microsoft が箱入り製品 (通常、モノリシック スタイル) からサービスに移行する過程で生まれたサービスであり、Azure SQL データベース、Document DB、その他のコア Azure サービスなど、大規模なサービスを構築し、運用した経験が主な原動力でした。全体的に、スケール、アジャイル性、独立チームのビジネス ニーズに取り組んだものであり、このプラットフォームは、それを採用するサービスが増えるにつれ、時間と共に進化しています。重要なことは、Service Fabric はどこでも、Azure だけではなく、スタンドアロン Windows Server デプロイメントでも実行できなければならなかったということです。

***Service Fabric の目的は、故障やアップグレードなど、サービスの構築と実行に伴う課題を解決することであり、チームがマイクロサービス手法でビジネス上の問題を解決できるようにインフラストラクチャ リソースを効率的に活用します。***

Service Fabric では、2 つの広範囲領域でマイクロサービス手法によるアプリケーション構築を支援します。

- デプロイメント、アップグレード、故障したサービスの検出と再開、サービスが現在実行されている場所の検出、ステート管理、正常性監視などを処理する一連のシステム サービスからなるプラットフォーム。実際、このようなシステム サービスにより、前述のマイクロサービスの特性の多くが可能になります。

-  マイクロサービスとしてのアプリケーション構築を支援するプログラミング API またはフレームワーク。提供されるプログラミング API は「[Reliable Actors と Reliable Services](service-fabric-choose-framework.md)」と呼ばれています。言うまでもなく、どのようなコードでもマイクロサービスを構築できますが、この API を利用すれば、作業が単純になるだけでなく、さらに深いレベルでプラットフォームと統合されるので、たとえば、正常性や診断に関する情報が得られたり、組み込みの高可用性を利用できます。

***Service Fabric は、サービスの構築方法や技術の利用方法に依存しません。しかしながら、マイクロサービスの構築を非常に簡単にする組み込みのプログラミング API を提供します。***

### 私のアプリケーションにマイクロサービスは適しているでしょうか。

その可能性はあります。経験から話せば、Microsoft では、ビジネス向けのクラウドの構築を要請されることが増え、多くの開発チームはマイクロサービス式の手法の長所を実感しています。たとえば、Bing では、何年もの間、この手法を検索に取り入れています。マイクロサービスに不慣れなチームもいて、解決しなければならない課題があるが、それはそのチームの強みではないということがありました。そこで Service Fabric がサービス構築技術として注目されました。

Service Fabric の目的は、マイクロサービス手法に伴うアプリケーション構築の複雑性を減らすことです。複雑性が減れば、お金のかかる再設計を繰り返す必要がなくなります。小規模から始め、必要に応じて拡張する。サービスを廃止し、新しいサービスを追加する。顧客の利用状況に合わせて進化する。それがマイクロサービス手法です。多くの開発者にとってマイクロサービスを本当に使いやすいものにするにはまだまだたくさんの課題が残っていることはわかっています。コンテナーとアクター プログラミング モデルはいずれもこの方向性における小さな前進の例です。さらに多くの革新的技術が開発され、簡易化が進むことを確信しています。 <!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## 次のステップ

* 詳細: 
	* [Service Fabric の概要](service-fabric-overview.md)
	* [技術概要](service-fabric-technical-overview.md)
* Service Fabric [開発環境](service-fabric-get-started.md)の設定
* サービスに[プログラミング モデル フレームワーク](service-fabric-choose-framework.md)を選択する。

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png

<!---HONumber=Nov15_HO4-->