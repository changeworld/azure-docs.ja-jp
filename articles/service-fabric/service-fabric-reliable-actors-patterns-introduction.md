<properties
   pageTitle="Reliable Actor のパターンとアンチパターン | Microsoft Azure"
   description="アクター プログラミング モデルの概要、Service Fabric Reliable Actor と効果的に連動する設計パターン、回避するべきアンチパターンを提供します。"
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="vturecek"/>

# 高信頼アクターの設計パターンの概要

Service Fabric の高信頼アクター プログラミング モデルは、クラウド スケールで現実の問題を解決するためにアクター モデルに基づいて構築されたプラットフォームです。Azure Service Fabric は、開発と管理が容易なクラウドおよびオンプレミスの両方の信頼性の高いスケーラブルなアプリケーションを構築するためのプラットフォームです。この記事は、実際問題に関する実用的な説明を意図しています。さまざまなパターンを通読したら、Reliable Actor モデルを使用して、"エンタープライズ" または "クラウド" ソリューションを構築する方法を理解できるはずです。

## パターン

このセクションでは、顧客との契約時に採用される一連のパターンおよび関連するシナリオの一覧を示します。これらのパターンは、お客様が Microsoft Azure でビルドする広範なソリューションに該当する問題のクラスを表します。シナリオは実際のケースに基づいていますが、読者にパターンがより明確になるようにドメイン固有の問題のほとんどを除去しました。ほとんどのサンプル コードは単純で明白なことがわかるでしょう。コードが含まれているのは完全を期すためであり、特にそれ以外の意味はありません。

このホワイト ペーパーに記載のパターンは包括的でも規範的でもありません。同じ問題やパターンを異なる方法で解決することもできます。

[パターン: スマート キャッシュ](service-fabric-reliable-actors-pattern-smart-cache.md)

[パターン: 分散ネットワークとグラフ](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[パターン: リソースのガバナンス](service-fabric-reliable-actors-pattern-resource-governance.md)

[パターン: ステートフル サービスの構成](service-fabric-reliable-actors-pattern-stateful-service-composition.md)

[パターン: モノのインターネット](service-fabric-reliable-actors-pattern-internet-of-things.md)

[パターン: 分散計算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[いくつかのアンチ パターン](service-fabric-reliable-actors-anti-patterns.md)

### アクターの詳細、簡単な歴史

アクター モデルが初めて登場した Hewitt 等による[論文](http://dl.acm.org/citation.cfm?id=1624804)は 1973 年に発表されましたが、分散システムの同時性と複雑さに対処する手段としてアクター モデルが注目を集めたのは比較的最近のことです。アクター モデルは、相互に分離された微少な個別オブジェクトであるアクターをサポートします。アクターは非同期メッセージを受け渡して通信し、アクター間で直接通信できます。アクターは、単一スレッドのセマンティクスで実行します。アクターの状態のカプセル化および他のアクターからの分離と併せて、同時実行に関する問題がアクターのコードから除去されることで、高度に並列的なシステムを簡単に作成できます。アクターは、利用可能なハードウェア リソースのプール上に動的に作成されます。

[Erlang](http://www.erlang.org/) は、アクター モデルの最も一般的な実装です。開発者はアクター モデルを再発見するようになり、Erlang および Erlang に似た新しいソリューションである [Scala](http://www.scala-lang.org/) アクター、[Akka](http://akka.io)、[Akka.net](http://getakka.net/)、[DCell](http://research.microsoft.com/pubs/75988/dcell.pdf) の作成に新たな関心を刺激されています。

## Azure Service Fabric の概要

Reliable Actor は、アクター モデルの実装であり、Erlang および分散オブジェクト システムから借用したいくつかのアイデアに、アクター インダイレクションのレイヤーを追加し、Azure Service Fabric プラットフォームを利用する統合されたプログラミング モデルでそれらを公開しています。

Reliable Actor の主なメリットは、1) エキスパート プログラマーでなくても**開発生産性が高く**、2) プログラマーが特別なことをしなくても**もともと透過的な拡張性を備えている**ことです。Reliable Actor は Service Fabric およびツールの基盤上で実行する .NET ライブラリなので、複雑な分散アプリケーションの開発が格段に容易になり、設計段階でスケーラブルなアプリケーションになります。以下ではこれらの利点についてさらに説明します。このプログラミング モデルは、以下の重要な抽象化、保証、およびシステム サービスを提供することで、熟練/非熟練両方のプログラマーの生産性を向上させます。

* *使い慣れたオブジェクト指向プログラミング (OOP) パラダイム*。アクターは、非同期メソッドおよびプロパティを備えた宣言済みの .NET アクター インターフェイスを実装する .NET クラスです。そのため、プログラマーからは、アクターはメソッド/プロパティを直接呼び出すことができるリモート オブジェクトのように見えます。これにより、メソッドの呼び出しをメッセージにして、正しいエンドポイントにルーティングし、ターゲット アクターのメソッドを呼び出して、エラーや困難なケースを完全に透過的な方法で処理することにより、使い慣れた OOP パラダイムがプログラマーに提供されます。

* *アクターのシングル スレッド実行。* Reliable Actor のランタイムは、アクターが同時に複数のスレッドで実行しないことを保証します。他のアクターからの分離と組み合わせて、プログラマーはアクター レベルでの同時性に直面することがないため、共有データへのアクセスを制御するためにロックや他の同期メカニズムを使用する必要はありません。この機能だけで、分散アプリケーションの開発が非熟練プログラマーでも扱いやすくなります。

* *透過的なアクティブ化。* このランタイムは、処理するメッセージがある場合にのみ、必要に応じてアクターをアクティブにします。これにより、アプリケーションのコードによって認識されて制御されるアクターの論理的作成の概念と、アプリケーションに対して透過的なメモリ内でのアクターの物理的なアクティブ化が、明確に分離されます。Reliable Actor は、仮想メモリと同じように、アクターを “ページアウト” (非アクティブ化) または “ページイン” (アクティブ化) するタイミングを決定します。アクターがある時点で物理メモリ内にあるかどうかにかかわらず、アプリケーションは論理的に作成されたアクターの “メモリ空間” 全体に中断なしにアクセスできます。ハードウェア リソースのプールへのアクターの配置と移行により、透過的なアクティブ化は動的で適応型の負荷分散を可能にします。

* *場所の透過性。* プログラマーがアクターのメソッドの呼び出しまたは他のコンポーネントへの受け渡しに使用するアクター参照 (プロキシ オブジェクト) には、アクターの論理 ID のみが含まれます。アクターの論理 ID から物理的な場所への変換および対応するメッセージのルーティングは、Reliable Actor ランタイムによって透過的に行われます。アプリケーション コードは、アクターの物理的な場所とは無関係にアクターと通信します。物理的な場所は、障害やリソース管理のため、または呼び出された時点でアクターが非アクティブ化されているため、時間の経過と共に変化する可能性があります。

* *永続的なストアとの透過的な統合。* Reliable Actor は、アクターのメモリ内の状態の永続的ストアへの宣言型マッピングに対応します。これは更新を同期化し、永続的な状態が正常に更新された後でのみ呼び出し元が結果を受け取ることを透過的に保証します。

* *高可用性、フェイルオーバーのサポート、アプリケーション ライフサイクルの管理。* Reliable Actor の状態は、プラットフォームによって管理され、たとえばクラスター内のノードで障害が発生した場合に復元できるようにレプリケートされます。また、Service Fabric はアプリケーションのライフサイクルを管理し、ダウンタイムなしでアプリケーションをアップグレードできます。Reliable Actor のプログラミング モデルは、アプリケーションまたはサービスの大幅な拡張が成功するようプログラマーを誘導するように設計されています。これは、実績のあるベスト プラクティスとパターンを組み込み、下位レベルのシステム機能の効率的な実装を提供することによって実現されます。Service Fabric アプリケーションのスケーラビリティとパフォーマンスを可能にするいくつかの重要な要因を次に示します。

* *アプリケーションの状態の暗黙的なきめ細かい分割。* アクターを直接対応可能なエンティティとして使用することにより、プログラマーはアプリケーションの全体的な状態を暗黙的に分割します。Reliable Actor のプログラミング モデルではアクターの大きさは規定されていませんが、通常は、ユーザー アカウントや注文といったアプリケーションの自然なエンティティをそれぞれが表す比較的多数 (百万以上) のアクターを使用します。アクターを個別に処理でき、それらの物理的な場所はランタイムによって抽象化されているため、アプリケーション開発者が何も考えなくても、透過的かつ汎用的な方法で非常に柔軟に負荷分散とホット スポットを処理できます。

* *適応型のリソース管理。* アクターは対話する他のアクターの局所性について何も想定せず、場所は透過的であるため、このランタイムは、要求の受信に失敗することなく、負荷と通信パターンに対応して、コンピューティング クラスター全体へのアクターの配置/移行をきめ細かく決定することにより、非常に動的な方法で、使用可能なハードウェア リソースの割り当てを管理および調整できます。特定のアクターの複数のレプリカを作成することで、ランタイムは、アプリケーションのコードを変更しなくても、必要に応じてアクターのスループットを向上させることができます。

* *多重化通信。* Service Fabric のアクターは論理エンドポイントを持ち、アクター間のメッセージは、すべて対すべての物理接続 (TCP ソケット) の固定セットによって多重化されます。これにより、このランタイムは、OS のオーバーヘッドなしでアクターごとに非常に多数 (数百万) のアドレス指定可能なエンティティをホストできます。さらに、アクターのアクティブ化/非アクティブ化では、TCP ポートや HTTP URL などの物理エンドポイントを登録/登録解除するコストは発生しません。

* *効率的なスケジューリング。* Reliable Actor のランタイムは、物理プロセッサ コアごとに 1 スレッドのカスタム スレッド プールにより多数のシングル スレッド アクターの実行をスケジュールします。非ブロッキング継続ベースの形式 (Reliable Actor のプログラミング モデルの必要条件) で記述されたアクターのコードでは、アプリケーション コードは競合のない非常に効率的な "協調" マルチスレッド方式で実行されます。これにより、システムは高スループットを達成し、きわめて安定した非常に高い CPU 使用率 (最大 90 + %) で実行できます。システム内のアクターの数と負荷が増加してもスレッドまたは他の OS プリミティブが増えないことは、個々のノードとシステム全体のスケーラビリティの向上につながります。

* *明示的な非同期性。* Reliable Actor のプログラミング モデルにより、分散アプリケーションの非同期的性質が明確になり、プログラマーが非ブロッキング非同期コードを作成する指針となります。これにより、マルチスレッドを明示的に使わずに、高い分散並列性と全体的スループットが実現されます。

<!---HONumber=Nov15_HO2-->