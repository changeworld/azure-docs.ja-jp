<properties
   pageTitle="高信頼アクターのライフサイクル | Microsoft Azure"
   description="Service Fabric 高信頼アクターのライフサイクルとガベージ コレクションについて説明します"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="amanbha"/>


# アクターのライフサイクルとガベージ コレクション
アクターは最初の呼び出し時にアクティブ化されます。一定期間使用されていない場合、アクターは非アクティブ化されます (アクター ランタイムによってガベージ コレクトされる)。この期間を構成するには、以下のアクターのガベージ コレクションに関するセクションを参照してください。

アクターをアクティブ化する場合:

- アクターが呼び出し時にまだアクティブになっていない場合は、新しいアクターが作成されます。
- アクターの状態が読み込まれます (ステートフル アクターの場合)。
- `OnActivateAsync` メソッド (アクターの実装でオーバーライドできる) が呼び出されます。
- アクターは、アクティブ アクター テーブルに追加されます。

アクターを非アクティブ化する場合:

- アクターは、一定期間使用されていない場合、アクティブ アクター テーブルから削除されます。
- `OnDeactivateAsync` メソッド (アクターの実装でオーバーライドできる) が呼び出されます。呼び出されると、アクターのタイマーをすべてクリアします。

> [AZURE.TIP]Fabric アクター ランタイムはいくつかの [アクターのアクティブ化と非アクティブ化に関するイベント](service-fabric-reliable-actors-diagnostics.md#actor-activation-and-deactivation-events)を出力します。これらは、診断やパフォーマンスの監視に役立ちます。

## アクターのガベージ コレクション
アクター ランタイムは、一定期間使用されていないアクターを定期的にスキャンし、そのアクターを非アクティブ化します。アクターは非アクティブ化されると、共通言語ランタイム (CLR) でガベージ コレクトすることができます。

ガベージ コレクションの目的で、次のような状態は「使用中」と見なされます。

- 呼び出しを受信する
- `IRemindable.ReceiveReminderAsync` メソッドが呼び出されている (アクターがアラームを使用する場合にのみ適用可)

アクターがタイマーを使用し、そのタイマーのコールバックが呼び出された場合は、「使用中」と見なされ**ない**ことに注意してください。

ガベージ コレクションの詳細に入る前に、次の用語を定義することが重要です。

- *スキャン間隔*。これは、アクター ランタイムがアクティブ アクター テーブルで、ガベージ コレクトできるアクターをスキャンする間隔です。この既定値は 1 分です。
- *アイドル タイムアウト*。これは、ガベージ コレクションの前に、アクターを未使用 (アイドル) のままにしておく必要がある時間です。この既定値は 60 分です。

通常は、これらの既定値を変更する必要はありません。ただし、必要に応じて、`ActorGarbageCollection` 属性を使用して、これらの間隔をそのアセンブリ内のすべてのアクター型のアセンブリ レベルまたはアクター型レベルで変更することはできます。次の例は、HelloActor のガベージ コレクション間隔の変更を示しています。

```csharp
[ActorGarbageCollection(IdleTimeoutInSeconds = 10, ScanIntervalInSeconds = 2)]
class HelloActor : Actor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

アセンブリ レベルで `ActorGarbageCollection` 属性の既定値を変更するには、次のスニペットを `AssemblyInfo.cs` に追加します。

```csharp
[assembly: ActorGarbageCollection(IdleTimeoutInSeconds = 10, ScanIntervalInSeconds = 2)]
```

アクティブ アクター テーブル内の各アクターについて、アクター ランタイムはアイドル (つまり、未使用) 状態だった時間を追跡します。アクター ランタイムは、`ScanIntervalInSeconds` ごとにアクターをそれぞれチェックして、ガベージ コレクションが可能かどうかを確認し、`IdleTimeoutInSeconds` の間アイドル状態だった場合はアクターを収集します。

アクターが使用されるたびに、そのアイドル時間は 0 にリセットされます。その後、アクターをガベージ コレクトできるのは、再び `IdleTimeoutInSeconds` の間アイドル状態のままになった場合のみです。アクター インターフェイス メソッドまたはアクター アラーム コールバックが実行された場合、アクターは使用されていると見なされることを思い出してください。タイマー コールバックが実行された場合、アクターは使用されていると見なされ**ません**。

次の図には、これらの概念を説明するための例が含まれています。

![アイドル時間の例][1]

この例は、アクティブ アクター テーブルに 1 つだけアクティブ アクターがあることを前提としています。この例では、このアクターの有効期間に対するアクター メソッドの呼び出し、アラームおよびタイマーの影響を示しています。この例では次の点に注意する必要があります。

- ScanInterval は 5、IdleTimeout は 10 にそれぞれ設定されます。(概念の説明のみが目的であるため、ここでは単位は重要ではありません)。
- ガベージ コレクションの対象となるアクターのスキャンは、5 のスキャン間隔で定義されると、T=0、5、10、15、20、25 で行われます。
- 定期的なタイマーは T=4、8、12、16、20、24 で開始され、そのコールバックが実行されます。アクターのアイドル時間に影響はありません。
- T=7 のアクター メソッド呼び出しは、アイドル時間を 0 にリセットし、アクターのガベージ コレクションを遅らせます。
- アクター アラームのコールバックは T=14 で実行され、アクターのガベージ コレクションをさらに遅らせます。
- T=25 のガベージ コレクションのスキャン中に、アクターのアイドル時間は最終的に 10 のアイドル タイムアウトを超え、アクターはガベージ コレクトされます。

メソッドの実行にどれだけ時間がかかっても、メソッドのいずれかが実行されている間にアクターがガベージ コレクトされることはないことに注意してください。前述のように、アクター インターフェイス メソッドとアラームのコールバックを実行すると、アクターのアイドル時間が 0 にリセットされるため、ガベージ コレクションが行われなくなります。タイマー コールバックの実行では、アイドル時間は 0 にリセットされません。ただし、タイマー コールバックの実行が完了するまで、アクターのガベージ コレクションは遅延されます。

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-lifecycle/garbage-collection.png

<!---HONumber=AcomDC_1217_2015-->