---
title: チュートリアル - Azure IoT Hub の暗号化と X.509 証明書について理解する | Microsoft Docs
description: チュートリアル - Azure IoT Hub の暗号化と X.509 PKI について理解する
author: v-gpettibone
manager: philmea
ms.service: iot-hub
services: iot-hub
ms.topic: tutorial
ms.date: 02/25/2021
ms.author: robinsh
ms.custom:
- mvc
- 'Role: Cloud Development'
- 'Role: Data Analytics'
ms.openlocfilehash: 2c375a02f534572826e1ebd6b8549e59f6e83640
ms.sourcegitcommit: 2654d8d7490720a05e5304bc9a7c2b41eb4ae007
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/13/2021
ms.locfileid: "107378382"
---
# <a name="tutorial-understanding-public-key-cryptography-and-x509-public-key-infrastructure"></a>チュートリアル: 公開キー暗号化と X.509 公開キー基盤について理解する

X.509 証明書を使用して、Azure IoT ハブに対してデバイスを認証できます。 証明書は、デバイスの公開キーが含まれているデジタル ドキュメントであり、デバイスが主張どおりのものであることを確認するために使用できます。 X.509 証明書と証明書失効リスト (CRL) については、[RFC 5280](https://tools.ietf.org/html/rfc5280) に記載されています。 証明書は、X.509 公開キー基盤 (PKI) の一部にすぎません。 X.509 PKI について理解するには、暗号アルゴリズム、暗号化キー、証明書、および証明機関 (CA) について理解する必要があります。

* **アルゴリズム** は、元のプレーンテキスト データを暗号化テキストに変換し、プレーンテキストに戻す方法を定義します。
* **キー** は、アルゴリズムへの入力として使用されるランダムまたは擬似ランダムなデータ文字列です。
* **証明書** は、エンティティの公開キーが含まれているデジタル ドキュメントであり、証明書のサブジェクトが主張どおりのものであるかどうかを確認するために使用できます。
* **証明機関** は、証明書のサブジェクトの信頼性を証明します。

証明機関 (CA) から証明書を購入できます。 また、テストおよび開発を行う場合や、自己完結型の環境で作業している場合は、自己署名ルート CA を作成することもできます。 たとえば、1 つまたは複数のデバイスを所有していて、IoT ハブ認証をテストする場合は、ご自分のルート CA に自己署名し、それを使用してデバイス証明書を発行できます。 自己署名デバイス証明書を発行することもできます。 これについては、以降の記事で説明します。

X.509 証明書についてもっと詳しく説明し、それらを使用して IoT ハブに対してデバイスを認証する前に、証明書の基盤となる暗号化について説明します。

## <a name="cryptography"></a>暗号化

暗号化は、情報や通信を保護するために使用されます。 これは通常、暗号化手法を使用して、プレーンテキスト (通常のテキスト) を暗号化テキスト (エンコードされたテキスト) にスクランブルし、元に戻すことによって行われます。 このスクランブル プロセスは暗号化と呼ばれます。 逆のプロセスは解読と呼ばれます。 暗号化は次の目的に関係しています。

* **機密性**: 対象ユーザーのみが情報を理解できます。
* **整合性**: ストレージ内または転送中の情報を変更することはできません。
* **否認防止**: 情報の作成者は後でその作成を否認することはできません。
* **認証**: 送信者と受信者はお互いの ID を確認できます。

## <a name="encryption"></a>暗号化

暗号化プロセスには、アルゴリズムとキーが必要です。 アルゴリズムは、データをプレーンテキストから暗号化テキストに変換し、プレーンテキストに戻す方法を定義します。 キーは、アルゴリズムへの入力として使用されるランダムなデータ文字列です。 プロセスのすべてのセキュリティはキーに含まれています。 そのため、キーは安全に保存する必要があります。 ただし、最もよく使用されているアルゴリズムの詳細は一般公開されています。

暗号化には 2 つの種類があります。 対称暗号化では、暗号化と解読の両方に同じキーが使用されます。 非対称暗号化では、暗号化と解読の実行に、異なるものの数学的に関連するキーが使用されます。

### <a name="symmetric-encryption"></a>対称暗号化

対称暗号化では、同じキーを使用して、プレーンテキストを暗号化テキストに暗号化し、暗号化テキストをプレーンテキストに解読します。 キーの必要な長さは、ビット数で表され、アルゴリズムによって決まります。 キーを使用してプレーンテキストが暗号化された後、暗号化されたメッセージが受信者に送信され、その後、暗号化テキストが解読されます。 対称キーは、受信者に安全に送信する必要があります。 対称アルゴリズムを使用する場合にセキュリティ上のリスクが最も高いのはキーの送信です。

![対称暗号化の例](media/tutorial-x509-introduction/symmetric-keys.png)

### <a name="asymmetric-encryption"></a>非対称暗号化

対称暗号化のみを使用する場合の問題点は、通信のすべての関係者が秘密キーを持っている必要があることです。 しかし、許可されているユーザーへの送信中に、許可されていない第三者がキーをキャプチャできる可能性があります。 この問題に対処するには、代わりに非対称または公開キー暗号化を使用します。

非対称暗号化では、すべてのユーザーがキーの組と呼ばれる数学的に関連する 2 つのキーを持っています。 1 つは公開キーで、もう 1 つは秘密キーです。 キーの組によって、データの解読に必要な秘密キーにアクセスできるのが受信者のみになります。 次の図は、非対称暗号化プロセスの概要を示しています。

![非対称暗号化の例](media/tutorial-x509-introduction/asymmetric-keys.png)

1. 受信者が公開および秘密キーの組を作成し、公開キーを CA に送信します。 CA が公開キーを X.509 証明書にパッケージ化します。

1. 送信者が CA から受信者の公開キーを取得します。

1. 送信者が暗号アルゴリズムを使用して、プレーンテキスト データを暗号化します。 受信者の公開キーを使用して、暗号化が実行されます。

1. 送信者が暗号化テキストを受信者に送信します。 受信者は暗号化テキストの解読に必要な秘密キーを既に持っているため、キーを送信する必要はありません。

1. 受信者が指定された非対称アルゴリズムと秘密キーを使用して、暗号化テキストを解読します。

### <a name="combining-symmetric-and-asymmetric-encryption"></a>対称と非対称の暗号化の組み合わせ

対称と非対称の暗号化を組み合わせると、それらの相対的なメリットを活かすことができます。 対称暗号化は非対称よりもはるかに高速ですが、秘密キーを他の関係者に送信する必要があるため、それほど安全ではありません。 2 種類を組み合わせる場合は、対称暗号化を使用して、プレーンテキストを暗号化テキストに変換できます。 非対称暗号化を使用して、対称キーを交換します。 これを示したのが次の図です。

![対称と非対称の暗号化](media/tutorial-x509-introduction/symmetric-asymmetric-encryption.png)

1. 送信者が受信者の公開キーを取得します。

1. 送信者が対称キーを生成し、それを使用して元のデータを暗号化します。

1. 送信者が受信者の公開キーを使用して、対称キーを暗号化します。

1. 送信者が暗号化された対称キーと暗号化テキストを目的の受信者に送信します。

1. 受信者が受信者の公開キーと一致する秘密キーを使用して、送信者の対称キーを解読します。

1. 受信者が対称キーを使用して、暗号化テキストを解読します。

### <a name="asymmetric-signing"></a>非対称署名

非対称アルゴリズムを使用して、データを変更から保護し、データ作成者の ID を証明できます。 次の図は、非対称署名が送信者の ID 証明にどのように役立つのかを示しています。

![非対称署名の例](media/tutorial-x509-introduction/asymmetric-signing.png)

1. 送信者が非対称暗号アルゴリズムを介してプレーンテキスト データを渡します。暗号化には秘密キーを使用します。 このシナリオでは、非対称暗号化について詳しく説明した前のセクションで示した秘密と公開キーの使用が逆転している点に注意してください。

1. 結果として生成された暗号化テキストが受信者に送信されます。

1. 受信者がディレクトリから送信者の公開キーを取得します。

1. 受信者が送信者の公開キーを使用して、暗号化テキストを解読します。 元のテキストを最初に暗号化した秘密キーにアクセスできるのは送信者だけであるため、結果として生成されたプレーンテキストは送信者の ID の証明になります。

## <a name="signing"></a>署名

デジタル署名を使用して、転送中または保存時のデータが変更されたかどうかを確認できます。 データは、指定されたメッセージから数学的な結果を生成する一方向の関数であるハッシュ アルゴリズムを介して渡されます。 結果は、"*ハッシュ値*"、"*メッセージ ダイジェスト*"、"*ダイジェスト*"、"*署名*"、または "*サムプリント*" と呼ばれます。 ハッシュ値を元に戻して、元のメッセージを取得することはできません。 メッセージの小さな変更によって "*サムプリント*" が大幅に変わるため、ハッシュ値を使用してメッセージが変更されたかどうかを確認できます。 次の図は、非対称暗号化とハッシュ アルゴリズムを使用して、メッセージが変更されていないことを確認する方法を示しています。

![署名の例](media/tutorial-x509-introduction/signing.png)

1. 送信者がプレーンテキスト メッセージを作成します。

1. 送信者がプレーンテキスト メッセージをハッシュして、メッセージ ダイジェストを作成します。

1. 送信者が秘密キーを使用して、ダイジェストを暗号化します。

1. 送信者がプレーンテキスト メッセージと暗号化されたダイジェストを目的の受信者に送信します。

1. 受信者が送信者の公開キーを使用して、ダイジェストを解読します。

1. 受信者がメッセージに対して使用したのと同じハッシュ アルゴリズムを実行します。

1. 受信者が結果として得られた署名と解読した署名を比較します。 ダイジェストが同じ場合、メッセージは転送中に変更されていません。

## <a name="next-steps"></a>次のステップ

証明書を構成するフィールドの詳細については、「[X.509 公開キー証明書について理解する](tutorial-x509-certificates.md)」を参照してください。

既に X.509 証明書について多くのことを知っていて、お使いの IoT ハブに対する認証に使用できるテスト バージョンを生成する必要がある場合は、次のトピックを参照してください。

* [Microsoft 提供のスクリプトを使用してテスト証明書を作成する](tutorial-x509-scripts.md)
* [OpenSSL を使用してテスト証明書を作成する](tutorial-x509-openssl.md)
* [OpenSSL を使用して自己署名のテスト証明書を作成する](tutorial-x509-self-sign.md)

証明機関 (CA) の証明書または下位 CA の証明書があり、それをお使いの IoT ハブにアップロードすると共に自分がその所有者であることを証明する必要がある場合には、「[CA 証明書の所有を証明する](tutorial-x509-prove-possession.md)」を参照してください。
