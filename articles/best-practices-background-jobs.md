<properties
   pageTitle="バックグラウンド ジョブのガイダンス | Microsoft Azure"
   description="ユーザー インターフェイスとは無関係に実行されるバックグラウンド タスクに関するガイダンスです。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="12/18/2015"
   ms.author="masashin"/>

# バックグラウンド ジョブのガイダンス

![](media/best-practices-background-jobs/pnp-logo.png)


## 概要

ユーザー インターフェイス (UI) とは無関係に実行されるバックグラウンド タスクは、さまざまな種類のアプリケーションで重要な役割を果たしています。その例として、バッチ ジョブ、多くの処理能力を消費するタスク、長時間実行されるプロセス (ワークフローなど) を挙げることができます。バックグラウンド ジョブの実行は、ユーザーの介入を必要としません。アプリケーションでジョブを起動した後も、ユーザーから対話式に送られる要求を処理し続けることができます。アプリケーションの UI に対する負荷が小さくなるので、稼働率が向上し、対話の応答時間が短縮されます。

たとえば、ユーザーからアップロードされた画像のサムネイルをアプリケーションで生成する場合、その処理をバックグラウンド ジョブとして実行し、完成したサムネイルを記憶域に保存することができます。処理が完了するまでユーザーを待たせる必要はありません。同様に、何かを購入する状況においても、注文を処理するワークフローをバックグラウンドで開始すれば、その間もユーザーは UI を使って Web アプリを閲覧することができます。バックグラウンド ジョブが完了した時点で、保存された注文データを更新し、注文内容を確認するメールをユーザーに送信することが可能です。

特定のタスクをバックグラウンド ジョブとして実装するかどうかの主要な判断基準は、そのタスクが、ユーザーの介入なしで実行できるかどうかと、ジョブの完了まで UI を待機状態にする必要があるかどうかです。完了までユーザーまたは UI を待機させる必要のあるタスクは、バックグラウンド ジョブに適していない可能性があります。

## バックグラウンド ジョブの種類

通常バックグラウンド ジョブには次の特徴があります。

- CPU に負荷のかかるジョブ (数学的計算、構造モデル分析など)。
- 入出力の多いジョブ (一連のストレージ トランザクションの実行、ファイルのインデックス作成など)。
- バッチ ジョブ (夜間のデータ更新、スケジュール設定された処理など)。
- 長時間実行されるワークフロー (受注処理、サービスやシステムのプロビジョニングなど)。
- 機密データ処理 (より安全な場所にタスクが引き渡されて処理される)。たとえば、機密データは、Web アプリ内で処理するより、[Gatekeeper](http://msdn.microsoft.com/library/dn589793.aspx) などのパターンに従い、保護された記憶域にアクセスできる分離されたバックグラウンド プロセスにデータを転送した方が賢明です。

## トリガー

バックグラウンド ジョブは、さまざまな方法で開始することができます。実質的には、大きく次の 2 つのカテゴリに分けられます。

- [**イベント ドリブン トリガー**](#event-driven-triggers)。イベント (通常、ユーザーが実行する操作またはワークフロー内のステップ) に反応する形でタスクが開始されます。
- [**スケジュール ドリブン トリガー**](#schedule-driven-triggers)。タイマーに基づくスケジュールに従ってタスクが呼び出されます。スケジュールに従って定期的に呼び出すことも、指定された時刻に 1 回だけ呼び出すこともできます。

### イベント ドリブン トリガー

イベント ドリブン型の呼び出しでは、トリガーを使ってバックグラウンド タスクが開始されます。イベント ドリブン トリガーの例を次に示します。

- UI やその他のジョブによってキューにメッセージが追加されます。メッセージに含まれているのは、実行された操作 (ユーザーによる注文など) に関するデータです。バックグラウンド タスクは、このキューで待機し、新しいメッセージの到着を検出します。そのメッセージが読み取られ、その中のデータが、バックグラウンド ジョブの入力として使用されます。
- UI やその他のジョブによって記憶域に値が保存されるか値が更新されます。バックグラウンド タスクは記憶域を監視し、変更を検出します。そのデータが読み取られ、バックグラウンド ジョブの入力として使用されます。
- UI やその他のジョブからエンドポイント (Web サービスとして公開されている API、HTTPS URI など) に要求が送られます。その際バックグラウンド タスクを実行するために必要なデータは要求の一部として渡されます。エンドポイントまたは Web サービスがバックグラウンド タスクを呼び出すときに、そのデータが入力として使用されます。

イベント ドリブンの呼び出しに適したタスクの例としては、画像処理、ワークフロー、リモート サービスへの情報送信、電子メール メッセージの送信、マルチテナント アプリケーションへの新しいユーザーのプロビジョニングが代表的です。

### スケジュール ドリブン トリガー

スケジュール ドリブン型の呼び出しでは、タイマーを使ってバックグラウンド タスクが開始されます。スケジュール ドリブン トリガーの例を次に示します。

- 同じアプリケーション内でローカルに実行されているタイマーまたはその動作環境であるオペレーティング システムの機能として実行されているタイマーによってバックグラウンド タスクが定期的に呼び出されます。
- 別のアプリケーションで実行されているタイマーまたは Azure Scheduler などのタイマー サービスから API や Web サービスに対して定期的に要求が送られます。その API または Web サービスによってバックグラウンド タスクが呼び出されます。
- 別のプロセスまたはアプリケーションによってタイマーが起動され、指定された時間の経過後または特定の時刻にバックグラウンド タスクが呼び出されます。

スケジュール ドリブンで呼び出すことが適しているタスクの例としては、バッチ処理ルーチン (ユーザーの直近の行動に基づいて、表示する関連製品一覧を更新するなど)、ルーチン データ処理タスク (インデックスの更新、蓄積された結果の生成など)、日次レポート用のデータ分析、保管データのクリーンアップ、データ一貫性チェックが代表的です。

スケジュール ドリブンのタスクを単一のインスタンスとして実行する必要がある場合は、次の点に注意してください。

- スケジューラを実行するコンピューティング インスタンス (Windows のスケジュール タスクを使用する仮想マシンなど) がスケーリングされた場合、そのスケジューラのインスタンスが複数実行され、タスクのインスタンスも複数起動される可能性があります。
- タスクの実行時間がスケジューラのイベントの発生間隔を超えた場合、先に起動されたインスタンスが終わる前に、スケジューラによってタスクのインスタンスがもう 1 つ起動されます。

## 結果の出力

バックグラウンド ジョブは、その呼び出し元となった UI やプロセスとは独立したプロセスで (または場合によっては別の場所で) 非同期的に実行されます。バックグラウンド タスクは、開始後放置できること、またその実行中に UI や呼び出し元のプロセスに影響を与えないことが理想です。呼び出し元のプロセスはタスクの完了を待機せず、いつタスクが完了するかを自動的には検出できません。バックグラウンド タスクが呼び出し元のタスクと情報をやり取りし、進行状況や完了を伝えることができるようにするには、そのための機構を実装する必要があります。次に例をいくつか示します。

- UI や呼び出し元のタスクからアクセスできる記憶域にステータス インジケーターの値を書き込み、呼び出し元が必要に応じてその値を監視、確認できるようにする。その他、バックグラウンド タスクから呼び出し元に返す必要のあるデータも同じ記憶域に格納することができます。
- 応答キューを設定し、そこで UI または呼び出し元を待機させる。バックグラウンド タスクは、このキューにメッセージを送ることでステータスや完了を知らせることができます。バックグラウンド タスクから呼び出し元に返す必要のあるデータもそのメッセージに格納することができます。Azure Service Bus を使っている場合、**ReplyTo** プロパティと **CorrelationId** プロパティを使ってこの機能を実装できます。詳細については、[Service Bus ブローカー メッセージングにおける相関](http://www.cloudcasts.net/devguide/Default.aspx?id=13029)に関するページを参照してください。
- UI や呼び出し元がステータス情報を取得する目的でアクセスできる API またはエンドポイントをバックグラウンド タスク側で公開する。その応答に、バックグラウンド タスクから呼び出し元に返す必要のあるデータを格納することができます。
- バックグラウンド タスクから API を介して UI や呼び出し元をコールバックし、定義済みのポイントや完了時点でステータスを通知する。コールバックのタイミングとしては、ローカルで発生するイベントや、パブリッシュとサブスクライブのメカニズムを利用することができます。バックグラウンド タスクから呼び出し元に返す必要のあるデータは、要求またはイベントのペイロードに格納することができます。

## ホスティング環境

バックグラウンド タスクは、Azure の各種プラットフォーム サービスを使ってホストすることができます。

- [**Azure Web アプリと Web ジョブ**](#azure-web-apps-and-webjobs)。Web ジョブを使うと、各種のスクリプトや実行可能プログラムをカスタム ジョブとして Web アプリのコンテキスト内で実行することができます。
- [**Azure Cloud Services の Web ロールと worker ロール**](#azure-cloud-services-web-and-worker-roles)。バックグラウンド タスクとして動作するロールにコードを記述することができます。
- [**Azure Virtual Machines**](#azure-virtual-machines)。Windows サービスがある場合または Windows タスク スケジューラを使用する場合、バックグラウンド タスクを専用の仮想マシンにホストするのが一般的です。

以降のセクションでそれぞれの方法について詳しく説明すると共に、適切な方法を選ぶうえでの注意事項を取り上げます。

### Azure Web アプリと Web ジョブ

Azure Web ジョブを使うと、Azure Web アプリ内でカスタム ジョブをバックグラウンド タスクとして実行できます。Web ジョブは、Web アプリのコンテキスト内で継続するプロセスとして実行されます。または、Azure Scheduler や外的要因 (ストレージ BLOB やメッセージ キューに対する変更など) からのトリガー イベントに反応する形で実行されます。ジョブは、起動と停止をオンデマンドで行うことができ、正規の手順でシャットダウンすることができます。継続的に実行される Web ジョブは、エラーが発生した場合、自動的に再起動されます。再試行とエラーのアクションは、設定で変更することができます。

Web ジョブを構成する際の注意事項を次に示します。

- イベント ドリブン トリガーを使ってジョブを起動する場合は、**[連続的に実行]** として構成する必要があります。スクリプトまたはプログラムは、"site/wwwroot/app\_data/jobs/continuous" という名前のフォルダーに格納されます。
- スケジュール ドリブン トリガーを使ってジョブを起動する場合は、**[スケジュールに従って実行]** として構成する必要があります。スクリプトまたはプログラムは、"site/wwwroot/app\_data/jobs/triggered" という名前のフォルダーに格納されます。
- ジョブを構成するときに **[オンデマンドで実行]** オプションを選択した場合、**[スケジュールに従って実行]** オプションと同じコードが起動時に実行されます。

Azure Web ジョブは、Web アプリのサンドボックス内で実行されます。つまり、環境変数にアクセスして、接続文字列などの情報を Web アプリとの間で共有することができます。Web ジョブは、それを実行しているコンピューターの一意の識別子にアクセスすることができます。Azure Storage のキューや BLOB、テーブルにアクセスしてアプリケーション データを取得したり、Service Bus にアクセスしてメッセージングや通信を行ったりするには、**AzureWebJobsStorage** という接続文字列を使用します。ジョブのアクション ログ ファイルにアクセスするには、**AzureWebJobsDashboard** という接続文字列を使用します。

Azure の Web ジョブの特徴を次に示します。

- **セキュリティ**: Web ジョブの保護には、Web アプリのデプロイ資格情報が使用されます。
- **サポートされるファイルの種類**: Web ジョブは、コマンド スクリプト (.cmd)、バッチ ファイル (.bat)、PowerShell スクリプト (.ps1)、bash シェル スクリプト (.sh)、PHP スクリプト (.php)、Python スクリプト (.py)、JavaScript コード (.js)、実行可能プログラム (.exe、.jar など) を使って定義することができます。
- **デプロイ**: スクリプトと実行可能ファイルは、Azure ポータルを使ってデプロイできます。作成からデプロイまでを Visual Studio の [WebJobsVs](https://visualstudiogallery.msdn.microsoft.com/f4824551-2660-4afa-aba1-1fcc1673c3d0) アドイン、[Visual Studio 2013 Update 4](http://www.visualstudio.com/news/vs2013-update4-rc-vs)、[Azure WebJobs SDK](websites-dotnet-webjobs-sdk-get-started.md) を使って行うこともできます。さらに、それらを次の場所に直接コピーしてデプロイすることもできます。
  - トリガーによって実行する場合: site/wwwroot/app\_data/jobs/triggered/{job name}
  - 連続実行の場合: site/wwwroot/app\_data/jobs/continuous/{job name}
- **ログ**: Console.Out は INFO として、Console.Error は ERROR として処理 (マーク) されます。監視情報と診断情報には、Azure ポータルからアクセスできます。ログ ファイルは、サイトから直接ダウンロードすることができます。これらの情報は次の場所に保存されます。
  - トリガーによって実行する場合: Vfs/data/jobs/continuous/jobName
  - 連続実行の場合: Vfs/data/jobs/triggered/jobName
- **構成**: Web ジョブの構成には、ポータル、REST API、PowerShell を使用できます。ジョブの構成情報は、ジョブ スクリプトと同じルート ディレクトリにある settings.job という名前の構成ファイルで指定できます。次に例を示します。
  - { "stopping\_wait\_time": 60 }
  - { "is\_singleton": true }

### 考慮事項

- 既定では、Web アプリをスケーリングすると Web ジョブもスケーリングされます。ただし、**is\_singleton** 構成プロパティを true に設定すれば、単一インスタンスで実行されるようにジョブを構成することが可能です。単一インスタンスの Web ジョブは、スケーリングが不要なタスク (インデックスの再構築、データ分析など、同時に複数のインスタンスで実行することが望ましくないタスク) に適しています。
- 長時間実行されるジョブやリソースの消費量が大きいジョブは、Web アプリのパフォーマンスへの影響を最小限に抑えるために、新しい App Service プランで空の Azure Web App インスタンスを作成し、そこでホストすることを検討してください。

### 詳細情報

- [Azure WebJobs 推奨リソース](websites-webjobs-resources.md)に関するページをご覧ください。Web ジョブに関する有益なリソースやダウンロード、サンプルが多数紹介されています。

## Azure Cloud Services の Web ロールと worker ロール

バックグラウンド タスクは、Web ロール内で実行することも、独立した worker ロールで実行することもできます。worker ロールを用いるかどうかは、スケーラビリティと弾力性の要件、タスクの有効期間、リリースの頻度、セキュリティ、フォールト トレランス、リソースの奪い合い、複雑性、論理アーキテクチャなどを考慮して判断します。詳細については、[Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)に関するページを参照してください。

Cloud Services ロールには、さまざまな方法でバックグラウンド タスクを実装することができます。

- Cloud Services ロールに **RoleEntryPoint** クラスの実装を作成し、そのメソッドを使ってバックグラウンド タスクを実行する。この場合タスクは WaIISHost.exe のコンテキストで動作し、**CloudConfigurationManager** クラスの **GetSetting** メソッドを使って構成設定を読み込むことができます。詳細については、「[ライフサイクル (Cloud Services)](#lifecycle-cloud-services)」を参照してください。
- アプリケーションの起動時にスタートアップ タスクを使ってバックグラウンド タスクを実行する。バックグラウンドでタスクを強制的に実行し続けるには、**taskType** プロパティを **background** に設定します (この設定をしなかった場合、アプリケーションの起動プロセスが中断状態でタスクの完了を待機します)。詳細については、[Azure におけるスタートアップ タスクの実行](cloud-services-startup-tasks.md)に関するページを参照してください。
- WebJobs SDK を使い、スタートアップ タスクとして開始される WebJobs としてバックグラウンド タスクを実装する。詳細については、[Get Started with the Azure WebJobs SDK (Azure Web ジョブ SDK の概要)](websites-dotnet-webjobs-sdk-get-started.md) を参照してください。
- バックグラウンド タスクを実行する Windows サービスを、スタートアップ タスクを使ってインストールする。サービスをバックグラウンドで実行するには、**taskType** プロパティを **background** に設定する必要があります。詳細については、[Azure におけるスタートアップ タスクの実行](cloud-services-startup-tasks.md)に関するページを参照してください。

### Web ロールでのバックグラウンド タスクの実行

バックグラウンド タスクを Web ロールで実行する利点はなんといっても、別途ロールを追加デプロイする必要がないため、ホスティングにかかるコストが低いことです。

### worker ロールでのバックグラウンド タスクの実行

以下、バックグラウンド タスクを worker ロールで実行する利点をいくつか挙げます。

- ロールの種類ごとに切り離してスケーリングを管理できる。たとえば現状の負荷に対応するために Web ロールのインスタンス数を増やす必要がある一方で、バックグラウンド タスクを実行する worker ロールのインスタンス数はもっと少なくできるという状況が考えられます。バックグラウンド タスクのコンピューティング インスタンスを UI のロールとは独立にスケーリングすることで、十分なパフォーマンスを維持しながら、ホスティングのコストを削減することができます。
- バックグラウンド タスクの処理オーバーヘッドを Web ロールから取り除くことができる。UI として機能する Web ロールの応答性を保つことができるため、ユーザーからの特定の量の要求を処理するために必要なインスタンス数が相対的に少なくて済みます。
- 処理内容の独立性を高めることができる。ロールの種類ごとに明確な特徴を持った関連するタスクを集めて実装することができます。他のロールのコードや機能への依存度が下がるため、コードの設計と管理がしやすくなります。
- 機密を要するプロセスやデータが分離しやすくなる。たとえば、UI の機能を実装する Web ロールが、worker ロールの管理下にあるデータにアクセスできる必要はありません。たとえば、[Gatekeeper パターン](http://msdn.microsoft.com/library/dn589793.aspx)を使って両者を分離することで、セキュリティを強化することができます。  

### 考慮事項

Cloud Services の Web ロールと worker ロールを使っているときに、バックグラウンド タスクをどこにどのようにデプロイするかは、次の点を考慮して判断してください。

- バックグラウンド タスクを既存の Web ロールでホスティングすると、そのタスク専用に独立した worker ロールを運用するコストを節約することができます。一方、処理や他のリソースを奪い合う状況が生じると、アプリケーションのパフォーマンスと稼働率に影響する可能性が高くなります。独立した worker ロールを使うと、バックグラウンド タスクの実行時間が長時間に及んだり、リソースが大量に消費されたりする影響から Web ロールを守ることができます。
- **RoleEntryPoint** クラスを使ってバックグラウンド タスクをホストすると、そのクラスを簡単に別のロールに移すことができます。たとえば、このクラスを最初 Web ロールに作成したものの、後日、worker ロールでタスクを実行することにした場合、**RoleEntryPoint** クラスの実装を worker ロールに移すことができます。
- スタートアップ タスクはプログラムまたはスクリプトを実行するように設計されています。バックグラウンド ジョブを実行可能プログラムとしてデプロイするのは、特に依存アセンブリのデプロイを伴う場合、スクリプトとしてデプロイするよりも難易度が高くなります。スタートアップ タスクを使うときは、スクリプトをデプロイして使用した方が簡単にバックグラウンド ジョブを定義できます。
- バックグラウンド タスクの障害を引き起こす例外の影響は、バックグラウンド タスクのホスティング形態によって異なります。
  - **RoleEntryPoint** クラスを使った方法を用いている場合、タスクの障害が発生すると、タスクを自動的に再起動するためにロールが再起動されます。このことでアプリケーションの稼働率に影響が生じる可能性があります。これを防ぐためには、**RoleEntryPoint** クラスとすべてのバックグラウンド タスクに堅牢な例外処理を設ける必要があります。障害の発生したタスクを (再起動することが妥当であれば) 再起動するようにコーディングし、そのコード内の正規の手順で障害から復旧できない場合にのみ、例外をスローしてロールを再起動するようにしてください。
  - スタートアップ タスクを使った場合、タスクの実行管理と障害が発生しているかどうかのチェックを自分で行う必要があります。
- スタートアップ タスクの管理と監視は、**RoleEntryPoint** クラスを使ったアプローチと比べて難しくなります。ただし、Azure WebJobs SDK に用意されているダッシュボードを使うと、スタートアップ タスクを用いて開始された Web ジョブを簡単に管理することができます。

### 詳細情報

- [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)
- [Azure Web ジョブ SDK の使用](websites-dotnet-webjobs-sdk-get-started.md)

## Azure Virtual Machines

バックグラウンド タスクの実装形態によっては、Azure Web Apps や Cloud Services にデプロイできなかったり、便利ではなかったりすることもあります。Windows のサービスや、サード パーティのユーティリティ、サード パーティの実行可能プログラムがその代表的な例です。また、アプリケーションのホスティング環境とは異なる実行環境向けに作成されたプログラムも同様です。たとえば、Unix や Linux のプログラムを Windows アプリケーションまたは .NET アプリケーションから実行するケースなどが該当します。Azure Virtual Machines には、さまざまなオペレーティング システムが用意されているので、そこから目的のオペレーティング システムを選んで、仮想マシン上で必要なサービスまたは実行可能ファイルを運用することができます。

どのようなときに Virtual Machines を使うかについては、[Azure App Services、Cloud Services、Virtual Machines の比較](choose-web-site-cloud-service-vm.md)に関するページを参照してください。Virtual Machines の選択肢については、[Azure の仮想マシンとクラウド サービスのサイズ](http://msdn.microsoft.com/library/azure/dn197896.aspx)に関するページを参照してください。Virtual Machines で利用できるオペレーティング システムと既製イメージの詳細については、[Azure の仮想マシン ギャラリー](https://azure.microsoft.com/gallery/virtual-machines/)を参照してください。

バックグラウンド タスクを別の仮想マシンで開始するには、いくつかの方法があります。

- タスクの公開エンドポイントに要求を送り、タスクに必要なデータを渡すことによってアプリケーションからオンデマンドで直接タスクを実行する。タスクは、このエンドポイントによって呼び出されます。
- 選択したオペレーティング システムに用意されているスケジューラやタイマーを使い、スケジュールに基づいて動作するようにタスクを構成する。たとえば Windows では、Windows タスク スケジューラを使ってスクリプトやタスクを実行できるほか、仮想マシンに SQL Server がインストールされていれば、SQL Server エージェントを使ってスクリプトやタスクを実行することができます。
- Azure Scheduler を使用し、タスクが待機しているキューにメッセージを追加するか、タスクが公開している API に要求を送ることによってタスクを開始する。

バックグラウンド タスクを開始する方法の詳細については、冒頭のセクション「[トリガー](#triggers)」を参照してください。

### 考慮事項

Azure 仮想マシンにバックグラウンド タスクをデプロイするかどうかは、次の点を考慮して判断してください。

- 独立した Azure 仮想マシンでバックグラウンド タスクをホスティングすれば、運用の幅が広がり、開始と実行、スケジューリング、リソース割り当てを細かく制御することができます。ただし、バックグラウンド タスクを実行するためだけに仮想マシンをデプロイしなければならない場合、ランタイム コストが大きくなります。
- [Azure サービス管理コマンドレット](http://msdn.microsoft.com/library/azure/dn495240.aspx)を使って仮想マシンを管理したり、仮想マシンの基本的なステータスを監視したりすることはできますが、バックグラウンド タスクを監視する機構は Azure ポータルにはなく、また、障害の発生したタスクを自動的に再起動する機能もありません。コンピューティング ノード内のプロセスやスレッドを制御する機構も存在しません。通常、仮想マシンを使うためには、タスクのインストルメンテーションや仮想マシン内のオペレーティング システムからデータを収集するメカニズムを別途導入する必要があります。1 つの方法として、[Azure 用の System Center 管理パック](http://technet.microsoft.com/library/gg276383.aspx)を使うことが解決策として考えられます。
- HTTP エンドポイントを介して公開される監視プローブの作成を検討してください。正常性チェックの実行、運用情報や統計情報の収集、エラー情報の照合を監視プローブのコードから実行して管理アプリケーションに返すようにします。詳細については、[Health Endpoint Monitoring パターン](http://msdn.microsoft.com/library/dn589789.aspx)に関するページを参照してください。

### 詳細情報

- Azure の [Virtual Machines](https://azure.microsoft.com/services/virtual-machines/)
- [Azure Virtual Machines に関する FAQ](virtual-machines/virtual-machines-linux-classic-faq.md)

## 設計上の考慮事項

バックグラウンド タスクを設計する際は、基本的な考慮事項がいくつかあります。以降のセクションで、パーティション分割、競合、調整について説明します。

## パーティション分割

バックグラウンド タスクを既存のコンピューティング インスタンス (Web アプリ、Web ロール、既存の worker ロール、仮想マシンなど) でホストすることにした場合、そのコンピューティング インスタンスとバックグラウンド タスクそのもののパフォーマンス特性に波及する影響を考慮に入れる必要があります。以下、既存のコンピューティング インスタンスを間借りする形でタスクを配置するか、独立したコンピューティング インスタンスを専用に用意して配置するかを決めるうえでの判断材料としてください。

- **稼働率**: バックグラウンド タスクに、アプリケーションの他の領域 (特に、ユーザーとの対話を直接つかさどる UI などの領域) と同じレベルの稼働率は必要ありません。バックグラウンド タスクは、処理をキューに追加することができるため、遅延や接続失敗時の再試行など、稼働率を左右する要因は、ある程度許容することができます。ただし、要求が溢れてしまうとキューがブロックされてアプリケーション全体に影響が生じるので、ある程度の処理能力は必要です。
- **スケーラビリティ**: 通常、バックグラウンド タスクは、アプリケーションの UI など対話的な操作をつかさどる領域とは、スケーラビリティの要件が異なります。UI のスケーリングは需要のピークに対応できるように行う必要があるのに対し、未処理のバックグラウンド タスクは混雑時を避け、より少ないコンピューティング インスタンス数で実行することができます。
- **回復性**: バックグラウンド タスクだけをホストするコンピューティング インスタンスは、障害が発生しても、それらのタスクの要求をキューに追加 (つまりタスクが回復するまで延期) すれば、アプリケーション全体に致命的な影響は生じません。適切な時間内にコンピューティング インスタンスまたはタスクが再起動されれば、アプリケーションのユーザーが影響を被ることはありません。
- **セキュリティ**: バックグラウンド タスクは、アプリケーションの UI などとは、セキュリティ上の要件や制限が異なります。独立したコンピューティング インスタンスを使うことによって、そのタスクに異なるセキュリティ環境を適用することができます。また、セキュリティと独立性を高めるために、Gatekeeper などのパターンを使って、バックグラウンド コンピューティング インスタンスと UI とを分離させることもできます。
- **パフォーマンス**: バックグラウンド タスクに用いるコンピューティング インスタンスのタイプは、具体的なタスクのパフォーマンス要件に合わせて選ぶことができます。タスクに求められる処理能力が UI ほど高くない場合は、より安価なコンピューティング オプションを選ぶことができます。逆に、UI よりも高い処理能力と多くのリソースが必要である場合は、コンピューティング インスタンスを増設することができます。
- **管理性**: バックグラウンド タスクは、開発とデプロイの頻度が、アプリケーションのメイン コードや UI とは異なる場合があります。独立したコンピューティング インスタンスにデプロイすることで、更新とバージョン管理を単純化することができます。
- **コスト**: バックグラウンド タスクを実行するためのコンピューティング インスタンスを追加した場合、ホスティングにかかるコストが増えます。処理能力の向上とコストの増大のトレードオフを慎重に検討する必要があります。

詳細については、[Leader Election パターン](http://msdn.microsoft.com/library/dn568104.aspx)と [Competing Consumers パターン](http://msdn.microsoft.com/library/dn568101.aspx)に関するページを参照してください。

## 競合

バックグラウンド ジョブのインスタンスが複数存在する場合、データベースや記憶域などのリソースやサービスを奪い合う状況が生じる可能性があります。このとき同時アクセスによってリソースの競合が生じ、サービスの稼働状態や記憶域におけるデータの整合性に矛盾が生じる場合があります。リソースの競合は、排他的ロックを使って解決できます。排他的ロックは、リソースを奪い合っている複数のタスクのインスタンスが同時にサービスにアクセスできないように (データを破損させないように) する手法です。

競合を解決するもう 1 つのアプローチとして、バックグラウンド タスクをシングルトンとして定義し、インスタンスを 1 つしか実行できないようにする方法もあります。しかし、この方法では、複数インスタンス構成の利点である信頼性とパフォーマンスが活かされません。特に、複数のバックグラウンド タスクを常時塞いでしまうほどに UI の処理能力が高い場合はなおさらです。バックグラウンド タスクを自動的に再起動できるようにし、さらに需要のピークに対処できるだけの処理能力を与えることが必須となります。たとえば、十分なリソースを備えたコンピューティング インスタンスを割り当てるか、要求をいったんキューに格納しておき後で需要が落ち着いたときに処理するメカニズムを実装するか、その両方の手段を組み合わせることが考えられます。

## 調整

バックグラウンド タスクは、複合的な成り立ちを有している場合があり、1 つの結果を得たり、すべての要件を満たしたりするためには、ばらばらに存在するいくつものタスクが必要になることがあります。そのような場合の常套手段は、より小さなステップ (サブタスク) にタスクを分割し、複数のコンシューマーによって実行できるようにすることです。複数のステップでジョブが構成されていれば、個々のステップを他のジョブで再利用できるため、効率がよく柔軟性も向上します。ステップの追加と削除、順序変更も容易に行うことができます。

複数のタスクやステップを調整するのは容易ではありませんが、その解決策として 3 つのパターンがよく知られているので、実装するうえでの参考にしてください。

- **再利用可能な複数のステップにタスクを分解する**。アプリケーションは、その処理の対象となる情報に対し、複雑度の異なる多様なタスクを実行しなければならない場合があります。その処理を一体型のモジュールとして実行するのが、柔軟性は低いものの実装方法としては簡単です。しかしそのアプリケーション内のどこか他の箇所で同じ処理の一部分が必要になったとき、この方法では、コードのリファクタリングや最適化、再利用の可能性が制限されます。詳細については、[Pipes and Filters パターン](http://msdn.microsoft.com/library/dn568100.aspx)に関するページを参照してください。
- **タスクのステップの実行を管理する**。アプリケーションで実行するタスクが、多数のステップから成り立っていて、その中でリモート サービスを呼び出したり、リモート リソースにアクセスしたりする場合があります。それぞれのステップは互いに独立しているかもしれませんが、それらを指揮するのは、タスクを実装するアプリケーションのロジックです。詳細については、[Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)に関するページを参照してください。
- **タスクのステップの障害復旧を管理する**。一連のステップによって実行される作業は、最終的にそれらが集まって整合の取れた操作となるものであり、そのいずれかのステップで障害が発生した場合は、アプリケーション側で元に戻す必要があります。詳細については、[Compensating Transaction パターン](http://msdn.microsoft.com/library/dn589804.aspx)に関するページを参照してください。

## ライフサイクル (Cloud Services)

 Web ロールと worker ロールを使用する Cloud Services アプリケーションで、**RoleEntryPoint** クラスを使ってバックグラウンド ジョブを実装する場合、このクラスのライフサイクルを理解しておくことが正しく使用するうえで大切です。

Web ロールと worker ロールが開始、実行、停止される過程には、明確に区別されたいくつかの段階が存在します。これらの各段階に到達したタイミングを通知する一連のイベントが、**RoleEntryPoint** クラスに定義されています。それらのイベントを利用して、カスタム バックグラウンド タスクの初期化、実行、停止を行うことができます。その全体のサイクルは次のとおりです。

- Azure がロールのアセンブリを読み込み、**RoleEntryPoint** から派生したクラスを探します。
- このクラスが見つかった場合、**RoleEntryPoint.OnStart()** を呼び出します。このメソッドをオーバーライドしてバックグラウンド タスクを初期化できます。
- **OnStart** メソッドの完了後、Azure は、アプリケーションの Global ファイル (ASP.NET を実行している Web ロールの Global.asax など) が存在する場合、そのファイル内の **Application\_Start()** を呼び出します。
- Azure が、**OnStart()** と並列に実行される新しいフォアグラウンド スレッドで **RoleEntryPoint.Run()** を呼び出します。このメソッドをオーバーライドしてバックグラウンド タスクを開始できます。
- Run メソッドが終了すると、Azure はまずアプリケーションの Global ファイル (存在する場合) 内の **Application\_End()** を呼び出し、その後、**RoleEntryPoint.OnStop()** を呼び出します。バックグラウンド タスクの停止、リソースのクリーンアップ、オブジェクトの破棄、タスクで使われていた接続の終了処理は、この **OnStop** メソッドをオーバーライドして行います。
- Azure worker ロールのホスト プロセスが停止します。この時点で、ロールがリサイクルされて再起動します。

**RoleEntryPoint** クラスのメソッドの詳細と使用例については、[Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)に関するページを参照してください。

## 考慮事項

バックグラウンド タスクを Web ロールで実行するか worker ロールで実行するかは、次の点を考慮して判断してください。

- **RoleEntryPoint** クラスの **Run** メソッドの既定の実装には、ロールを無期限に起動状態にする **Thread.Sleep(Timeout.Infinite)** の呼び出しが含まれています。この **Run** メソッドをオーバーライドする場合 (通常、バックグラウンド タスクを実行するためにはオーバーライドが必要)、ロール インスタンスをリサイクルするとき以外は、このメソッドを終了してはいけません。
- 通常、**Run** メソッドの実装は、個々のバックグラウンド タスクを開始するコードと、すべてのバックグラウンド タスクの状態を定期的にチェックするループ構文を含んでいます。障害の発生したタスクを再起動したり、ジョブが完了したことを示すキャンセル トークンを監視したりすることが可能です。
- ハンドルされない例外が特定のバックグラウンド タスクでスローされた場合、ロール内の他のバックグラウンド タスクについては実行を継続し、例外のスローされたタスクだけをリサイクルします。ただしその例外が、タスクの外部にあるオブジェクト (共有記憶域など) の破損に起因する場合、**RoleEntryPoint** クラスに実装するコードの中でその例外を処理し、すべてのタスクをキャンセルしたうえで、**Run** メソッドを終了できる状態にします。その後 Azure によってロールが再起動されます。
- バックグラウンド タスクを一時停止または強制終了し、リソースをクリーンアップするには、**OnStop** メソッドを使います。必然的に、長時間実行されるタスクや複数のステップから成るタスクを停止しなければならない場合があります。データに不整合を来さない方法でいかにそれを実行するかは重要な考慮事項です。ユーザーによって引き起こされたシャットダウンを除く何らかの理由でロール インスタンスが停止した場合、**OnStop** メソッドで実行されているコードは 5 分以内に完了しなければなりません。5 分が経過すると強制終了されます。その時間内に完了するようにコードを作成するか、最後まで実行されなくても支障がないようにコードを設計してください。  
- Azure ロード バランサーは、**RoleEntryPoint.OnStart** メソッドから true が返されると、ロール インスタンスにトラフィックを誘導し始めます。そのため、正常に初期化されなかったロール インスタンスにトラフィックが振り分けられることのないよう、必要な初期化コードはすべて **OnStart** メソッドに記述することをお勧めします。
- **RoleEntryPoint** クラスのメソッドに加えてスタートアップ タスクを使うことができます。Azure ロード バランサーの設定を初期化して変更する必要がある場合は、スタートアップ タスクを使う必要があります。スタートアップ タスクは、ロールが要求を受け取る前に実行されます。詳細については、[Azure におけるスタートアップ タスクの実行](cloud-services-startup-tasks.md)に関するページを参照してください。
- スタートアップ タスクにエラーが存在すると、ロールの再起動が強制的に繰り返されることがあります。この場合、それまでのステージング環境への VIP スワップを実行できなくなる可能性があります。VIP スワップを実行するためには、ロールへの排他アクセスが必要ですが、ロールの再起動中は排他アクセスを取得できないためです。それを解決するには、次のようにします。
	-  ロールの **OnStart** メソッドと **Run** メソッドの先頭に次のコードを追加します。

	```C#
	var freeze = CloudConfigurationManager.GetSetting("Freeze");
	if (freeze != null)
	{
		if (Boolean.Parse(freeze))
	  	{
		    Thread.Sleep(System.Threading.Timeout.Infinite);
		}
	}
	```

   - 使用するロールの ServiceDefinition.csdef ファイルと ServiceConfiguration.*.cscfg ファイルに **Freeze** 設定の定義を Boolean 値として追加し、**false** に設定します。ロールが再起動を繰り返す状態になった場合は、この設定を **true** に変更してロールの実行を凍結 (Freeze) させれば、それまでの環境とスワップできる状態になります。

## 回復性に関する考慮事項

バックグラウンド タスクが Reliable Services をアプリケーションに提供するためには、その回復力が重要となります。バックグラウンド タスクを計画、設計する際は、次の点を考慮してください。

- バックグラウンド タスクは、ロールやサービスの再起動を正規の手順で処理できることが必要です。データが破損したり、アプリケーションに不整合をもたらしたりすることは許されません。長時間実行されるタスクや複数のステップから成るタスクでは、_チェック ポイント_の使用を検討してください。ジョブの状態を永続的ストレージに保存するか、または (妥当である場合) メッセージとしてキューに保存します。たとえば、状態情報をメッセージとしてキューに永続化し、タスクの進行状況に合わせてその状態情報を漸増的に更新します。そうすれば、良好な状態であることが確認できている最新のチェックポイントからタスクを処理することができ、最初からやり直す必要はありません。Azure Service Bus キューを使っている場合は、メッセージ セッションを使って同じシナリオを実現できます。[SetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.setstate.aspx) メソッドと [GetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.getstate.aspx) メソッドを使って、アプリケーションの処理状態を保存したり取得したりすることが可能です。信頼性のあるマルチ ステップのプロセスとワークフローを設計する方法の詳細については、[Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)に関するページを参照してください。
- Web ロールまたは worker ロールを使って複数のバックグラウンド タスクをホストするときは、失敗したタスクや停止したタスクがないか監視し、それらを再起動するように **Run** メソッドのオーバーライドを設計してください。それが難しい状況で worker ロールを使っている場合は、**Run** メソッドを終了することによって強制的に worker ロールを再起動してください。
- バックグラウンド タスクとのやり取りにキューを使っている場合、普段よりも高い負荷がアプリケーションにかかっているときにはキューがバッファーとして働き、タスクに送られた要求を溜めておくことができます。負荷が低くなったときにタスクの処理が UI に追い付くことができます。このことはまた、ロールをリサイクルしても UI がブロックされないことを意味します。詳細については、[Queue-Based Load Leveling パターン](http://msdn.microsoft.com/library/dn589783.aspx)に関するページを参照してください。タスクによって重要度に差がある場合は、[Priority Queue パターン](http://msdn.microsoft.com/library/dn589794.aspx)を用い、重要度の高いタスクが低いタスクよりも先に実行されるようにすることをお勧めします。
- メッセージによって開始されるバックグラウンド タスクまたは逆にメッセージを処理するバックグラウンド タスクは、さまざまな不整合、たとえば不適切な順序で到着するメッセージ、頻繁にエラーが起こるメッセージ (_有害なメッセージ_)、複数回配信されるメッセージに対処できるように設計する必要があります。以下、具体例に沿って説明します。
  - 既存の値に基づいてデータを変更する (たとえば既存の値に加算する) など、特定の順序で処理する必要のあるメッセージが、送信されたときと同じ順序で到着するとは限りません。また、バックグラウンド タスクの各インスタンスにかかる負荷の変動によって、メッセージを処理するインスタンスが変わったり、メッセージの処理の順番が入れ替わったりする可能性もあります。特定の順序で処理する必要のあるメッセージは、バックグラウンド タスクが常に正しい順序で処理できるように、シーケンス番号やキーなど、何らかのインジケーターを含んでいる必要があります。Azure Service Bus を使っている場合、メッセージ セッションを使って配信の順序を保証することができます。ただし通常は、メッセージの順序が問題とならないようにプロセスを設計した方が効率的です。
  - バックグラウンド タスクは通常、キュー内のメッセージを読み出し (このとき、対象のメッセージは、一時的に他のメッセージ コンシューマーからは見えなくなります)、正常に処理した後でそのメッセージを削除します。メッセージの処理中にバックグラウンド タスクで障害が発生した場合、読み出しのタイムアウト期間が経過するとそのメッセージが再びキューに現れ、別のタスク インスタンスによって (または同じインスタンスの次回の処理サイクルで) 処理されることになります。同じメッセージに起因するエラーが繰り返しコンシューマーで発生すると、やがてキューがいっぱいになり、タスクやキュー、最終的にはアプリケーションそのものまでブロックされてしまいます。そのため、有害なメッセージを検出してキューから除去することが不可欠となります。Azure Service Bus を使っている場合、エラーの原因となるメッセージを自動的に、または手動で、対応する配信不能キューに移動することができます。
  - キューは _Least Once_ のメカニズムで配信が保証されますが、同じメッセージが複数回配信される可能性もあります。また、メッセージの処理後、キューから削除される前にバックグラウンド タスクで障害が発生した場合、そのメッセージは再び処理の対象となります。バックグラウンド タスクは、1 と 1 のかけ算のように、同じメッセージを繰り返し処理しても、エラーを招いたり、アプリケーションのデータに不整合を来さないことが必要です。中には、自然にそのような性質を備えている操作もあります (格納された値を特定の新しい値に設定するなど)。ただし、格納されている既存の値に対して値を加算する際、格納されている値が、メッセージ送信時と同じであることをチェックしなかった場合は、不整合の原因となります。Azure Service Bus のキューは、重複するメッセージを自動的に削除するように構成できます。
  - Azure ストレージ キューや Azure Service Bus キューなど、一部のメッセージング システムは、メッセージがキューから読み出された回数を示すデキュー カウント プロパティをサポートしています。反復するメッセージや有害なメッセージの処理には、このプロパティを利用できます。詳細については、[非同期メッセージングの基本](http://msdn.microsoft.com/library/dn589781.aspx)と [Idempotency パターン](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)に関するページを参照してください。

## スケーリングとパフォーマンスの考慮事項

バックグラウンド タスクは、システムに負荷がかかっている状況下で、アプリケーションをブロックしないこと、また操作に遅延が生じることによる不整合を起こさないことが重要です。そのような事態を引き起こさないだけのパフォーマンスをバックグラウンド タスクには確保する必要があります。通常、バックグラウンド タスクをホストするコンピューティング インスタンスをスケーリングすることによってパフォーマンスは向上します。バックグラウンド タスクを計画、設計する際は、スケーラビリティとパフォーマンスに関して次の点を考慮してください。

- Azure は自動スケールをサポートしています。Web Apps、Cloud Services の Web ロールと worker ロール、Virtual Machines にホストされたデプロイに対し、そのときどきの需要と負荷に応じて、または、あらかじめ決められたスケジュールに基づいてスケールアウトし、不要になったら再びスケールインする、といったことが可能です。この機能を利用することで、運用コストを最小限に抑えつつ、アプリケーション全体の性能を適切な水準に保つことができます。
- バックグラウンド タスクに求められるパフォーマンス要件が Cloud Services アプリケーションの他の領域 (たとえば UI や、データ アクセス レイヤーなどのコンポーネント) と異なる場合、バックグラウンド タスクをまとめて別個の worker ロールでホスティングすれば、UI とバックグラウンド タスクのロールを独立にスケーリングしながら負荷に対応することができます。バックグラウンド タスク同士でパフォーマンス要件が大きく異なる場合は、それらを別々の worker ロールに分けて、それぞれのロール タイプを別々にスケーリングすることをお勧めします。ただしその場合、より少数のロールに全タスクをまとめた場合と比べ、運用コストが増える可能性があるので注意が必要です。
- 単純にロールをスケーリングするだけでは、負荷がかかった状況下でのパフォーマンス低下を防ぎきれない場合もあります。処理チェーン全体の一箇所がボトルネックになってしまうことを防ぐためには、ストレージ キューやその他のリソースをスケーリングすることも、場合によっては必要です。それ以外にも、アプリケーションとバックグラウンド タスクで使われているストレージや各種サービスの最大スループットなどの制限も考慮してください。
- バックグラウンド タスクの設計は、スケーリングを想定して行う必要があります。たとえば、バックグラウンド タスクは、キューで待機したり適切なキューにメッセージを送信したりするために、使用中のストレージ キューの数を動的に検出できなければなりません。
- 既定では、Web ジョブは、それが関連付けられている Azure Web Apps インスタンスに合わせてスケーリングされます。ただし、Web ジョブを単一のインスタンスとしてのみ実行する必要がある場合は、**{ "is\_singleton": true }** という JSON データを含んだ Settings.job ファイルを作成してください。これで、関連付けられている Web アプリのインスタンスが複数存在していても、Web ジョブ インスタンスを強制的に 1 つだけ実行させることができます。スケジュール設定されたジョブで、常に単一インスタンスとして実行する必要がある場合などにこの手法を活用できます。

## 関連するパターン

- [非同期メッセージングの基本](http://msdn.microsoft.com/library/dn589781.aspx)
- [自動スケール ガイダンス](http://msdn.microsoft.com/library/dn589774.aspx)
- [Compensating Transaction パターン](http://msdn.microsoft.com/library/dn589804.aspx)
- [Competing Consumers パターン](http://msdn.microsoft.com/library/dn568101.aspx)
- [コンピューティング分割ガイダンス](http://msdn.microsoft.com/library/dn589773.aspx)
- [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)
- [Gatekeeper パターン](http://msdn.microsoft.com/library/dn589793.aspx)
- [Leader Election パターン](http://msdn.microsoft.com/library/dn568104.aspx)
- [Pipes and Filters パターン](http://msdn.microsoft.com/library/dn568100.aspx)
- [Priority Queue パターン](http://msdn.microsoft.com/library/dn589794.aspx)
- [Queue-Based Load Leveling パターン](http://msdn.microsoft.com/library/dn589783.aspx)
- [Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)

## 詳細情報

- [worker ロールを使用した Azure アプリケーションのスケーリング](http://msdn.microsoft.com/library/hh534484.aspx#sec8)
- [バックグラウンド タスクの実行](http://msdn.microsoft.com/library/ff803365.aspx)
- [Azure ロールのスタートアップ ライフサイクル](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (ブログ記事)
- [Azure Cloud Services ロールのライフサイクル](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (ビデオ)
- [Azure Web ジョブ SDK の使用](websites-dotnet-webjobs-sdk-get-started.md)
- [Azure キューと Service Bus キューの比較](service-bus-azure-and-service-bus-queues-compared-contrasted.md)
- [クラウド サービスの診断を有効にする方法](cloud-services-dotnet-diagnostics.md)

<!---HONumber=AcomDC_0323_2016-->