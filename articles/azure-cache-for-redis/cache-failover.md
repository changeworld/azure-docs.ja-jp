---
title: フェールオーバーと修正プログラムの適用- Azure Cache for Redis
description: Azure Cache for Redis のフェールオーバー、修正プログラムの適用、および更新プロセスについて学習します。
author: asasine
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 6ff33bd594181aabc4fd7d55ce33f780a0d06086
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/27/2020
ms.locfileid: "74122194"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Azure Cache for Redis のフェールオーバーと修正プログラムの適用

回復性の高い優れたクライアント アプリケーションを構築するには、Azure Cache for Redis サービスのコンテキストでのフェールオーバーを理解することが重要です。 フェールオーバーは、計画された管理操作の一環であることも、計画外のハードウェアやネットワーク障害で発生することもあります。 一般的にキャッシュ フェールオーバーは、管理サービスが Azure Cache for Redis バイナリに修正プログラムを適用するときに使用します。 この記事では、フェールオーバーの概要と、修正プログラムの適用時にそれがどのように起こるか、また回復性の高いクライアント アプリケーションの構築方法について説明します。

## <a name="what-is-a-failover"></a>フェールオーバーとは

まず、Azure Cache for Redis のフェールオーバーの概要について説明します。

### <a name="a-quick-summary-of-cache-architecture"></a>キャッシュ アーキテクチャの簡単な概要

キャッシュは、個別のプライベート IP アドレスを持つ複数の仮想マシンで構成されます。 ノードとも呼ばれる各仮想マシンは、1 つの仮想 IP で共有のロード バランサーに接続されています。 各ノードは Redis サーバーのプロセスを実行し、ホスト名と Redis ポートを使用してアクセスすることができます。 各ノードは、マスターまたはレプリカ ノードのいずれかと見なされています。 クライアント アプリケーションがキャッシュに接続されると、そのトラフィックはこのロード バランサーを通過し、自動的にマスター ノードにルーティングされます。

Basic キャッシュでは、1 つのノードが常にマスターとなります。 Standard または Premium キャッシュには、マスターとして選択されているノードと、レプリカとして選択されているノードの 2 つのノードがあります。 ノードが複数ある Standard および Premium キャッシュでは、1 つのノードが要求の処理を続けているとき、1 つのノードは利用できない場合があります。 クラスター化されたキャッシュは多くのシャードで構成され、それぞれに個別のマスター ノードとレプリカ ノードがあります。 他のシャードが使用可能な状態であるとき、1 つのシャードがダウンしている場合があります。

> [!NOTE]
> Basic のキャッシュにはノードは複数はなく、可用性に関する SLA は提供されていません。 Basic のキャッシュは、開発およびテストの目的でのみに推奨されます。 マルチノード デプロイには、可用性を高めるために Standard または Premium キャッシュを使用してください。

### <a name="explanation-of-a-failover"></a>フェールオーバーの説明

フェールオーバーは、1 つのレプリカ ノードが自身をマスター ノードに昇格し、古いマスター ノードが既存の接続を切断したときに発生します。 復帰後、そのマスター ノードがロールの変更を認識すると、自身をレプリカに降格させます。 その後、新しいマスターに接続し、データを同期します。 フェールオーバーは、計画されている場合とされなていない場合があります。

*計画されたフェールオーバー*は、Redis への修正プログラムの適用時や OS のアップグレード時などのシステム更新時、およびスケーリングや再起動などの管理操作時に発生します。 ノードには更新が事前通知されているため、ロールを協調的に交換し、ロード バランサーをすばやく変更で更新できます。 計画フェールオーバーは通常 1 秒未満で終了します。

*計画外のフェールオーバー*は、ハードウェア障害、ネットワーク障害、またはその他のマスター ノードに対する予期しない停止が原因で発生します。 レプリカ ノードは自身をマスターに昇格しますが、そのプロセスには時間がかかります。 レプリカ ノードがフェールオーバー プロセスを開始するには、まずそのマスター ノードが使用できないことを検出する必要があります。 また、不要なフェールオーバーがなされないよう、この計画外の障害が一時的なものでもローカルのものでもないことをレプリカ ノードが確認する必要があります。 検出が遅れるということは、計画外のフェールオーバーは通常 10 秒から 15 秒以内に完了することを意味します。

## <a name="how-does-patching-occur"></a>修正プログラムの適用はどのように行われますか?

Azure Cache for Redis サービスでは、お使いのキャッシュを最新のプラットフォーム機能と修正プログラムで定期的に更新します。 このサービスは、キャッシュへの修正プログラムの適用を次の手順で実行します。

1. 管理サービスでは、修正プログラムを適用する 1 つのノードを選択します。
1. 選択したノードがマスター ノードである場合、そのレプリカ ノードは自身を協調的に昇格させます。 この昇格は、計画されたフェールオーバーと見なされます。
1. 選択されたノードは再起動されて新しい変更が取得され、レプリカ ノードとして復帰します。
1. レプリカ ノードがマスター ノードに接続し、データを同期します。
1. データの同期が完了すると、残りのノードに対する修正プログラムの適用プロセスが繰り返されます。

修正プログラムの適用は計画されたフェールオーバーであるため、レプリカ ノードではマスターになるために迅速に自身を昇格させ、要求と新しい接続の処理を開始します。 Basic のキャッシュにはレプリカ ノードはなく、更新が完了するまで使用することはできません。 クラスター化されたキャッシュの各シャードには個別に修正プログラムが適用され、別のシャードへの接続は閉じられません。

> [!IMPORTANT]
> データの損失を防ぐために、ノードには一度に 1 つずつ修正プログラムが適用されます。 Basic キャッシュではデータが失われます。 クラスター化されたキャッシュでは、一度に 1 つのシャードに修正プログラムが適用されます。

同じリソー スグループとリージョン内の複数のキャッシュにも、一度に 1 つずつ修正プログラムが適用されます。  異なるリソース グループまたは異なるリージョンにあるキャッシュには、同時に修正プログラムが適用できる場合があります。

データの完全な同期はプロセスが繰り返される前に行われるため、Standard または Premium キャッシュを使用している場合にデータが失われる可能性は低いです。 データを[エクスポート](cache-how-to-import-export-data.md#export)して、[永続化](cache-how-to-premium-persistence.md)を有効にすると、データの損失をさらに防御できます。

## <a name="additional-cache-load"></a>追加のキャッシュの負荷

フェールオーバーが発生するたびに、Standard および Premium キャッシュでは、ノード間でデータをレプリケートする必要があります。 このレプリケーションによって、サーバーのメモリと CPU の両方で負荷が増加します。 キャッシュ インスタンスに既に大きな負荷がかかっている場合は、クライアント アプリケーションの待機時間が長くなることがあります。 極端な場合、クライアント アプリケーションがタイムアウト例外を受け取ることがあります。 このさらなる負荷の影響を軽減するには、キャッシュの `maxmemory-reserved` 設定を[構成](cache-configure.md#memory-policies)します。

## <a name="how-does-a-failover-affect-my-client-application"></a>フェールオーバーはクライアント アプリケーションにどのような影響を与えますか?

クライアント アプリケーションで見られるエラーの数は、フェールオーバー時にその接続で保留されていた操作の数によって異なります。 切断されたノード経由でルーティングされている接続で、エラーは発生します。 多くのクライアント ライブラリは、切断時に、タイムアウト例外、接続例外、またはソケット例外など、さまざまな種類のエラーをスローする場合があります。 例外の数と種類は、キャッシュで接続が閉じられたときの要求のコード パス内の場所によって異なります。 たとえば、要求を送信した操作が、フェールオーバーの発生で応答を受信しない場合、タイムアウト例外を取得する可能性があります。 接続が閉じられたオブジェクトは、再接続が正常に行われるまで、新しい要求で接続例外を受け取ります。

ほとんどのクライアント ライブラリは、構成されている場合、キャッシュへの再接続を試みます。 ただし、予期しないバグによってライブラリ オブジェクトが回復不能な状態になることがあります。 エラーが事前構成された時間を超えて続く場合は、接続オブジェクトを再作成する必要があります。 Microsoft .NET およびその他のオブジェクト指向言語では、[Lazy\<T\> パターン](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)を使用することで、アプリケーションを再起動せずに接続を再作成できます。

### <a name="how-do-i-make-my-application-resilient"></a>アプリケーションの回復性を高める方法

フェールオーバーを完全に回避することは不可能なので、お使いのクライアント アプリケーションで、接続の中断時と要求の失敗時の回復性を記述します。 ほとんどのクライアント ライブラリは自動的にキャッシュ エンドポイントに再接続できますが、少数は失敗した要求を再試行します。 アプリケーションのシナリオによっては、バックオフによる再試行ロジックが理にかなっている場合があります。

クライアント アプリケーションの回復性をテストするには、接続が切断された場合の手動トリガーとして、[再起動](cache-administration.md#reboot)を使用します。 また、キャッシュに[更新をスケジュール](cache-administration.md#schedule-updates)することをお勧めします。 管理サービスに、指定した週の時間枠の間に Redis のランタイム修正プログラムを適用するように指示します。 通常これらの時間枠は、発生の可能性のある事柄を回避する、クライアント アプリケーションのトラフィックが少ない時間です。

### <a name="client-network-configuration-changes"></a>クライアントのネットワーク構成の変更

クライアント側の特定のネットワーク構成の変更によって、"接続が使用できません" というエラーが発生することがあります。 このような変更には、次のものが含まれます。

- クライアント アプリケーションの仮想 IP アドレスをステージング スロットと運用スロット間で交換しました。
- お使いのアプリケーションのインスタンスのサイズまたは数をスケーリングしました。

このような変更では、1 分未満の接続の問題が発生する可能性があります。 お使いのクライアント アプリケーションからは、Azure Cache for Redis サービスに加え、他の外部のネットワークのリソースにも接続できなくなる場合があります。

## <a name="next-steps"></a>次のステップ

- キャッシュの[更新をスケジュールする](cache-administration.md#schedule-updates)。
- [再起動](cache-administration.md#reboot)を使用して、アプリケーションの回復性をテストする。
- メモリの予約とポリシーを[構成する](cache-configure.md#memory-policies)。
