---
title: 検索結果の操作方法
titleSuffix: Azure Cognitive Search
description: Azure Cognitive Search において、検索結果の構成と並べ替え、ドキュメント数の取得、および検索結果へのコンテンツ ナビゲーションの追加を行います。
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 04/01/2020
ms.openlocfilehash: 0f815003449f0600bce1cb8927b92b85b51b09a1
ms.sourcegitcommit: d791f8f3261f7019220dd4c2dbd3e9b5a5f0ceaf
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2020
ms.locfileid: "81641617"
---
# <a name="how-to-work-with-search-results-in-azure-cognitive-search"></a>Azure Cognitive Search での検索結果の操作方法

この記事では、一致するドキュメントの合計数、ページ分割された結果、並べ替えられた結果、検索結果が強調表示された用語と共に返されるクエリ応答を取得する方法について説明します。

応答の構造は、クエリ内のパラメーター、つまり REST API での[検索ドキュメント](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)または .NET SDK での [DocumentSearchResult クラス](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.documentsearchresult-1)によって決定されます。

## <a name="result-composition"></a>結果の構成

検索ドキュメントは多数のフィールドで構成される可能性がありますが、一般に、結果セット内の各ドキュメントを表すために必要なものは数個しかありません。 クエリ要求で、応答にどのフィールドを表示するかを指定するには `$select=<field list>` を追加します。 あるフィールドを結果に含めるには、そのフィールドのインデックスに**取得可能**の属性が付けられている必要があります。 

最適に機能するフィールドには、各ドキュメントを比較対照して区別することにより、ユーザーの側にクリックスルー応答を誘うための十分な情報を提供するフィールドが含まれます。 eコマース サイトでは、それは製品名、説明、ブランド、色、サイズ、価格、評価などである場合があります。 hotels-sample-index という組み込みのサンプルの場合、それは次の例のフィールドのようになります。

```http
POST /indexes/hotels-sample-index/docs/search?api-version=2019-05-06 
    {  
      "search": "sandy beaches",
      "select": "HotelId, HotelName, Description, Rating, Address/City"
      "count": true
    }
```

> [!NOTE]
> 結果に画像ファイル (製品の写真やロゴなど) を含める場合、それらは Azure Cognitive Search の外部に格納しますが、画像の URL を参照するためのインデックス内のフィールドを検索ドキュメントに含めます。 結果内の画像をサポートするサンプル インデックスには、この[クイックスタート](search-create-app-portal.md)で紹介されている **realestate-sample-us** のデモや、[ニューヨーク市のジョブ デモ アプリ](https://aka.ms/azjobsdemo)が含まれます。

## <a name="paging-results"></a>ページングの結果

既定では、検索エンジンは最初の 50 個の一致まで返します。順序は、クエリがフルテキスト検索である場合は検索スコアによって決定され、完全一致のクエリの場合は任意の順序で返されます。

別の数の一致するドキュメントを返すには、クエリ要求に `$top` および `$skip` パラメーターを追加します。 このロジックを説明する一覧を次に示します。

+ インデックス内の一致するドキュメントの合計数を取得するには、`$count=true` を追加します。

+ 15 個の一致するドキュメントの最初のセットに加え、合計の一致の数を返します: `GET /indexes/<INDEX-NAME>/docs?search=<QUERY STRING>&$top=15&$skip=0&$count=true`

+ 2 番目のセットを返し、次の 15 個を取得するために最初の 15 個をスキップします: `$top=15&$skip=15`。 15 個の 3 番目のセットについて同じことを行います: `$top=15&$skip=30`

基になるインデックスが変更されている場合、ページ分割されたクエリの結果の安定性は保証されません。 ページングによって各ページの `$skip` の値が変更されますが、各クエリは独立しており、クエリ時にインデックス内に存在する (つまり、汎用データベースで見られるような結果のキャッシュやスナップショットは存在しない) ため、データの現在のビューに対して動作します。
 
次の例は、重複がどのように発生するかを示しています。 4 つのドキュメントを含む次のインデックスがあるとします。

    { "id": "1", "rating": 5 }
    { "id": "2", "rating": 3 }
    { "id": "3", "rating": 2 }
    { "id": "4", "rating": 1 }
 
ここでは、結果を一度に 2 つ、評価の順序で返してもらいたいとします。 結果の最初のページを取得するために `$top=2&$skip=0&$orderby=rating desc` というクエリを実行すると、次の結果が生成されます。

    { "id": "1", "rating": 5 }
    { "id": "2", "rating": 3 }
 
このサービスでは、クエリ呼び出しの間に `{ "id": "5", "rating": 4 }` という 5 番目のドキュメントがインデックスに追加されたとします。  その後すぐに、2 ページ目をフェッチするために `$top=2&$skip=2&$orderby=rating desc` というクエリを実行すると、次の結果が得られます。

    { "id": "2", "rating": 3 }
    { "id": "3", "rating": 2 }
 
ドキュメント 2 が 2 回フェッチされることに注意してください。 これは、新しいドキュメント 5 の方が評価の値が大きいため、ドキュメント 2 の前に並べ替えられ、最初のページに割り当てられるためです。 この動作は予期されない可能性がありますが、検索エンジンの動作としては一般的なものです。

## <a name="ordering-results"></a>結果の並べ替え

フルテキスト検索クエリの場合、結果は、ドキュメント内の用語頻度と近接性に基づいて計算された検索スコアによって自動的にランク付けされます。ここで、検索用語に対するより多くの、またはより強力な一致を含むドキュメントにより高いスコアが割り当てられます。 

検索スコアは、一般的な意味での関連性を伝達するため、同じ結果セット内の他のドキュメントと比べた場合の一致の強さが反映されています。 スコアは、必ずしもあるクエリから次のクエリへと一貫しているとは限らないため、クエリを操作していると、検索ドキュメントの順序付け方法における小さな不一致に気付くことがあります。 これが発生する理由については、次のいくつかの説明があります。

| 原因 | 説明 |
|-----------|-------------|
| データのボラティリティ | ドキュメントを追加、変更、または削除すると、インデックス コンテンツは変動します。 インデックスの更新が徐々に処理されるに従って用語頻度は変化し、一致するドキュメントの検索スコアに影響を与えます。 |
| 複数のレプリカ | 複数のレプリカを使用するサービスの場合、クエリは、各レプリカに対して並列に発行されます。 検索スコアを計算するために使用されるインデックス統計はレプリカごとに計算され、クエリ応答の中で結果がマージされ、順序付けられます。 レプリカのほとんどは互いのミラーですが、状態の小さな違いのために統計は異なる場合があります。 たとえば、あるレプリカで、他のレプリカからマージされた、その統計に寄与しているドキュメントが削除されることがあります。 通常、レプリカごとの統計の違いは、小さなインデックスの方がより顕著です。 |
| 同一のスコア | 複数のドキュメントのスコアが同じである場合、それらはいずれも最初に表示される可能性があります。  |

### <a name="consistent-ordering"></a>一貫した順序付け

結果の順序付けが柔軟であるなら、一貫性がアプリケーションの要件である場合は、他のオプションを調査することもできます。 最も簡単なアプローチは、評価や日付などのフィールド値での並べ替えです。 評価や日付などの特定のフィールドで並べ替えるシナリオの場合は、**並べ替え可能**のインデックスが付けられた任意のフィールドに適用できる [`$orderby` 式](query-odata-filter-orderby-syntax.md)を明示的に定義できます。

別のオプションとして、[カスタム スコアリング プロファイル](index-add-scoring-profiles.md)の使用があります。 スコアリング プロファイルを使用すると、検索結果内の項目のランク付けをより細かく制御できるため、特定のフィールドで見つかる一致を向上させることができます。 追加のスコアリング ロジックにより、各ドキュメントの検索スコアがさらに離れるため、レプリカ間のわずかな違いのオーバーライドに役立ちます。 このアプローチには[ランク付けアルゴリズム](index-ranking-similarity.md)をお勧めします。

## <a name="hit-highlighting"></a>検索結果の強調表示

検索結果の強調表示とは、結果内の一致する用語に適用され、一致が容易に見つかるようにするテキストの書式設定 (太字や黄色の強調表示など) を指します。 検索結果の強調表示の手順については、[クエリ要求](https://docs.microsoft.com/rest/api/searchservice/search-documents)に関する記事で説明しています。 検索エンジンは、一致する用語をタグ `highlightPreTag` と `highlightPostTag` で囲み、ユーザーのコードがその応答を処理します (太字のフォントの適用など)。

書式設定は、語句全体のクエリに適用されます。 次の例では、[説明] フィールド内で見つかった用語 "sandy"、"sand"、"beaches"、"beach" に強調表示のタグが付けられます。 エンジンのクエリ拡張をトリガーするクエリ (あいまい検索やワイルドカード検索など) では、検索結果の強調表示のサポートが制限されています。

```http
GET /indexes/hotels-sample-index/docs/search=sandy beaches&highlight=Description?api-version=2019-05-06 
```

```http
POST /indexes/hotels-sample-index/docs/search?api-version=2019-05-06 
    {  
      "search": "sandy beaches",  
      "highlight": "Description"
    }
```

### <a name="new-behavior-starting-july-15"></a>新しい動作 (7 月15日以降)

2020 年 7 月 15 日以降に作成されたサービスでは、異なる強調表示エクスペリエンスが提供されます。 この日付より前に作成されたサービスについては、強調表示の動作に変更はありません。 

新しい動作では:

* フル フレーズのクエリに一致する語句だけが返されるようになります。 クエリ "super bowl" では、次のような強調表示が返されます。

    ```html
    '<em>super bowl</em> is super awesome with a bowl of chips'
    ```
  用語 *bowl of chips*はフル フレーズと一致しないため、強調表示されていないことに注意してください。
  
* 強調表示用に返されるフラグメント サイズも指定できるようになります。 フラグメント サイズは文字数として指定します (最大 1000 文字)。

ヒットの強調表示を実装するクライアント コードを記述する場合は、この変更点に注意してください。 まったく新しい検索サービスを作成しない限り、この変更の影響を受けることはありません。

## <a name="next-steps"></a>次のステップ

クライアントの検索ページをすばやく生成するには、次のオプションを検討してください。

+ [アプリケーション ジェネレーター](search-create-app-portal.md)。ポータルで、検索バー、ファセット ナビゲーション、画像を含む結果領域を備えた HTML ページを作成します。
+ [C# での最初のアプリの作成](tutorial-csharp-create-first-app.md)に関するページは、機能するクライアントを構築するチュートリアルです。 サンプル コードは、ページ分割されたクエリ、検索結果の強調表示、並べ替えを示しています。

複数のコード サンプルに Web フロントエンド インターフェイスが含まれており、次でも見つけることができます: [ニューヨーク市のジョブ デモ アプリ](https://aka.ms/azjobsdemo)、[ライブ デモ サイトを使用した JavaScript サンプル コード](https://github.com/liamca/azure-search-javascript-samples)、および [CognitiveSearchFrontEnd](https://github.com/LuisCabrer/CognitiveSearchFrontEnd)。
