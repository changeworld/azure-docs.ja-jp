---
title: Azure Cosmos DB インデックス作成ポリシー
description: Azure Cosmos DB でのインデックス作成の自動化とパフォーマンス向上のために、既定のインデックス作成ポリシーを構成および変更する方法について説明します。
author: timsander1
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 04/28/2020
ms.author: tisande
ms.openlocfilehash: 68adfb8b4cfb7c665a8e8b162b4698a095bb671e
ms.sourcegitcommit: f57297af0ea729ab76081c98da2243d6b1f6fa63
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/06/2020
ms.locfileid: "82869941"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Azure Cosmos DB でのインデックス作成ポリシー

Azure Cosmos DB では、すべてのコンテナーに、コンテナーの項目のインデックスを作成する方法を指示するインデックス作成ポリシーがあります。 新しく作成したコンテナーの既定のインデックス作成ポリシーでは、すべての項目のプロパティに対してインデックスが作成され、文字列または数値には範囲インデックスが、Point 型の GeoJSON オブジェクトには空間インデックスが適用されます。 これにより、インデックス作成とインデックス管理を事前に考慮することなく、高いクエリ パフォーマンスを得ることができます。

状況によっては、この自動動作を、自分の要件にさらに適合するようにオーバーライドできます。 "*インデックス作成モード*" を設定し、"*プロパティ パス*" を含めるか除外することで、コンテナーのインデックス作成ポリシーをカスタマイズできます。

> [!NOTE]
> この記事で説明するインデックス作成ポリシーの更新方法は、Azure Cosmos DB の SQL (Core) API にのみ適用されます。

## <a name="indexing-mode"></a>インデックス作成モード

Azure Cosmos DB では 2 つのインデックス作成モードがサポートされます。

- **同期**: 項目を作成、更新、削除すると、それに同期してインデックスが更新されます。 つまり、読み取りクエリの一貫性は、[アカウント用に構成された整合性](consistency-levels.md)になります。
- **なし**: コンテナーでインデックス作成が無効になっています。 これは、コンテナーがセカンダリ インデックスを必要としない純粋なキー値ストアとして使用される場合に一般的に使用されます。 一括操作のパフォーマンスを改善する目的で使用することもできます。 一括操作が完了したら、インデックス モードを Consistent に設定し、完了まで [IndexTransformationProgress](how-to-manage-indexing-policy.md#dotnet-sdk) を利用して監視できます。

> [!NOTE]
> Azure Cosmos DB では、Lazy インデックス作成モードもサポートされます。 Lazy 方式のインデックスではインデックス更新の優先順位が低く、エンジンが他に何も作業をしていないときに実行されます。 結果的に、クエリの結果に**一貫性がなくなったり、不完全になったり**します。 Cosmos コンテナーに対してクエリを実行する場合は、Lazy インデックス作成を選択しないでください。

既定では、インデックス作成ポリシーは `automatic` に設定されます。 これはインデックス作成ポリシーの `automatic` プロパティを `true` に設定することで行います。 このプロパティを `true` に設定すると、Azure Cosmos DB で、ドキュメントが書き込まれたときに自動的にインデックスを作成できます。

## <a name="including-and-excluding-property-paths"></a><a id="include-exclude-paths"></a> プロパティ パスを含める/除外する

カスタム インデックス作成ポリシーには、明示的にインデックス作成に含めるかインデックス作成から除外するプロパティ パスを指定できます。 インデックスが作成されるパスの数を最適化することによって、コンテナーによって使用されるストレージの量を削減し、書き込み操作の待機時間を短縮できます。 これらのパスは、[インデックス作成の概要内のセクションで説明されている方法](index-overview.md#from-trees-to-property-paths)に従って定義され、以下のように追加されます。

- スカラー値 (文字列または数値) へのパスは `/?` で終わる
- 配列の要素は、(`/0` や `/1` ではなく) `/[]` 表記でまとめて処理される
- `/*` ワイルドカードを使用してノードの下の任意の要素を一致させることができる

同じ例をもう一度使用します。

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters` の `employees` パスは `/headquarters/employees/?`

- `locations` の `country` パスは `/locations/[]/country/?`

- `headquarters` の下にあるもののパスは `/headquarters/*`

たとえば、`/headquarters/employees/?` パスを含めることができます。 このパスにより employees プロパティのインデックスが確実に作成されますが、このプロパティ内で入れ子になっている追加の JSON のインデックスは作成されません。

## <a name="includeexclude-strategy"></a>包含/除外戦略

すべてのインデックス作成ポリシーには、含まれるパスまたは除外されるパスのいずれかとしてルート パス `/*` を指定する必要があります。

- インデックスを作成する必要がないパスを選択的に除外するためにルート パスを指定する。 モデルに追加される可能性がある新しいプロパティのインデックスを Azure Cosmos DB で先を見越して作成できるため、これが推奨される方法です。
- インデックスを作成する必要があるパスを選択的に含めるためにルート パスを除外する。

- 英数字や _ (アンダースコア) を含む通常文字から成るパスの場合は、パス文字列を二重引用符で囲んでエスケープする必要はありません ("/path/?" など)。 他の特殊文字を含むパスの場合は、パス文字列を二重引用符で囲んでエスケープする必要があります ("/\"path-abc\"/?" など)。 パスの中に特殊文字が予測される場合は、安全のために、すべてのパスをエスケープすることができます。 機能的には、すべてのパスをエスケープしても、特殊文字を含むパスだけをエスケープしても何も違いはありません。

- システム プロパティ `_etag` は、etag がインデックス作成対象パスに追加されていない限り、既定でインデックス作成から除外されます。

- インデックス作成モードが **[consistent]\(同期\)** に設定されている場合、システム プロパティ `id` と `_ts` には自動的にインデックスが作成されます。

パスを含めたり除外したりするときに、次の属性が見つかる場合があります。

- `kind` には、`range` または `hash` のいずれかを指定できます。 範囲インデックス機能ではハッシュ インデックスのすべての機能が提供されるため、範囲インデックスを使用することをお勧めします。

- `precision` は、含まれるパスのインデックス レベルで定義された数値です。 値 `-1` は、最大有効桁数を示します。 この値は常に `-1` に設定することをお勧めします。

- `dataType` には、`String` または `Number` のいずれかを指定できます。 これは、インデックスが作成される JSON プロパティの種類を示します。

指定しない場合、これらのプロパティには次の既定値が設定されます。

| **プロパティ名**     | **既定値** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` および `Number` |

パスを含めたり除外したりするためのインデックス作成ポリシーの例については、[こちらのセクション](how-to-manage-indexing-policy.md#indexing-policy-examples)を参照してください。

## <a name="includeexclude-precedence"></a>優先順位を含める、または除外する

含まれるパスと除外されるパスに競合がある場合は、より正確なパスが優先されます。

次に例を示します。

**含まれるパス**: `/food/ingredients/nutrition/*`

**除外されるパス**: `/food/ingredients/*`

この場合、含まれるパスはより正確であるため、除外されるパスよりも優先されます。 これらのパスに基づいて、`food/ingredients` パス内または入れ子になっているすべてのデータは、インデックスから除外されます。 例外は、含まれるパス `/food/ingredients/nutrition/*` 内のデータで、インデックスが作成されます。

Azure Cosmos DB の含まれるパスと除外されるパスの優先順位に関するいくつかの規則を次に示します。

- より深いパスは、浅いパスよりも正確です。 たとえば、`/a/b/?` は `/a/?` よりも正確です。

- `/?` は `/*` よりも正確です。 たとえば `/a/?` は `/a/*` よりも正確であるため、`/a/?` が優先されます。

- パス `/*` には、含まれるパスまたは除外されるパスを指定する必要があります。

## <a name="spatial-indexes"></a>空間インデックス

インデックス作成ポリシーで空間パスを定義する場合は、そのパスに適用するインデックスの ```type``` を定義する必要があります。 空間インデックスには、次のような種類があります。

* ポイント

* 多角形

* MultiPolygon

* LineString

既定では、Azure Cosmos DB では空間インデックスは作成されません。 空間 SQL 組み込み関数を使用する場合は、必要なプロパティに対して空間インデックスを作成する必要があります。 空間インデックスを追加するためのインデックス作成ポリシーの例については、[このセクション](geospatial.md)を参照してください。

## <a name="composite-indexes"></a>複合インデックス

2 つ以上のプロパティを使用する `ORDER BY` 句が含まれるクエリには、複合インデックスが必要です。 また、複合インデックスを定義して、多くの等値クエリと範囲クエリのパフォーマンスを向上させることもできます。 既定では、複合インデックスは定義されないため、必要に応じて[複合インデックスを追加する](how-to-manage-indexing-policy.md#composite-indexing-policy-examples)必要があります。

含まれるパスまたは除外されるパスとは異なり、`/*` ワイルドカードを使用してパスを作成することはできません。 すべての複合パスには、指定する必要のないパスの末尾に暗黙的な `/?` があります。 複合パスはスカラー値になります。これは、複合インデックスに含まれる唯一の値です。

複合インデックスを定義する場合は、次のものを指定します。

- 2 つ以上のプロパティ パス。 プロパティ パスが定義されるシーケンスが重要です。

- 順序 (昇順または降順)。

> [!NOTE]
> 複合インデックスを追加したとき、新しい複合インデックスの追加が完了するまで、クエリは既存の範囲インデックスを利用します。 そのため、複合インデックスを追加しても、すぐにパフォーマンス向上が見られないことがあります。 [いずれかの SDK を使用して](how-to-manage-indexing-policy.md)、インデックス変換の進行状況を追跡できます。

### <a name="order-by-queries-on-multiple-properties"></a>複数のプロパティに対する ORDER BY クエリ:

2 つ以上のプロパティを使用する `ORDER BY` 句が含まれるクエリに複合インデックスを使用する場合は、次の考慮事項を確認します。

- 複合インデックスのパスが `ORDER BY` 句の中のプロパティのシーケンスに一致しない場合、その複合インデックスはクエリをサポートできません。

- 複合インデックスのパスの順序 (昇順または降順) は、`ORDER BY` 句の中の `order` とも一致する必要があります。

- 複合インデックスはまた、すべてのパスで反対の順序を持つ `ORDER BY` 句もサポートします。

複合インデックスがプロパティ name、age、および _ts に対して定義されている次の例を考えてみます。

| **複合インデックス**     | **サンプルの `ORDER BY` クエリ**      | **複合インデックスでサポートされているか** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

すべての必要な `ORDER BY` クエリに対応できるように、インデックス作成ポリシーをカスタマイズする必要があります。

### <a name="queries-with-filters-on-multiple-properties"></a>複数のプロパティに対するフィルターを含むクエリ

クエリに 2 つ以上のプロパティに対するフィルターが含まれている場合は、これらのプロパティの複合インデックスを作成すると便利な場合があります。

たとえば、2 つのプロパティに対する等値フィルターが含まれている次のクエリについて考えてみます。

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

このクエリは、(name ASC, age ASC) の複合インデックスを利用できる場合、時間が短縮され、RU の消費が少なくなり、より効率的に実行できます。

範囲フィルターが含まれるクエリを複合インデックスを使用して最適化することもできます。 ただし、クエリに含めることができる範囲フィルターは 1 つのみです。 範囲フィルターは、`>`、`<`、`<=`、`>=`、`!=` です。 範囲フィルターは、複合インデックス内で最後に定義する必要があります。

等値フィルターと範囲フィルターの両方が含まれる次のクエリについて考えてみます。

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

このクエリは、(name ASC, age ASC) の複合インデックスを使用すると、より効率的に実行できます。 ただし、等値フィルターは複合インデックス内で最初に定義する必要があるため、クエリでは (age ASC, name ASC) の複合インデックスが使用されません。

複数のプロパティに対するフィルターが含まれるクエリ用に複合インデックスを作成する場合は、次の考慮事項を確認します。

- クエリのフィルター内のプロパティは、複合インデックス内のプロパティと一致している必要があります。 複合インデックスにプロパティが含まれていても、クエリにフィルターとして含まれていない場合、このクエリでは複合インデックスは使用されません。
- 複合インデックスで定義されていない追加のプロパティがフィルターに含まれているクエリの場合は、複合インデックスと範囲インデックスの組み合わせを使用してクエリが評価されます。 この場合、範囲インデックスのみ使用する場合よりも、必要な RU が少なくなります。
- プロパティに範囲フィルター (`>`、`<`、`<=`、`>=`、または `!=`) が含まれている場合、このプロパティは複合インデックス内で最後に定義する必要があります。 クエリに複数の範囲フィルターが含まれている場合、複合インデックスは使用されません。
- 複数のフィルターが含まれるクエリを最適化するために複合インデックスを作成する場合、複合インデックスの `ORDER` は結果に影響しません。 このプロパティは省略可能です。
- 複数のプロパティに対するフィルターが含まれるクエリに対して複合インデックスを定義しなかった場合でも、クエリは成功します。 しかし、複合インデックスを使用すると、クエリの RU コストを削減できます。

複合インデックスがプロパティ name、age、および timestamp に対して定義されている次の例を考えてみます。

| **複合インデックス**     | **サンプル クエリ**      | **複合インデックスでサポートされているか** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>フィルターおよび ORDER BY 句が含まれるクエリ

クエリで 1 つ以上のプロパティがフィルター処理され、ORDER BY 句に異なるプロパティが含まれている場合は、フィルター内のプロパティを `ORDER BY` 句に追加すると便利な場合があります。

たとえば、フィルター内のプロパティを ORDER BY 句に追加すると、複合インデックスを利用するために次のクエリを書き直すことができます。

範囲インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

複合インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

複数の等値フィルターが含まれるクエリに対して、同じパターンおよびクエリの最適化を一般化できます。

範囲インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

複合インデックスを使用するクエリ:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

フィルターと `ORDER BY` 句が含まれるクエリを最適化するために複合インデックスを作成する場合は、次の考慮事項を確認します。

* クエリでプロパティをフィルター処理する場合は、最初に `ORDER BY` 句に含める必要があります。
* 1 つのプロパティに対するフィルターと、異なるプロパティを使用する別の `ORDER BY` 句が含まれるクエリに対して複合インデックスを定義しなかった場合でも、クエリは成功します。 しかし、複合インデックスを使用すると、特に `ORDER BY` 句内のプロパティのカーディナリティが高い場合、クエリの RU コストを削減できます。
* 複合インデックスを、複数のプロパティが含まれる `ORDER BY` クエリ、および複数のプロパティに対するフィルターが含まれるクエリに対して作成する際の考慮事項もすべて、適用されます。


| **複合インデックス**                      | **サンプルの `ORDER BY` クエリ**                                  | **複合インデックスでサポートされているか** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>インデックス作成ポリシーの変更

コンテナーのインデックス作成ポリシーは、[Azure portal またはサポートされている SDK のいずれかを使用して](how-to-manage-indexing-policy.md)いつでも更新できます。 インデックス作成ポリシーを更新すると、古いインデックスから新しいインデックスへの変換がトリガーされ、オンラインでその場で実行されます (そのため、この操作中に記憶域が追加で消費されることはありません)。 古いポリシーのインデックスは新しいポリシーに効率的に変換され、コンテナー上での書き込み可用性やプロビジョニングされたスループットが影響を受けることはありません。 インデックス変換は非同期操作であり、完了までにかかる時間は、プロビジョニングされたスループット、項目の数、およびそれらのサイズによって決まります。

> [!NOTE]
> 範囲または空間インデックスの追加中は、一致する結果の一部がクエリから返されない可能性があり、それが何もエラーを返さずに行われます。 つまり、クエリの結果は、インデックス変換が完了するまでは一貫性がない可能性があります。 [いずれかの SDK を使用して](how-to-manage-indexing-policy.md)、インデックス変換の進行状況を追跡できます。

新しいインデックス作成ポリシーのモードが [同期] に設定されている場合、インデックス変換の進行中は、他のインデックス作成ポリシーの変更を適用することはできません。 実行中のインデックス変換は、インデックス作成ポリシーのモードを [なし] に設定することでキャンセルできます (インデックスがただちにドロップされます)。

## <a name="indexing-policies-and-ttl"></a>インデックス作成ポリシーと TTL

[Time-to-live (TTL) 機能](time-to-live.md)がオンになっているコンテナーでは、インデックス作成がアクティブになっている必要があります。 これは、次のことを意味します。

- インデックス作成モードが [なし] に設定されているコンテナーで TTL をアクティブにすることはできません。
- TTL がアクティブになっているコンテナーで、インデックス作成モードを [なし] に設定することはできません。

インデックス作成が必要なプロパティ パスはないが、TTL が必要なシナリオでは、次のようなインデックス作成ポリシーを使用できます。

- インデックス作成モードが [同期] に設定されている
- パスが含まれていない
- 唯一の除外パスとして `/*` が指定されている

## <a name="next-steps"></a>次のステップ

以下の記事で、インデックス作成についての詳細を参照してください。

- [インデックス作成の概要](index-overview.md)
- [インデックス作成ポリシーを管理する方法](how-to-manage-indexing-policy.md)
