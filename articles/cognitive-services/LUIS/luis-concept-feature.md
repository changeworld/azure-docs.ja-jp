---
title: LUIS での機械学習の特徴
description: フィーチャーを言語モデルに追加することで、ラベル付けまたは分類する必要がある入力を認識する方法についてのヒントが提供されます。
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 09/22/2020
ms.openlocfilehash: da85abdff3d1022659f2d4e83fd14c5ae6003fc9
ms.sourcegitcommit: f28ebb95ae9aaaff3f87d8388a09b41e0b3445b5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "100546059"
---
# <a name="machine-learning-features"></a>機械学習の特徴

機械学習では、 *特徴* がデータを区別するための特性または属性であり、システムを使ってその観察と学習を行います。

機械学習の特徴は、LUIS にとって、概念を区別するものをどこで探すかに関する重要な手がかりとなります。 これらは LUIS で利用できるヒントですが、厳密な規則ではありません。 LUIS ではこれらのヒントをラベルと組み合わせて使用し、データを見つけます。

特徴は、f(x) = y のような関数として記述できます。 発話の例では、この特徴により、特性を区別するために発話の例のどこを調べるかが示されます。 この情報は、スキーマの作成に役立てるために使用します。

## <a name="types-of-features"></a>特徴の種類

特徴は、スキーマ設計の必要な部分です。 LUIS は、語句一覧とモデルの両方を特徴としてサポートしています。

* フレーズ リストの特徴
* 特徴としてのモデル (意図またはエンティティ)

## <a name="find-features-in-your-example-utterances"></a>発話の例の中で特徴を見つける

LUIS は言語ベースのアプリケーションであるため、特徴はテキストベースです。 区別する特性を示すテキストを選択します。 LUIS の場合、最小の単位は *トークン* です。 英語では、スペースや句読点を含まない、文字や数字が連続する範囲が 1 つのトークンです。

スペースと句読点はトークンではないため、特徴として使用できるテキストのヒントに焦点を当てます。 忘れずに、次のような単語のバリエーションを含めてください。

* 複数形
* 動詞の時制
* 省略形
* スペルとスペルミス

それによって特性が区別されるため、テキストで以下を行う必要があるかどうかを決定します。

* 完全な単語または語句に一致する:正規表現エンティティを追加するか、特徴としてのリスト エンティティをエンティティまたは意図に追加することを検討します。
* 日付、時刻、または人名のようなよく知られた概念と一致する:エンティティまたは意図に対する特徴として事前構築済みのエンティティを使用します。
* 時間の経過と共に新しい例を学習する:エンティティまたは意図に対する特徴としての概念の例がいくつか含まれるフレーズ リストを使用します。

## <a name="create-a-phrase-list-for-a-concept"></a>概念のフレーズ リストを作成する

フレーズ リストは、1 つの概念を記述する単語またはフレーズのリストです。 フレーズ リストは、大文字と小文字を区別しない一致として、トークン レベルで適用されます。

フレーズ リストを追加すると、特徴を **[グローバル](#global-features)** として設定できます。 グローバル特徴はアプリ全体に適用されます。

### <a name="when-to-use-a-phrase-list"></a>語句一覧を使用する条件

LUIS アプリで、概念の新しい項目を一般化して識別する必要がある場合は、フレーズ リストを使用します。 フレーズ リストは、領域固有の語彙に似ています。 これらによって、意図とエンティティについての理解の質が向上します。

### <a name="how-to-use-a-phrase-list"></a>語句一覧の使用方法

フレーズ リストを使用すると、LUIS ではコンテキストの検討と一般化が行われ、類似しているが完全なテキスト一致ではない項目が識別されます。 以下の手順に従ってフレーズ リストを使用します。

1. 機械学習エンティティから開始します。
    1. 発話の例を追加します。
    1. 機械学習エンティティを使用してラベルを付けます。
1. フレーズ リストを追加します。
    1. 類似の意味を持つ単語を追加します。 考えられるすべての単語やフレーズを追加しないでください。 その代わりに、一度に数個の単語またはフレーズを追加します。 その後、再度トレーニングして発行します。
    1. 提案された単語を検討して追加します。

### <a name="a-typical-scenario-for-a-phrase-list"></a>フレーズ リストの一般的なシナリオ

フレーズ リストの一般的なシナリオは、特定のアイデアに関連する単語をブーストすることです。

重要性を大幅に高めるためにフレーズ リストが必要になる可能性がある単語の良い例は、医学用語です。 これらの用語には、特定の物理的意味、化学的意味、治療上の意味、または抽象的な意味がある可能性があります。 フレーズ リストがないと、LUIS では対象ドメインにとってその用語が重要であることを判断できません。

医学用語を抽出するには:

1. 発話の例を作成し、それらの発話内の医学用語にラベルを付けます。
2. 主題領域で使われる用語の例を含むフレーズ リストを作成します。 このフレーズ リストには、ラベルを付けた実際の用語と、同じ概念を説明する他の用語を含める必要があります。
3. フレーズ リストで使用される概念を抽出するエンティティまたはサブエンティティに、フレーズ リストを追加します。 最も一般的なシナリオは、機械学習エンティティのコンポーネント (子) です。 フレーズ リストをすべての意図またはエンティティにわたって適用する必要がある場合は、フレーズ リストをグローバル フレーズ リストとしてマークします。 API では、**enabledForAllModels** フラグによって、このモデルのスコープが制御されます。

### <a name="token-matches-for-a-phrase-list"></a>語句一覧のトークンの一致

フレーズ リストは常にトークン レベルで適用されます。 次の表は、**Ann** という単語を含むフレーズ リストが、その順序で同じ文字のバリエーションにどのように適用されるかを示しています。


| **Ann** のトークン バリエーション | トークンが見つかったときのフレーズ リストの一致 |
|--------------------------|---------------------------------------|
| **ANN**<br>**aNN**<br>           | はい - トークンは **Ann** です                  |
| **Ann's**                    | はい - トークンは **Ann** です                  |
| **Anne**                     | いいえ - トークンは **Anne** です                  |

<a name="how-to-use-phrase-lists"></a>
<a name="how-to-use-a-phrase-lists"></a>
<a name="phrase-lists-help-identify-simple-exchangeable-entities"></a>

## <a name="a-model-as-a-feature-helps-another-model"></a>別のモデルの役に立つ特徴としてのモデル

モデル (意図またはエンティティ) を特徴として別のモデル (意図またはエンティティ) に追加できます。 既存の意図またはエンティティを特徴として追加することで、ラベル付けされた例を含む適切に定義された概念を追加することになります。

特徴としてのモデルを追加する場合、特徴を次のように設定できます。
* **[必須](#required-features)** 。 モデルを予測エンドポイントから返すには、必須の特徴が検出される必要があります。
* **[グローバル](#global-features)** 。 グローバル特徴はアプリ全体に適用されます。

### <a name="when-to-use-an-entity-as-a-feature-to-an-intent"></a>特徴としてのエンティティを意図に使用するタイミング

意図にとってあるエンティティの検出が重要である場合は、そのエンティティを特徴としてその意図に追加します。

たとえば、意図 (**BookFlight** など) がフライトを予約することで、エンティティがチケット情報 (座席番号、出発地、目的地など) である場合、チケット情報のエンティティが見つかれば、**BookFlight** 意図の予測に非常に大きな重み付けが追加されるはずです。

### <a name="when-to-use-an-entity-as-a-feature-to-another-entity"></a>特徴としてのエンティティを別のエンティティに使用するタイミング

エンティティ (A) の検出が、エンティティ (B) の予測にとって重要である場合は、エンティティ (B) に対する特徴として、エンティティ (A) を追加する必要があります。

たとえば、ある配送先住所エンティティが、1 つの番地サブエンティティに含まれている場合、その番地サブエンティティが見つかれば、配送先住所エンティティの予測に非常に大きな重み付けが追加されます。

* 配送先住所 (機械学習エンティティ):

    * 番地の番号 (サブエンティティ)
    * 番地 (サブエンティティ)
    * 市区町村 (サブエンティティ)
    * 都道府県 (サブエンティティ)
    * 国/地域 (サブエンティティ)
    * 郵便番号 (サブエンティティ)

## <a name="nested-subentities-with-features"></a>特徴があり、入れ子になっているサブエンティティ

機械学習サブエンティティは、親エンティティに概念があることを示します。 親は、別のサブエンティティである場合も、最上位エンティティである場合もあります。 サブエンティティの値は、その親の特徴として機能します。

サブエンティティは、フレーズ リストと、特徴としてのモデル (もう 1 つのエンティティ) の両方を持つことができます。

サブエンティティにフレーズ リストがある場合、概念の語彙が増加しますが、予測の JSON 応答にはいかなる情報も追加されません。

サブエンティティに別のエンティティの特徴があるとき、JSON 応答にはその別のエンティティの抽出データが含まれます。


## <a name="required-features"></a>必須の特徴

モデルを予測エンドポイントから返すには、必須の特徴が検出される必要があります。 入力データが特徴と一致する必要があることがわかっている場合は、必須の特徴を使用します。

発話テキストは、必須の特徴と一致しない場合は抽出されません。

必須の特徴には、機械学習されたのではないエンティティを使用します。

* 正規表現エンティティ
* リスト エンティティ
* 事前構築済みのエンティティ

データにモデルが含まれると確信している場合は、その特徴を必須として設定します。 必須の特徴が見つからない場合は、何も返されません。

配送先住所の例を続けます。

配送先住所 (機械学習エンティティ)

 * 番地の番号 (サブエンティティ)
 * 番地 (サブエンティティ)
 * 通りの名前 (サブエンティティ)
 * 市区町村 (サブエンティティ)
 * 都道府県 (サブエンティティ)
 * 国/地域 (サブエンティティ)
 * 郵便番号 (サブエンティティ)

### <a name="required-feature-using-prebuilt-entities"></a>事前構築済みのエンティティを使用した必須の特徴

通常、市区町村、都道府県、国、リージョンなどの事前構築済みのエンティティは、閉じたリストのセットです。つまり、時間の経過と共に大きく変化することはありません。 このようなエンティティは、関連する推奨の特徴を持つ可能性があります。また、それらの特徴に必須とマークすることができます。 ただし、`isRequired` フラグは、割り当て先のエンティティにのみ関連付けられており、階層には影響しません。 事前構築済みのサブエンティティ機能が見つからない場合、これは親エンティティの検出とリターンには影響しません。

必要な機能の例として、住所を検出することを検討します。 場合により、番地を要件とすることを検討します。 これにより、ユーザーは「1 Microsoft Way (Microsoft 通り 1 番地)」または「One Microsoft Way (Microsoft 通り一番地)」と入力することができ、どちらの場合も番地サブエンティティは数値の "1" に解決されます。 詳細については、「[事前構築済みのエンティティ](luis-reference-prebuilt-entities.md)」の記事を参照してください。

### <a name="required-feature-using-list-entities"></a>リスト エンティティを使用した必須の特徴

[リスト エンティティ](reference-entity-list.md)は、正規名のリストとして、そのシノニムと共に使用されます。 必須の特徴として、発話に正規名またはシノニムが含まれていない場合、予測エンドポイントの一部としてエンティティは返されません。

会社が限られた国や地域のみに荷物を出荷するとします。 顧客が国や地域を参照するための方法が複数含まれるリスト エンティティを作成できます。 LUIS によって発話のテキスト内の正確な一致が検出されない場合、(リスト エンティティの必須の特徴を持つ) エンティティは予測で返されません。

|正規名|シノニム|
|--|--|
|United States|米国<br>U.S.A<br>US<br>米国<br>0|

チャット ボットなどのクライアント アプリケーションでは、フォローする質問をして助けることができます。 これは、国や地域の選択肢が限られていて *必須* であることを、顧客が理解する助けになります。

### <a name="required-feature-using-regular-expression-entities"></a>正規表現エンティティを使用した必須の特徴

必須の特徴として使用される[正規表現エンティティ](reference-entity-regular-expression.md)は、豊富なテキスト照合機能を備えています。

配送先住所の例では、国や地域の郵便番号の構文規則を取り込んだ正規表現を作成できます。

## <a name="global-features"></a>グローバル特徴

最も一般的な使用方法は特徴を特定のモデルに適用することですが、特徴を **グローバル特徴** として構成し、アプリケーション全体に適用することができます。

グローバル特徴の最も一般的な使用法は、追加の語彙をアプリに追加することです。 顧客が第 1 言語を使用していても、同じ発話内で別の言語を使用可能であると想定される場合は、第 2 言語の単語を含む特徴を追加できます。

ユーザーは、すべての意図またはエンティティにわたって第 2 言語を使用することを期待するため、第 2 言語の単語をフレーズ リストに追加します。 フレーズ リストはグローバル特徴として構成します。

## <a name="combine-features-for-added-benefit"></a>特徴を結合して利点を追加する

1 つの特性または概念を記述するために、複数の特徴を使用できます。 一般的なペアリングでは、次のものを使用します。

* フレーズ リストの特徴:同じモデルに対して複数の語句リストを特徴として使用できます。
* フィーチャーとしてのモデル: [事前構築済みエンティティ](luis-reference-prebuilt-entities.md)、[正規表現エンティティ](reference-entity-regular-expression.md)、[リスト エンティティ](reference-entity-list.md)。 

### <a name="example-ticket-booking-entity-features-for-a-travel-app"></a>例: 旅行アプリのチケット予約エンティティの特徴  

基本的な例として、フライト予約の _意図_ とチケット予約 _エンティティ_ が使用される、フライト予約用のアプリを考えてみましょう。 チケット予約エンティティは、予約システムで航空機のチケットを予約するための情報をキャプチャします。 

チケット予約のための機械学習エンティティには、出発地と目的地を取得するための 2 つのサブエンティティがあります。 これらの特徴は、最上位レベルのエンティティではなく、各サブエンティティに追加する必要があります。

:::image type="content" source="media/luis-concept-features/ticket-booking-entity.png" alt-text="チケット予約エンティティ スキーマ":::

チケット予約エンティティは機械学習エンティティであり、"_出発地_" や "_目的地_" などのサブエンティティを含みます。 これらのサブエンティティは、どちらも地理的な場所を示します。 場所を抽出し、"_出発地_" と "_目的地_" を区別できるようにするには、各サブエンティティに特徴が必要です。

|型|出発地のサブエンティティ |目的地のサブエンティティ|
|--|--|--|
|特徴量としてのモデル|[geographyV2](luis-reference-prebuilt-geographyv2.md?tabs=V3) 事前構築済みエンティティ|[geographyV2](luis-reference-prebuilt-geographyv2.md?tabs=V3) 事前構築済みエンティティ|
|フレーズ リスト|**出発地の単語**: `start at`、`begin from`、`leave`|**目的地の単語**: `to`、`arrive`、`land at`、`go`、`going`、`stay`、`heading`|
|フレーズ リスト|空港コード - 出発地と目的地の両方で同じリスト|空港コード - 出発地と目的地の両方で同じリスト|
|フレーズ リスト|空港名 - 出発地と目的地の両方で同じリスト|空港コード - 出発地と目的地の両方で同じリスト|

空港コードや空港名を使用することが予想される場合、LUIS には、両方の種類のフレーズを使用するフレーズ リストが必要です。 空港コードは、チャットボットに入力したテキストによく見られる場合があります。一方、空港名は音声対応のチャットボットのような会話によく見られる場合があります。

特徴の照合の詳細は、モデルに対してのみ返され、フレーズ リストに対しては返されません。これは、予測 JSON ではモデルのみ返されるためです。

#### <a name="ticket-booking-labeling-in-the-intent"></a>意図内でのチケット予約のラベル付け

機械学習エンティティを作成したら、発話の例を意図に追加し、親エンティティとすべてのサブエンティティにラベルを付ける必要があります。

チケット予約の例では、`TicketBooking` エンティティとテキスト内のすべてのサブエンティティを使用して、意図内の発話の例にラベルを付けます。

:::image type="content" source="media/luis-concept-features/intent-example-utterances-machine-learning-entity.png" alt-text="ラベルの発話の例":::

### <a name="example-pizza-ordering-app"></a>例: ピザの注文アプリ

2 番目の例では、ピザ レストランのアプリについて考えてみます。このアプリでは、注文を受けているピザの種類の詳細など、ピザの注文を受けます。 注文処理を完了するために、可能であれば、ピザの詳細を抽出する必要があります。

この例の機械学習エンティティは、入れ子になったサブエンティティ、フレーズ リスト、事前構築済みのエンティティ、およびカスタム エンティティにより、さらに複雑になります。

:::image type="content" source="media/luis-concept-features/pizza-order-entity.png" alt-text="ピザの注文エンティティ スキーマ":::

この例では、サブエンティティ レベルとサブエンティティ レベルの子で特徴を使用します。 どのレベルが特徴としてどのような種類のフレーズ リストまたはモデルを取得するかということは、エンティティ設計の重要な部分です。

サブエンティティには、エンティティの検出に役立つ特徴として多くのフレーズ リストを含めることができますが、各サブエンティティには特徴としてモデルが 1 つだけあります。 この[ピザ アプリ](https://github.com/Azure/pizza_luis_bot/blob/master/CognitiveModels/MicrosoftPizza.json)では、これらのモデルは主にリストです。

:::image type="content" source="media/luis-concept-features/intent-example-utterances-machine-learning-entity-pizza.png" alt-text="ラベル付きの発話の例を使用したピザの注文の意図":::

正しくラベル付けされた発話の例は、エンティティがどのように入れ子になっているかを示すように表示されます。 


## <a name="best-practices"></a>ベスト プラクティス

[ベスト プラクティス](luis-concept-best-practices.md)を確認します。

## <a name="next-steps"></a>次のステップ

* アプリ モデルを予測ランタイムで[拡張](schema-change-prediction-runtime.md)します。
* [特徴の追加](luis-how-to-add-features.md)に関するページを参照して、LUIS アプリに特徴を追加する方法を確認します。
