<properties
	pageTitle="データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス"
	description="このトピックでは、お使いのアプリケーションに最適なサービス層を決める際の指針と Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。"
	services="sql-database"
	documentationCenter="na"
	authors="CarlRabeler"
	manager="jhubbard"
	editor="" />


<tags
	ms.service="sql-database"
	ms.devlang="na"
	ms.topic="article"
	ms.tgt_pltfrm="na"
	ms.workload="data-management"
	ms.date="06/30/2016"
	ms.author="carlrab" />

# データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス

## 概要

Microsoft Azure SQL Database には 3 つの[サービス層](sql-database-service-tiers.md)があります。Basic、Standard、Premium です。すべてのサービス層で、Azure SQL Database に与えられたリソースが厳密に分離され、パフォーマンスが予測可能になります。データベースに保証されるスループットは、Premium、Standard、Basic の順に高くなります。

>[AZURE.NOTE] Business サービス層と Web サービス層は 2015 年 9 月で終了しました。詳細については、「[Web および Business エディションの終了に関する FAQ](https://msdn.microsoft.com/library/azure/dn741330.aspx)」を参照してください。既存の Web データベースと Business データベースを新しいサービス層にアップグレードする方法については、「[SQL Database の Web/Business データベースを新しいサービス層にアップグレードする](sql-database-upgrade-server-portal.md)」を参照してください。

この文書では、お使いのアプリケーションに最適なサービス層を決める際の指針と Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。

>[AZURE.NOTE] この記事では、SQL Database のデータベースが 1 台の場合のパフォーマンスについて説明しまするエラスティック データベース プールのパフォーマンス ガイダンスについては、「[エラスティック データベース プールの価格とパフォーマンスに関する考慮事項](sql-database-elastic-pool-guidance.md)」を参照してください。ただし、この記事にある、データベースが 1 つの場合の調整事項の多くは、パフォーマンス上の長所が同じエラスティック プール内のデータベースに適用できます。

**作成者:** Conor Cunningham、Kun Cheng、Jan Engelsberg

**技術校閲者:** Morgan Oslake、Joanne Marone、Keith Elmore、José Batista-neto、Rohit Nayak

## Azure SQL Database の背景

Basic、Standard、Premium サービス層が Azure SQL Database サービスを機能強化するしくみについて理解するには、Azure SQL Database の全体像を把握しておくと役立ちます。Azure SQL Database はいくつかの理由から選択できます。その 1 つは、ハードウェアの購入と取り付けという長期にわたる周期を回避するためです。Azure SQL Database があれば、購買発注の承認、コンピューターの到着、電源と冷却機能のアップグレード、取り付けの完了を待たなくても、データベースをオンザフライで作成したり、切断したりできます。Microsoft はこれらの課題に対処し、各データ センターで集計された需要に基づいてハードウェアを事前プロビジョニングし、アイデアをソリューションに変えるために必要な時間を大幅に短縮します。企業がハードウェアを購入し、手動でデプロイするために必要な時間を数週間または数か月短縮できます。

Microsoft はまた、自動 HA や組み込み管理など、さまざまな自動管理機能を Azure SQL Database に追加しています。

### 自動高可用性 (HA)
 Azure SQL Database はユーザー データベースごとに最低 3 台のレプリカを維持し、レプリカのクォーラムに合わせ、各々の変化を自動的にコミットするロジックを備えています。それにより、1 台のコンピューターが壊れても、データを失うことがありません。さらに、各レプリカは異なるハードウェア ラックに配置され、電力またはネットワーク スイッチを失ってもデータベースは影響を受けません。最後になりますが、コンピューターが失われた場合、レプリカを自動的に再構築するロジックを備えています。コンピューターが正常でなくなった場合でも、好ましい状態のプロパティが自動的に保持されています。こうしたメカニズムにより、今日の高可用性ソリューションの設置と構成に必要な時間のかかるプロセスを回避できます。事前構成済み HA ソリューションをデータに与えることで、従来の手法では難しかったミッションクリティカル データベース ソリューションの構築から悩みの種がまた 1 つ取り除かれます。

### 組み込み管理
 Azure SQL Database はサービスとして実行されます。つまり、データベースごとにアップタイムの目標が定義されており、保守管理のための長期にわたるダウンタイム枠が回避されます。Microsoft はこのサービスにシングルベンダー ソリューションを提供します。つまり、問題が発生した場合、連絡先は 1 社だけになります。Microsoft はまた、継続的にサービスを更新し、機能と容量を追加し、より簡単に更新するための方法を模索しています。更新プログラムは透過的かつダウンタイム枠なしで行われます。つまり、通常の HA フェールオーバー メカニズムに統合されています。それにより、新しい機能が発表された直後にそれを活用できます。一定のダウンタイム枠の間、サーバーのアップグレードを待つ必要がありません。

以上の機能はすべて、あらゆるサービス層で利用できます。自己所有のサーバーを購入し、実行するよりはるかに安く、非常に小規模なプロジェクトでも大金を使わずに Azure の機能を活用できます。

## 各サービス層の違い
Basic、Standard、Premium という 3 つのサービス階層があります。各サービス階層には 1 つまたは複数のパフォーマンス レベルがあり、予測できる方法でデータベースを実行するためのパワーを与えます。このパワーの説明は「[DTU (Database Transaction Unit)](sql-database-technical-overview.md#understand-dtus)」にあります。

Basic サービス層は、各データベースのパフォーマンスを時間単位で予測できるように設計されています。Basic データベースの DTU は、複数の同時要求がない、小規模のデータベースに十分なリソースを与えるように設計されています。

Standard サービス層ではパフォーマンス予測機能が上がっており、ワークグループや Web アプリケーションなど、複数の同時要求があるデータベースに対応します。Standard サービス層のデータベースを使用すると、分単位の予測可能パフォーマンスに基づいてデータベース アプリケーションをサイズ調整できます。

Premium サービス層のパフォーマンスに関する看板機能は、Premium データベースごとに秒単位でパフォーマンスを予測できることです。Premium サービス層を利用すれば、データベースのピーク負荷に基づいてデータベース アプリケーションのサイズを調整し、パフォーマンス差異に起因し、待ち時間が重要な操作で予想以上の時間が小規模クエリにかかる事態をなくすることができます。このモデルは、ピーク時のリソース ニーズ、パフォーマンス差異、クエリ待ち時間を高い確率で予測するために必要なアプリケーションの開発と製品検証の周期を大幅に単純化できます。

Standard と同様に、Premium サービス層では、お客様が希望する分離に基づき、さまざまなパフォーマンス レベルを選択できます。

Standard と Premium のパフォーマンス レベル設定では、必要とする容量の分だけ支払い、作業負荷の変化に合わせ、容量を増やしたり、減らしたりできます。たとえばに、新学期のお買い物シーズンにデータベースの作業負荷がビジー状態になる場合、その期間、データベースのパフォーマンス レベルを増やし、ピーク期間が過ぎたら、減らすなどできます。ビジネスの季節性に合わせてクラウド環境を最適化することで、支払いを最小限に抑えることができます。このモデルはソフトウェア製品のリリース周期にも適しています。テスト チームは、テストの実行中に容量を割り当て、テストが完了したらその容量を解放できます。必要な分の容量に支払い、滅多に使われない専用リソースにかける支出を避けるとき、このような容量要求機能が最適です。Microsoft の多くのお客様に SQL Server と共にご利用いただいている従来の専用ハードウェア モデルに近いパフォーマンスが与えられます。Azure SQL Database でもっとたくさんのアプリケーションをより簡単に実行できます。

サービス層、パフォーマンス レベル、DTU の詳細については、[Azure SQL Database のサービス層とパフォーマンス レベル](sql-database-service-tiers.md)に関するトピックを参照してください。



## サービス層を使用する理由

作業負荷は変化に富み、サービス層の目的は、さまざまなパフォーマンス レベルでパフォーマンスの高度な予測機能を提供することです。データベースのリソース要件が大規模になるお客様は、より専用度の高いコンピューティング環境で作業できます。

### Basic サービス層の使用例:

- **Azure SQL Database の概要**: 多くの場合、開発中のアプリケーションは高いレベルのパフォーマンスを必要としません。Basic データベースは、低価格でデータベースを開発するための理想的な環境となります。
- **ユーザーが 1 人のデータベース**: 1 人のユーザーがデータベースに関連付けられるアプリケーションでは通常、同時性とパフォーマンスの要件が高くなりません。そのような要件のアプリケーションの場合、Basic サービス層が候補となります。

### Standard サービス層の使用例:

- **同時要求が複数になるデータベース**: トラフィックが中程度の Web サイトなど、一部に複数のユーザーにサービスを提供するアプリケーションや、大量のリソースを必要とする部署アプリケーションの場合、Stardard サービス層が候補となります。

### Premium サービス層の使用例:

- **高ピーク負荷**: 操作を完了するためにたくさんの CPU、メモリ、IO を必要とするアプリケーション。たとえば、データベース操作で延長時間に対して複数の CPU コアが使用される場合、Premium データベースが候補となります。
- **多くの同時要求**: トラフィック量が多い Web サイトにサービスを提供するなど、一部のデータベース アプリケーションは多くの同時要求にサービスを提供します。Basic サービス層と Standard サービス層の場合、同時要求の数に制限があります。アプリケーションが多くの接続を必要とするとき、場合によっては、必要な要求の最大数を処理するための予約サイズを選択する必要があります。
- **短い待ち時間**: 一部のアプリケーションでは、データベースから応答時間を最小限にする必要があります。お客様側の操作の一部として所与のストアド プロシージャが呼び出されるとき、99% の割合で 20 ミリ秒以内にその呼び出しから返すことが場合によっては要求されます。この種のアプリケーションでは、Premium データベースを利用すれば、コンピューティング パワーが確実に得られます。

必要となる厳密なレベルはリソース次元ごとのピーク負荷要件に基づきます。アプリケーションによっては 1 つのリソースのわずかな量を利用するものもあれば、要件が大規模になるものもあります。

サービス層の詳細については、[Azure SQL Database のサービス層とパフォーマンス レベル](sql-database-service-tiers.md)に関するトピックを参照してください。

## 課金と価格情報

エラスティック データベース プールは、次の特性ごとに課金されます。

- エラスティック プールは、プールにデータベースがない場合でも、その作成時に課金されます。
- エラスティック プールは 1 時間ごとに課金されます。これは、シングル データベースのパフォーマンス レベルと同じ使用状況測定の頻度です。
- エラスティック プールが新しい eDTU 量にサイズ変更されると、サイズ変更操作が完了するまでは新しい eDTU 量に応じた課金はされません。これは、スタンドアロン データベースのパフォーマンス レベルを変更する場合と同様のパターンに従っています。


- エラスティック プールの価格は、プールの eDTU 数に基づきます。エラスティック プールの価格は、内部のエラスティック データベースの使用率とは関係ありません。
- 価格は、(プールの eDTU 数) x (eDTU あたりの単価) で計算されます。

エラスティック プールの eDTU 単価は、同じサービス階層のスタンドアロン データベースの DTU 単価よりも高くなります。詳細については、「[SQL Database の価格](https://azure.microsoft.com/pricing/details/sql-database/)」をご覧ください。

## サービス層の機能と制限
各サービス層とパフォーマンス レベルは、さまざまな制限やパフォーマンス特性に関連付けられています。次の表は、単一データベースの特性についてまとめたものです。

[AZURE.INCLUDE [SQL DB のサービス階層表](../../includes/sql-database-service-tiers-table.md)]

次のセクションでは、前の表の各領域の詳細を提供します。

### データベースの最大サイズ

**データベースの最大サイズ**はデータベースのサイズ制限です (GB 単位)。

### DTU

**DTU** は Database Transaction Unit の略です。データベースのトランザクションという実際の測定に基づいたデータベースの相対的な能力を表す SQL Database の測定単位です。オンライン トランザクション処理 (OLTP) 要求に一般的な一連の操作で構成され、完全搭載条件で 1 秒間に完了可能なトランザクション数を測定します。DTU の詳細については、「[DTU について](sql-database-technical-overview.md#understand-dtus)」を参照してください。DTU の測定方法に関する詳細については、「[ベンチマークの概要](sql-database-benchmark-overview.md)」を参照してください。

### ポイントインタイム リストア

**ポイントインタイム リストア**は過去の特定の時点にデータベースを復元する機能です。何日前までさかのぼれるかはご利用のサービス層によって決まります。詳細については、「[ポイントインタイム リストア](sql-database-recovery-using-backups.md#point-in-time-restore)」をご覧ください。

### 障害復旧

**障害復旧**は、プライマリ SQL データベースで障害から復旧する機能です。

*geo リストア*はすべてのサービス層で追加料金なしで利用できます。障害の発生時、最も新しい geo 冗長バックアップを利用し、任意の Azure リージョンにデータベースを復元できます。

[アクティブ geo レプリケーション](sql-database-geo-replication-overview.md)にも同様の障害復旧機能が備わっていますが、目標復旧時点 (RPO) は非常に低くなります。たとえば、geo リストアの場合、RPO は 1 時間未満になります (言い換えると、バックアップは最も新しくて 1 時間前になります)。アクティブ geo レプリケーションの場合、RPO は 5 秒未満です。

詳細については、「[ビジネス継続性の概要](sql-database-business-continuity.md)」を参照してください。

### 最大インメモリ OLTP ストレージ
**最大インメモリ OLTP ストレージ**とは、Premium データベースの[インメモリ OLTP プレビュー](sql-database-in-memory.md)で利用できる最大ストレージ容量です。これは、*XTP インメモリ ストレージ*と呼ばれることもあります。Azure クラシック ポータルまたは **sys.dm\_db\_resource\_stats** ビューを利用し、メモリ内ストレージの使用を監視できます。監視の詳細については、「[OLTP インメモリ ストレージを監視する](sql-database-in-memory-oltp-monitoring.md)」を参照してください。

>[AZURE.NOTE] メモリ内 OLTP プレビューは現在のところ、単一データベースでのみサポートされており、エラスティック データベース プールのデータベースではサポートされていません。

### 最大同時要求数

**最大同時要求数**は、データベースで同時に実行される同時ユーザー/アプリケーション要求の最大数です。同時要求の数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

	SELECT COUNT(*) AS [Concurrent_Requests]
	FROM sys.dm_exec_requests R

オンプレミス SQL Server データベースの作業負荷を分析している場合、分析している特定のデータベースでフィルター処理するようにこのクエリを変更してください。たとえば、「MyDatabase」という名前のオンプレミス データベースがある場合、次の Transact-SQL クエリはそのデータベースの同時要求数を返します。

	SELECT COUNT(*) AS [Concurrent_Requests]
	FROM sys.dm_exec_requests R
	INNER JOIN sys.databases D ON D.database_id = R.database_id
	AND D.name = 'MyDatabase'

これはある時点のスナップショットにすぎないことに注意してください。作業負荷をさらに詳しく理解するには、長期間のたくさんのサンプルを集め、同時要求要件を理解する必要があります。

### 最大同時ログイン数

**最大同時ログイン数**はデータベースへのログインを同時に試行するユーザーまたはアプリケーションの数の制限です。これらのクライアントで同じ接続文字列を使用している場合でも、サービスは各ログインを認証することに注意してください。つまり、10 人のユーザーが同じユーザー名とパスワードでデータベースに同時に接続した場合、10 件の同時ログインが発生します。この制限は、ログインと認証の期間のみに適用されます。そのため、同じ 10 人のユーザーがデータベースに順番に接続した場合、同時ログイン数が 1 より大きくなることはありません。

>[AZURE.NOTE] この制限は現在のところ、エラスティック データベース プールのデータベースには適用されません。

同時ログイン数または履歴を表示するクエリや DMV はありません。ユーザーやアプリケーションのパターンを分析すれば、ログインの頻度を理解できます。テスト環境で実世界の負荷を実行し、この上限やこのトピックで説明されている他の上限に達していないことを確認できます。

### 最大セッション数

**最大セッション**は、データベースに開いている同時接続の最大数です。ユーザーがログインすると、セッションが確立され、ログアウトするか、セッションがタイムアウトになるまでアクティで名状態を維持します。現在のアクティブなセッション数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

	SELECT COUNT(*) AS [Sessions]
	FROM sys.dm_exec_connections

オンプレミス SQL Server の作業負荷を分析している場合、特定のデータベースに焦点を当てるようにクエリを変更してください。それにより、そのデータベースを Azure SQL Database に移動する場合、そのデータベースに考えられるセッション ニーズを決定できます。

	SELECT COUNT(*)  AS [Sessions]
	FROM sys.dm_exec_connections C
	INNER JOIN sys.dm_exec_sessions S ON (S.session_id = C.session_id)
	INNER JOIN sys.databases D ON (D.database_id = S.database_id)
	WHERE D.name = 'MyDatabase'

ここでも、これらのクエリはある時点の検数を返します。つまり、長期間、複数のサンプルを集めることで、セッション使用を正確に理解できます。

SQL Database 分析の場合、**sys.resource\_stats** にクエリを実行し、セッションの過去の統計値を取得することもできます。**active\_session\_count** 列を利用します。次の監視セクションで、このビューの利用に関する詳細を提供します。

## リソース使用の監視
SQL データベースのリソース使用をそのサービス層との関連で監視できるビューが 2 つあります。

- [sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx)
- [sys.resource\_stats](https://msdn.microsoft.com/library/dn269979.aspx)

>[AZURE.NOTE] Azure クラシック ポータルを使用し、リソース使用を表示することもできます。たとえば、「[サービス層 - パフォーマンスの監視](sql-database-service-tiers.md#monitoring-performance)」を参照してください。

### sys.dm\_db\_resource\_stats の使用
[sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx) ビューは各 SQL データベースにあり、サービス層との関連で最近リソース使用率データを提供します。CPU、データ IO、ログ書き込み、メモリの平均 (%) が 15 秒ごとに記録され、1 時間保持されます。

このビューにはリソース使用率が詳細に表示されるので、現状の分析やトラブルシューティングの場合、最初に「**sys.dm\_db\_resource\_stats**」を利用してください。たとえば、次のクエリは、この 1 時間の現在のデータベースの平均リソース使用率と最大リソース使用率を表示します。

	SELECT  
	    AVG(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
	    MAX(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
	    AVG(avg_data_io_percent) AS 'Average Data IO In Percent',
	    MAX(avg_data_io_percent) AS 'Maximum Data IO In Percent',
	    AVG(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
	    MAX(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
	    AVG(avg_memory_usage_percent) AS 'Average Memory Usage In Percent',
	    MAX(avg_memory_usage_percent) AS 'Maximum Memory Usage In Percent'
	FROM sys.dm_db_resource_stats;  

その他のクエリについては、[sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx) の例を参照してください。

### sys.resource\_stats の使用

**マスター** データベースの [sys.resource\_stats](https://msdn.microsoft.com/library/dn269979.aspx) ビューには、特定のサービス層とパフォーマンス レベルで SQL データベースを監視するための追加情報があります。データは 5 分ごとに集められ、約 35 日間保存されます。このビューは、SQL データベースの過去のリソース使用率を長期にわたり分析する際に役立ちます。

次のグラフは、Premium データベースの CPU リソース利用率を示しています (P2 パフォーマンス レベル、1 週間における毎時間の利用率)。このグラフは月曜日始まり、5 営業日を示し、週末ではアプリケーションの活動が大幅に減っていることがわかります。

![SQL DB リソース使用率](./media/sql-database-performance-guidance/sql_db_resource_utilization.png)

このデータから、このデータベースのピーク CPU 負荷は現在のところ、P2 パフォーマンス レベルに対して 50% をわずかに超える CPU 利用率になっていることがわかります (火曜日の昼)。アプリケーションのリソース プロファイルにおいて CPU が支配的要因になる場合、P2 が作業負荷に常に対処できる最適なパフォーマンス レベルであると決定できます。アプリケーションで時間と共に増加が予測される場合、上限に到達しないように、余分にリソース バッファーを考慮すると合理的です。特に待ち時間が重要になる環境において (データベース呼び出しの結果に基づいて Web ページを表示するアプリケーションをサポートするデータベースなど)、パワーが足りないため、要求を効果的に処理できないデータベースに起因して、お客様に見えるエラーが発生する事態を回避できます。

アプリケーションの種類が異なれば、同じグラフの解釈が異なることにも注意してください。たとえば、あるアプリケーションが給与データを毎日処理し、同じグラフが与えられるとき、場合によっては、この種の「一括ジョブ」モデルは P1 パフォーマンス レベルで何の問題もありません。P1 パフォーマンス レベルの DTU は 100 で、P2 パフォーマンス レベルの DTU は 200 です。つまり、P1 パフォーマンス レベルのパフォーマンスは P2 パフォーマンス レベルの半分となります。そのため、P2 の 50% CPU 使用は P1 の 100% CPU 使用に等しくなります。アプリケーションにタイムアウトがない限り、当日に完了するのであれば、大きなジョブに 2 時間かかっても 2.5 時間かかっても問題ないでしょう。このカテゴリのアプリケーションは、おそらく、P1 パフォーマンス レベルを利用します。その日の中でリソース利用率が低くなる時間帯があるという事実を利用できます。つまり、「大きなピーク」があっても、そのような時間帯の 1 つに広がることがあります。ジョブを毎日定刻で完了できる限り、P1 パフォーマンス レベルがこのようなアプリケーションに最適化もしれません (さらにコストを削減します)。

Azure SQL Database では、各サーバーの**マスター** データベースの **sys.resource\_stats** ビューにアクティブなデータベース別のリソース利用情報が公開されます。テーブルのデータは 5 分おきに集計されます。Basic、Standard、Premium サービス層では、データをテーブルに表示するのに 5 分以上かかります。つまり、このデータはほぼリアルタイムの分析より過去の分析に適しています。**sys.resource\_stats** ビューに問い合わせると、データベースの最近の履歴が表示され、選択した予約で必要なときに望ましいパフォーマンスが届けられたか検証されます。

>[AZURE.NOTE] 次の例で **sys.resource\_stats** にクエリを実行するために、論理 SQL Database サーバーの**マスター** データベースに接続する必要があります。

次の例は、このビューのデータが公開されるしくみを示しています。

	SELECT TOP 10 *
	FROM sys.resource_stats
	WHERE database_name = 'resource1'
	ORDER BY start_time DESC

![システム リソース統計](./media/sql-database-performance-guidance/sys_resource_stats.png)

次の例では、**sys.resource\_stats** カタログ ビューを利用し、SQL データベースのリソース使用率を理解するためのさまざまな方法を示します。

>[AZURE.NOTE] **sys.resource\_stats** の列の一部は現在の V12 データベースで変更されています。そのため、次の例のサンプル クエリはエラーを生成することがあります。このトピックの今後の更新では、この問題に対処する新しいバージョンのクエリを紹介します。

1. たとえば、「userdb1」という名前のデータベースの先週のリソース利用率を調べる場合、次のクエリを実行できます。

		SELECT *
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND
		      start_time > DATEADD(day, -7, GETDATE())
		ORDER BY start_time DESC;

2. 作業負荷がパフォーマンス レベルに適合する様子を評価するために、さまざまなリソース指標 (CPU、読み取り、書き込み、ワーカー数、セッション数) で分析する必要があります。次は sys.resource\_stats を利用したクエリを修正したものです。平均とリソース指標の最大値を報告します。

		SELECT
		    avg(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
		    max(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
		    avg(avg_data_io_percent) AS 'Average Physical Data IO Utilization In Percent',
		    max(avg_data_io_percent) AS 'Maximum Physical Data IO Utilization In Percent',
		    avg(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
		    max(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
		    avg(max_session_percent) AS 'Average % of Sessions',
		    max(max_session_percent) AS 'Maximum % of Sessions',
		    avg(max_worker_percent) AS 'Average % of Workers',
		    max(max_worker_percent) AS 'Maximum % of Workers'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

3. 各リソース指標の平均と最大値に関する上記の情報があれば、選択したパフォーマンス レベルに作業負荷が適合する様子を評価できます。ほとんどの場合、sys.resource\_stats からの平均値が目標サイズに対する有効な基準となります。これを主要なものさしとしてください。たとえば、S2 パフォーマンス レベルで Standard サービス層を使用しているとき、CPU、読み取り、書き込みの平均利用率が 40% を下回り、ワーカーの平均数が 50 を下回り、セッションの平均数が 200 を下回る場合、作業負荷は S1 パフォーマンス レベルが最適かもしれません。データベースがワーカーとセッションの制限内に収まるかどうかが簡単にわかります。CPU、読み取り、書き込みに関して、データベースが下位のパフォーマンス レベルに適合するかどうかを確認するには、下位パフォーマンス レベルの DTU 数を現在のパフォーマンス レベルの DTU 数で割り、その計算結果に 100 を掛けます。

	**S1 DTU / S2 DTU * 100 = 20 / 50 * 100 = 40**

	この結果は、2 つのパフォーマンス レベルの間の相対的パフォーマンス差異を百分率で表したものになります。利用率がこの割合を超えていない場合、その作業負荷には下位のパフォーマンス レベルが適しているかもしれません。ただし、リソース利用率の値を全範囲で見て、割合の観点で、どのくらいの頻度でデータベースの作業負荷が下位のパフォーマンス レベルに適合するかを判断する必要もあります。次のクエリは、上で計算された 40% のしきい値に基づき、リソース次元別の適合率を出力します。

		SELECT
		    (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data IO Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

	データベースのサービス レベル目標 (SLO) に基づき、作業負荷が下位のパフォーマンス レベルに適合するかどうかを判断できます。データベース作業負荷 SLO が 99.9% で、上のクエリが 3 つすべてのリソース次元に対して 99.9 以上の値を返す場合、その作業負荷はおそらく下位のパフォーマンス レベルに適合します。

	適合率を見ると、SLO を満たすために上位のパフォーマンス レベルに移るべきかどうかもわかります。たとえば、「userdb1」は先週の次の使用率を示しています。

	| 平均 CPU パーセント | 最大 CPU パーセント |
	|---|---|
	| 24\.5 | 100\.00 |

	平均 CPU はパフォーマンス レベルの上限の約 4 分の 1 になり、データベースのパフォーマンス レベルにうまく適合でしょう。ただし、最大値はデータベースがパフォーマンス レベルの上限に到達することを示します。次に上位のパフォーマンス レベルに移動する必要がありますか。 この場合も、作業負荷が 100% に到達する回数を見て、それをデータベース作業負荷 SLO と比較する必要があります。

		SELECT
		(COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent’
		,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data IO Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

	上記のクエリが 3 つのリソース次元のいずれにも 99.9% 未満の値を返す場合、次に上位のパフォーマンス レベルに移動するか、アプリケーションの調整手法を利用し、Azure SQL Database の負荷を減らすことを検討してください。

4. 上の演習では、将来的に予測される作業負荷の増加も考慮する必要があります。

## アプリケーションの調整

従来のオンプレミス SQL Server では、初回の容量計画のプロセスは、多くの場合、アプリケーションを本稼働実行するプロセスとは分けられます。言い換えると、SQL Server を実行するためのハードウェアと関連ライセンスの購入は前もって行われ、パフォーマンス調整は後で行われます。Azure SQL Database を使用するとき、通常、アプリケーションの実行と調整のプロセスを交互に扱うことが推奨されます (毎月請求されるため、おそらくはこれが望ましくなります)。オンデマンド容量の支払いモデルでは、アプリケーションの将来的な成長計画の推測に基づいてハードウェアに大規模な過剰プロビジョニングを行う代わりに (はるか先の将来まで予測する必要があるため、多くの場合、この方法は正しくありません)、現在必要とされる最小リソースを使用するようにアプリケーションを調整できます。アプリケーションを調整せず、代わりにハードウェア リソースを過剰プロビジョニングするお客様もいることにご留意ください。そのような手法は、ある重要なアプリケーションの利用が集中する期間にそのアプリケーションを変更が望まれない場合に有効です。アプリケーションを調整することで、リソース要件を最小限に抑え、Azure SQL Database のサービス層を使用するとき、毎月の請求額を抑えます。

### アプリケーションの特性

サービス層はアプリケーションのパフォーマンスを安定させ、予測精度を高めるように設計されています。この機能を最大限に活用するために、アプリケーションの調整方法には最良事例がいくつか存在します。上位のパフォーマンス レベルまたはサービス層に切り替えることで、多くのアプリケーションでパフォーマンスが大幅に上がりますが、さらに調整しなければ効果が出ない場合もあります。アプリケーションに次の特性がある場合、Azure SQL Database の使用時のパフォーマンスを改善する目的で、追加のアプリケーション調整も考慮してください。

- **「chatty (煩雑な)」動作に起因してパフォーマンスが低下するアプリケーション**: ネットワークの待ち時間が重要となるデータ アクセス操作が過度に発生するアプリケーションがこれに該当します。そのようなアプリケーションでは、場合によっては、Azure SQL Database にデータ アクセスする操作の数を減らす修正が必要になります。たとえば、アドホック クエリをまとめて処理したり、ストアド プロシージャにクエリを移動したりするなどの手法でアプリケーションが改善される可能性があります。詳細については、後続の「クエリの一括処理」セクションを参照してください。
- **集中的な作業負荷を 1 台のコンピューター全体で処理できないデータベース**: Premium の最高レベルのパフォーマンスのリソースを超えるデータベースは最良の候補ではありません。このようなデータベースは、作業負荷をスケールアウトすることで改善することがあります。詳細については、後続の「データベース間のシャーディング」セクションと「機能的パーティション分割」セクションを参照してください。
- **最適ではないクエリを含むアプリケーション**: 特にデータ アクセス層の、クエリが十分に調整されていないアプリケーションの場合、上位のパフォーマンス レベルを選択しても期待したような効果が得られない可能性があります。たとえば、WHERE 句がない、インデックスが足りない、統計が古いクエリです。このようなアプリケーションの場合、クエリ パフォーマンスの標準的な調整方法で効果が得られます。詳細については、後続の「インデックスの不足」セクションと「クエリの調整/ヒント」を参照してください。
- **データ アクセス設計が最適ではないアプリケーション**: デッドロックなど、データ アクセスの同時性問題が内在するアプリケーションの場合、上位のパフォーマンス レベルを選択しても効果が得られないことがあります。アプリケーションの開発者は、Azure Caching サービスや他のキャッシング技術を利用し、クライアント側でデータをキャッシュすることで Azure SQL Database に対するラウンドトリップを減らすことを検討してください。後続の「アプリケーション層のキャッシング」セクションを参照してください。

## 調整技法
このセクションでは、 Azure SQL Database を調整し、アプリケーションから最良のパフォーマンスを引き出し、可能な限り下位のパフォーマンス レベルで実行するための手法について説明します。多くの手法が従来の SQL Server 調整の最良事例と同じものですが、一部は Azure SQL Database に固有です。従来の SQL Server 手法を拡大し、Azure SQL Database に応用することもできます。その場合、データベースに利用されるリソースを調べ、さらに細かく調整するべき領域を見つけます。

### Query Performance Insight と SQL Database Advisor
SQL Database は Azure ポータルでデータベースのパフォーマンス問題を分析し、解消するための 2 つのツールを提供します。

- [Query Performance Insight](sql-database-query-performance.md)
- [SQL Database Advisor](sql-database-advisor.md)

各ツールの概要とその使用方法については、前のリンクを参照してください。インディクスの不足とクエリの調整に関する次の 2 つのセクションでは、同様のパフォーマンス問題を手動で見つけ、修正するためのその他の方法を提供します。最初にポータルのツールを試し、より効率的に診断し、問題を解消することをお勧めします。特別なケースで手動の調整方法を利用してください。

### インデックスの不足
OLTP データベースのパフォーマンスの一般的問題は物理的なデータベース設計に関連します。多くの場合、データベース スキーマは (負荷またはデータ量の) 規模の面で試験することなく設計され、出荷されます。残念ながら、クエリ プランのパフォーマンスは小規模で許容される場合がありますが、実稼働レベルのデータ量に直面したときに大幅が低下する可能性があります。この問題の最も一般的な原因は、適切なインデックスがなく、クエリのフィルターまたはその他の制約を満たせないことにあります。多くの場合、これはインデックス シークで足りるとき、テーブル スキャンとして現れます。

次の例では、シークで足りるとき、選択したクエリ プランにスキャンが含まれます。

	DROP TABLE dbo.missingindex;
	CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO dbo.missingindex(col2) VALUES (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION;
	GO
	SELECT m1.col1
	FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
	WHERE m1.col2 = 4;

![インデックス不足のクエリ プラン](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

Azure SQL Database には、データベース管理者が一般的なインデックス不足状態を発見し、修正するときに役立つ機能があります。Azure SQL Database に組み込まれている動的管理ビュー (DMV) には、クエリ コンパイルが表示されます。クエリを実行するために見積もられたコストをクエリで大幅に削減できる場合があります。クエリの実行中、各クエリ プランが実行される頻度と、実行クエリ プランとそのインデックスが存在した想定クエリ プランの間で見積もられるギャップが追跡記録されます。それにより、データベース管理者は、所与のデータベースとその実際の作業負荷に対して、全体的な作業負荷コストを改善できる可能性がある物理的データベース設計変更をすばやく推測できます。

>[AZURE.NOTE] DMV を利用してインディクスの不足を見つける前に、「[Query Performance Insight と SQL Database Advisor](#query-performance-insight-and-index-advisor)」のセクションをご覧ください。

次のクエリは潜在的なインデックス不足の評価に使用できます。

	SELECT CONVERT (varchar, getdate(), 126) AS runtime,
	    mig.index_group_handle, mid.index_handle,
	    CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
	            (migs.user_seeks + migs.user_scans)) AS improvement_measure,
	    'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
	              CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
	              (' + ISNULL (mid.equality_columns,'')
	              + CASE WHEN mid.equality_columns IS NOT NULL
	                          AND mid.inequality_columns IS NOT NULL
	                     THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
	              + ')'
	              + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
	    migs.*,
	    mid.database_id,
	    mid.[object_id]
	FROM sys.dm_db_missing_index_groups AS mig
	INNER JOIN sys.dm_db_missing_index_group_stats AS migs
	    ON migs.group_handle = mig.index_group_handle
	INNER JOIN sys.dm_db_missing_index_details AS mid
	    ON mig.index_handle = mid.index_handle
	ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

この例では、次のインデックスが提案されました。

	CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

作成後、その同じ SELECT ステートメントが今度は、スキャンの代わりに、シークを使用する別の計画を選択します。次のクエリ プランのように、より効率的に実行されます。

![インデックスが修正されたクエリ プラン](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

重要なことは、共有される商品システムの IO 容量は一般的に専用サーバー コンピューターより限られるということです。そのため、不必要な IO を最小限に抑え、Azure SQL Database のサービス層の各パフォーマンス レベルの DTU 内でシステムを最大限に活用することが有効です。物理データベースに適切な設計を選択すると、個々のクエリの待ち時間とスケール単位で処理可能な同時要求のスループットを大幅に改善し、クエリを満たすために必要なコストを最小限に抑えることができます。インデックス不足の DMV に関する詳細については、「[sys.dm\_db\_missing\_index\_details](https://msdn.microsoft.com/library/ms345434.aspx)」を参照してください。

### クエリ調整/ヒント
Azure SQL Database 内のクエリ オプティマイザーは従来の SQL Server クエリ オプティマイザーと非常に似ています。クエリを調整し、クエリ オプティマイザーの推論モデル制約を理解する最良事例の多くは Azure SQL Database にも適用されます。Azure SQL Database のクエリを調整すると、総リソース要求を減らせる場合があります。また、下位のパフォーマンス レベルで実行できるため、調整されている場合に比べ、低コストでアプリケーションを実行できます。

SQL Server で観察される共通例で、Azure SQL Database にも適用できるものの 1 つは、コンパイル中、より最適なプランを作成するためにパラメーターを「sniffed (探り出す)」方法に関連します。パラメーター スニッフィングは、より最適なクエリ プランを作成する目的でクエリをコンパイルするとき、クエリ オプティマイザーがパラメーターの現在値を考慮するプロセスです。この方針で、多くの場合、パラメーター値に関する知識なしでコンパイルされたプランより大幅に速いクエリ プランが作成されますが、現在の SQL Server/Azure SQL Database の動作は完全ではありません。パラメーターを探り出せない場合があります。また、パラメーターが検索されても、ある作業負荷のフルセットのパラメーター値に対し、生成されたプランは次善となる場合があります。Microsoft はクエリ ヒント (指示) を追加しています。それを利用すれば、意図をより慎重に指定し、パラメーター スニッフィングの既定動作を上書きできます。多くの場合、SQL Server/Azure SQL Database の既定の動作ではお客様の作業負荷に完全に対応できない問題を解消するのにヒントが役立ちます。

次の例は、パフォーマンス要件とリソース要件の両方で次善となるプランをクエリ プロセッサが生成するしくみと、Azure SQL Database でクエリ ヒントを利用し、クエリ ランタイムを短縮し、リソース要件を減らすしくみを示しています。

次はサンプル セットアップです。

	DROP TABLE psptest1;
	CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));

	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO psptest1(col2) values (1);
	    INSERT INTO psptest1(col2) values (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION
	CREATE INDEX i1 on psptest1(col2);
	GO

	CREATE PROCEDURE psp1 (@param1 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1
	    WHERE col2 = @param1
	    ORDER BY col2;
	END
	GO

	CREATE PROCEDURE psp2 (@param2 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
	    ORDER BY col2
	    OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
	END
	GO

	CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
	GO

このセットアップ コードでは、傾斜データ分布を含むテーブルが作成されます。最適なクエリ プランは、選択されているパラメーターによって異なります。残念ながら、プラン キャッシング動作は常に最も一般的なパラメーター値に基づいてクエリを再コンパイルするとは限りません。つまり、別のプランのほうが平均的プランとしてより良い選択になる場合でも、次善プランがキャッシュされ、多くの値に使用される可能性があります。次に、そのうちの 1 つに特殊なクエリ ヒントが含まれることを除いて、同じストアド プロシージャが 2 つ作成されます (理由は後続で説明されます)。

**例 (パート 1):**

	-- Prime Procedure Cache with scan plan
	EXEC psp1 @param1=1;
	TRUNCATE TABLE t1;

	-- Iterate multiple times to show the performance difference
	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp1 @param1=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

**例 (パート 2 – この部分を試す前に 10 分間お待ちください。結果的に生成されるテレメトリ データが明らかに変わります。):**

	EXEC psp2 @param2=1;
	TRUNCATE TABLE t1;

	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp2 @param2=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

この例の各パートで、(テスト データ セットに十分な関連負荷を生成するために) パラメーター化された挿入ステートメントが 1000 回実行されます。ストアド プロシージャを実行するとき、クエリ プロセッサは、その最初のコンパイル中にプロシージャに渡されるパラメーター値を調べます (これがパラメーターの「スニッフィング」です)。結果的に生成されたプランがキャッシュされ、パラメーター値が異なる場合でも、後の呼び出しで使用されます。その結果、最適なプランが使用されないことがあります。クエリが最初にコンパイルされたときのケースではなく、平均的ケースに最適なプランを選択するようにお客様がオプティマイザーを調整しなければならないこともあります。この例では、最初のプランは、パラメーターに一致する各値を見つけるためにすべての行を読み込む「スキャン」プランを生成します。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_1.png)

値 1 でプロシージャを実行したので、結果的に生成されたプランは 1 に対して最適になるが、テーブルにあるその他すべての値に対しては次善となります。各プランを無作為に選択した場合、結果として得られる動作は希望の動作とは異なるものになります。そのプランがゆっくり実行され、多くのリソースを使用するためです。

「SET STATISTICS IO ON」でテストを実行すると、内部でこの例で行われた論理スキャン作業が表示されます。このプランで 1148 件の読み取りが行われたことがわかります (平均的なケースで返される行がたった 1 つの場合、これは効率的ではありません)。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_2.png)

例の 2 つ目の部分では、クエリ ヒントを利用し、コンパイル プロセス中に特定の値を使用するようにオプティマイザーに伝えます。この場合、パラメーターとして渡される値を無視し、代わりに「UNKNOWN」を想定するようにクエリ プロセッサに強制します。つまり、テーブルの平均頻度を持つ値です (傾斜を無視します)。結果的に生成されるプランはシーク ベースのプランであり、例のパート 1 のプランに比べて概して速く、使用するリソースが少なくなります。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_3.png)

この影響は **sys.resource\_stats** テーブルを調べることでわかります (注記: テストを実行してからデータがテーブルに入力されるまでの間に遅延があります)。この例の場合、パート 1 は 22:25:00 の時間枠で実行され、パート 2 は 22:35:00 の時間枠で実行されます。早いほうの時間枠で遅いほうの時間枠に比べてその時間枠のリソースがより多く使用されることに注意してください (プランの効率性改善に起因)。

	SELECT TOP 1000 *
	FROM sys.resource_stats
	WHERE database_name = 'resource1'
	ORDER BY start_time DESC

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_4.png)

>[AZURE.NOTE] ここで使用されている例は意図的に小規模にしてありますが、次善パラメーターの影響は、特に大規模データベースで、相当大きくなります。極端なところ、速い場合は数秒単位、遅い場合は数時間単位になります。

**sys.resource\_stats** を調べれば、あるテストのリソースが他のテストに比べてより多いリソースを使用するか、より少ないリソースを使用するかがわかります。データを比較するとき、**sys.resource\_stats** ビューで同じ 5 分の時間枠グループに入らないように十分な時間でテストを分けます。また、演習の目標は使用される合計リソースを最小限に抑えることであり、ピーク リソース自体を最小限に抑えることではありません。一般的に、待ち時間のコードの一部を最適化すると、リソース使用量も減ります。アプリケーションで検討される変更は実際に必要なものであることを確認し、クエリ ヒントの利用時、アプリケーション利用者のカスタマー エクスペリエンスに悪影響を与えないようにしてください。

作業負荷に一連の繰り返しクエリが含まれる場合、大抵、そのようなプラン選択肢の最適性を記録し、検証すると有効です。おそらく、データベースをホストするために必要な最小リソース サイズ単位を推進します。検証後、折に触れてこれらのプランを調べれば、劣化を回避できます。クエリ ヒントの詳細については、「[クエリ ヒント (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx)」を参照してください。

### データベース間のシャーディング
Azure SQL Database は汎用ハードウェアで実行されるため、従来のオンプレミス SQL Server インストールと比べ、1 台のデータベースに対して容量限度が一般的に低くなります。そのため、Azure SQL Database でデータベース操作が 1 台のデータベースの上限に収まらないとき、多くのお客様がシャーディング手法を利用し、複数のデータベースにデータベース操作を分散しています。現在、Azure SQL Database でシャーディング手法を利用するお客様の大半は、1 つの次元のデータを複数のデータベースで分割します。この手法は、OLTP アプリケーションは、多くの場合、スキーマ内の 1 行またはほんの数行からなるグループにのみ適用されるトランザクションを実行することを理解した上で行われます。

>[AZURE.NOTE] SQL Database にシャーディングを支援するライブラリが追加されました。詳細については、「[エラスティック データベース クライアント ライブラリの概要](sql-database-elastic-database-client-library.md)」をご覧ください。

たとえば、(SQL Server 付属の従来のサンプル Northwind データベースのように) あるデータベースに顧客、注文、注文詳細が含まれる場合、注文と注文詳細が関連している顧客をグループにまとめ、1 つのデータベース内に留めることで、このデータを複数のデータベースに分割できます。アプリケーションはデータベース間で顧客を分割し、効果的に負荷を分散します。それにより、お客様がデータベース サイズの上限を回避できるだけでなく、個々のデータベースがその DTU に収まる限り、各パフォーマンス レベルの上限を大幅に超える作業負荷を Azure SQL Database で処理できます。

データベース シャーディングはソリューションの総リソース容量を減らしませんが、この手法は複数のデータベースにまたがる大規模ソリューションで非常に効果的であり、各データベースを異なるパフォーマンス レベルで実行し、リソース要件の高い、大規模で「効果的な」データベースをサポートできます。

### 機能的パーティション分割
SQL Server ユーザーは、多くの場合、1 台のデータベースのさまざまな機能を組み合わせます。たとえば、アプリケーションに店舗の在庫を管理するロジックが含まれている場合、そのデータベースには、在庫に関連付けられているロジック、購買発注の追跡、ストアド プロシージャ、月末報告を管理するインデックス付きビュー/具体化されたビュー、その他の機能が含まれていることがあります。この手法には、バックアップなどのデータベース操作を簡単に管理できるという利点がありますが、アプリケーションの機能全体でピーク負荷を処理できるようにハードウェアのサイズを調整する必要もあります。

Azure SQL Database 内で使用されるスケールアウト アーキテクチャ内では、多くの場合、アプリケーションの異なる機能を複数のデータベースに分割すると有効です。それにより、各々を個別にスケール調整できます。管理者は、アプリケーションがビジー状態になったとき (また、データベースの負荷が増えたとき)、アプリケーション内の機能ごとにパフォーマンス レベルを個別選択できます。制約はありますが、複数のコンピューター間で負荷を分散することで、アプリケーションの処理能力を 1 台の汎用コンピューター以上に上げることがこのアーキテクチャで可能になります。

### クエリの一括処理
頻繁にその場限りでクエリを実行し、データにアクセスするアプリケーションの場合、アプリケーション層と Azure SQL Database 層の間のネットワーク通信の応答に相当の時間が費やされます。アプリケーションと Azure SQL Database が同じデータ センターに存在する場合でも、データ アクセス操作の数が多ければ、この 2 つの間のネットワーク待ち時間が長くなります。このようなデータ アクセス操作のネットワーク ラウンド トリップを減らすために、アプリケーションの開発者は、アドホック クエリを一括処理するか、ストアド プロシージャにコンパイルすることを検討してください。アドホック クエリを一括処理すると、複数のクエリを 1 つの大きなバッチとして 1 回のトリップで Azure SQL Database に送信できます。アドホック クエリをストアド プロシージャにコンパイルすると、一括処理と同じ結果が得られます。ストアド プロシージャを利用する場合、同じストアド プロシージャを後で実行するときのために、クエリ プランが Azure SQL Database にキャッシュされる機会が増えるという利点もあります。

一部のアプリケーションでは、書き込みが集中します。場合によっては、書き込みを一括処理する方法を検討することで、データベースの IO 総負荷を減らせることがあります。それは、多くの場合、ストアド プロシージャやアドホック バッチ内で、自動コミット トランザクションの代わりに、明示的トランザクションを使用するのと同じくらい単純になります。利用できるさまざまな手法の評価は「[Azure の SQL Database アプリケーションの一括処理手法](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx)」にあります。独自の作業負荷を試し、一括処理に最適なモデルを探してください。モデルによっては、トランザクションの整合性がわずかに変わることがあります。リソース使用を最小限に抑える作業負荷を見つけるには、整合性と性能の適度なバランスを見つける必要があります。

### アプリケーション層のキャッシュ
データベース アプリケーションによっては、作業負荷の大半が読み取りになります。キャッシュ層を利用すれば、データベースの負荷を減らすことができます。また、Azure SQL Database を利用するデータベースを支援するために必要なパフォーマンス レベルを下げられる可能性もあります。[Azure Redis Cache](https://azure.microsoft.com/services/cache/) を利用すれば、読み取り集中型の作業負荷に対して、データを 1 回読み込み (あるいは、構成方法によっては、アプリケーション層コンピューターごとに 1 回)、Azure SQL Database の外にそのデータを保存することができます。それにより、データベースの負荷 (CPU と読み取り IO) を減らすことができますが、トランザクションの整合性が影響を受けます。キャッシュから読み込まれるデータはデータベースのデータよりも古いことがあるためです。多くのアプリケーションでは一定の不整合が許容されますが、すべての作業負荷で許容されるとは限りません。アプリケーション層のキャッシュ手法を採用する前に、あらゆるアプリケーション要件を完全に理解してください。

## まとめ

Azure SQL Database のサービス層を利用すると、クラウドに構築する各種アプリケーションの水準を上げることができます。さらにアプリケーションの調整も頻繁に行うことで、アプリケーションのパフォーマンスが強力かつ予測可能となります。このドキュメントでは、特定のパフォーマンス レベルに問題なく適合するようにデータベースのリソース利用を最適化するための推奨手法について説明します。クラウド モデルにおいては調整は継続的に実施するものであり、それにより、各種のサービス層とそのパフォーマンス レベルにおいて、管理者はパフォーマンスを最大限に引き出し、同時に Microsoft Azure Platform のコストを最小限に抑えることができます。

<!---HONumber=AcomDC_0803_2016-->