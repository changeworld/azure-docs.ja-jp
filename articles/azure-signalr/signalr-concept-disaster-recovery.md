---
title: Azure SignalR Service の回復性とディザスター リカバリー
description: 複数の SignalR サービス インスタンスをセットアップして回復性とディザスター リカバリーを実現する方法についての概要
author: chenkennt
ms.service: signalr
ms.topic: conceptual
ms.date: 03/01/2019
ms.author: kenchen
ms.openlocfilehash: cf0f345b0fbf9fea2512f72c1996c9a1597cc0cd
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/27/2020
ms.locfileid: "73747649"
---
# <a name="resiliency-and-disaster-recovery"></a>回復性とディザスター リカバリー

回復性とディザスター リカバリーは、各種オンライン システムに共通の要件です。 Azure SignalR Service では、既に 99.9% の可用性が保証されていますが、それはあくまでリージョンごとのサービスです。
サービス インスタンスは常に 1 つのリージョンで実行されており、リージョン全体の機能が停止しても、他のリージョンにフェールオーバーされることはありません。

その代わり、このサービスの SDK には、複数の SignalR サービス インスタンスをサポートする機能があり、そのいくつかが利用できなくなったときに自動的に他のインスタンスに切り替わります。
この機能を利用すれば、障害発生時に復旧できるようになりますが、適切なシステム トポロジをご自分でセットアップする必要が生じます。 このドキュメントでは、その方法について説明します。

## <a name="high-available-architecture-for-signalr-service"></a>SignalR サービスの高可用性アーキテクチャ

リージョンをまたぐ回復性を SignalR サービスに確保するためには、複数のサービス インスタンスを異なるリージョンにセットアップする必要があります。 そうすることで、1 つのリージョンがダウンしても、その他のリージョンをバックアップとして使用することができます。
複数のサービス インスタンスをアプリ サーバーに接続する際には、プライマリとセカンダリという 2 つのロールが存在します。
プライマリは、オンライン トラフィックを処理するインスタンスであり、セカンダリは、完全に機能している状態ではありますが、プライマリのバックアップ インスタンスです。
この SDK の実装では、ネゴシエートからはプライマリ エンドポイントだけが返されるため、正常時にクライアントが接続するのはプライマリ エンドポイントだけです。
しかし、プライマリ インスタンスがダウンしているときは、クライアントが引き続き接続できるよう、ネゴシエートでセカンダリ エンドポイントが返されます。
プライマリ インスタンスとアプリ サーバーは、通常のサーバー接続を介して接続されますが、セカンダリ インスタンスとアプリ サーバーは、弱い接続と呼ばれる特殊な接続を介して接続されます。
主な違いは、弱い接続がクライアントの接続ルーティングを受け入れない点です。セカンダリ インスタンスは、別のリージョンに置かれるためです。 クライアントを別のリージョンにルーティングすることは最適な選択ではありません (待ち時間が長くなります)。

1 つのサービス インスタンスを複数のアプリ サーバーに接続するとき、そのインスタンスには、複数のロールを割り当てることができます。
SignalR サービス インスタンスとアプリ サーバーとを 2 ペア (またはそれ以上) 用意するのが、リージョンをまたぐシナリオで一般的な構成です。
それぞれのペア内でアプリ サーバーと SignalR サービスとが同じリージョン内に存在し、SignalR サービスは、プライマリ ロールとしてアプリ サーバーに接続されます。
ペアとペアの間でも、アプリ サーバーと SignalR サービスとが接続されますが、SignalR は、別のリージョン内のサーバーに接続するときにはセカンダリとなります。

このトポロジであっても、すべてのアプリ サーバーと SignalR サービス インスタンスが相互接続されているので、一方のサーバーからすべてのクライアントにメッセージを配信することはできます。
しかしクライアントが接続されているときは、最適なネットワーク待ち時間を確保するために、そのクライアントは、常に同じリージョン内のアプリ サーバーにルーティングされます。

次の図は、そのようなトポロジを示したものです。

![トポロジ](media/signalr-concept-disaster-recovery/topology.png)

## <a name="configure-app-servers-with-multiple-signalr-service-instances"></a>複数の SignalR サービス インスタンスでアプリ サーバーを構成する

SignalR サービスとアプリ サーバーを各リージョンに作成したら、すべての SignalR サービス インスタンスに接続するようにアプリ サーバーを構成することができます。

それには次の 2 とおりの方法があります。

### <a name="through-config"></a>config による方法

環境変数/アプリの設定/web.cofig から `Azure:SignalR:ConnectionString` という名前の config エントリで SignalR サービスの接続文字列を設定する方法をご存知のはずです。
複数のエンドポイントがある場合は、複数の config エントリでそれらを設定してください。それぞれ次の形式で設定します。

```
Azure:SignalR:ConnectionString:<name>:<role>
```

ここで、`<name>` はエンドポイントの名前であり、`<role>` はそのロール (プライマリまたはセカンダリ) です。
名前は省略可能ですが、複数のエンドポイント間でルーティングの動作をさらにカスタマイズしたい場合に役立ちます。

### <a name="through-code"></a>コードによる方法

どこか他の場所に接続文字列を保存したい場合は、コードからそれらを読み取って、`AddAzureSignalR()` (ASP.NET Core の場合) または `MapAzureSignalR()` (ASP.NET の場合) を呼び出す際にパラメーターとして使用することもできます。

次にサンプル コードを示します。

ASP.NET Core:

```cs
services.AddSignalR()
        .AddAzureSignalR(options => options.Endpoints = new ServiceEndpoint[]
        {
            new ServiceEndpoint("<connection_string1>", EndpointType.Primary, "region1"),
            new ServiceEndpoint("<connection_string2>", EndpointType.Secondary, "region2"),
        });
```

ASP.NET:

```cs
app.MapAzureSignalR(GetType().FullName, hub,  options => options.Endpoints = new ServiceEndpoint[]
    {
        new ServiceEndpoint("<connection_string1>", EndpointType.Primary, "region1"),
        new ServiceEndpoint("<connection_string2>", EndpointType.Secondary, "region2"),
    };
```

複数のプライマリまたはセカンダリ インスタンスを構成できます。 プライマリ インスタンスまたはセカンダリ インスタンスが複数ある場合、ネゴシエートは次の順序でエンドポイントを返します。

1. 少なくとも 1 つのプライマリ インスタンスがオンラインになっている場合は、ランダムなオンラインのプライマリ インスタンスを返します。
2. すべてのプライマリ インスタンスがダウンしている場合は、ランダムなオンラインのセカンダリ インスタンスを返します。

## <a name="failover-sequence-and-best-practice"></a>フェールオーバーのシーケンスとベスト プラクティス

以上で、適切なシステム トポロジのセットアップが完了しました。 一方の SignalR サービス インスタンスがダウンすると、オンライン トラフィックが別のインスタンスにルーティングされます。
プライマリ インスタンスがダウンしたとき (そしてその後しばらくしてから復旧するとき) の挙動を次に示します。

1. プライマリ サービス インスタンスがダウンすると、このインスタンスにおけるすべてのサーバー接続が切断されます。
2. このインスタンスは、そこに接続されているすべてのサーバーによってオフラインとしてマークされます。また、以後ネゴシエートでこのエンドポイントは返されなくなり、セカンダリのエンドポイントが返されるようになります。
3. また、このインスタンスに対するクライアント接続はすべて閉じられ、クライアントの再接続が行われます。 以後アプリ サーバーからはセカンダリ エンドポイントが返されるので、クライアントはセカンダリ インスタンスに接続されるようになります。
4. これですべてのオンライン トラフィックがセカンダリ インスタンスに向かうようになりました。 セカンダリはすべてのアプリ サーバーに接続されているため、サーバーからクライアントへのメッセージは依然としてすべて配信されます。 しかし、クライアントからサーバーへのメッセージのルーティング先は、同じリージョン内のアプリ サーバーに限られます。
5. プライマリ インスタンスが復旧してオンラインに戻った後、アプリ サーバーはプライマリ インスタンスへの接続を再度確立し、それをオンラインとしてマークします。 以後ネゴシエートでは再びプライマリ エンドポイントが返されるようになるので、新しいクライアントは元どおりプライマリに接続されます。 ただし、既存のクライアントは切断されず、自ら切断するまでそのままセカンダリにルーティングされ続けます。

以下の図は、SignalR サービスにおけるフェールオーバーの動作を示したものです。

図 1 フェールオーバー前 ![フェールオーバー前](media/signalr-concept-disaster-recovery/before-failover.png)

図 2 フェールオーバー後 ![フェールオーバー後](media/signalr-concept-disaster-recovery/after-failover.png)

図 3 プライマリの復旧後間もなく ![プライマリの復旧後間もなく](media/signalr-concept-disaster-recovery/after-recover.png)

正常時には、オンライン トラフィック (青色) がプライマリのアプリ サーバーと SignalR サービスにのみ向かうことがわかります。
フェールオーバー後は、セカンダリのアプリ サーバーと SignalR サービスもアクティブになります。
プライマリの SignalR サービスがオンラインに戻った後、新しいクライアントはプライマリの SignalR に接続されます。 一方、既存のクライアントはそのままセカンダリに接続された状態になるので、両方のインスタンスにトラフィックが向かうことになります。
既存のクライアントがすべて切断されると、システムが正常な状態に戻ります (図 1)。

リージョンをまたぐ高可用性アーキテクチャを導入する場合、主に次の 2 つのパターンがあります。

1. 1 つ目は、アプリ サーバーと SignalR サービス インスタンスから成る一方のペアですべてのオンライン トラフィックを処理し、もう一方のペアはバックアップとして使用する方法です (これは "アクティブ/パッシブ" と呼ばれます。図1 を参照)。 
2. もう 1 つは、アプリ サーバーと SignalR サービス インスタンスから成るペアを 2 つ (またはそれ以上) 用意し、それぞれのペアがオンライン トラフィックを分担して処理し、他のペアのバックアップとして機能する方法です (これは "アクティブ/アクティブ" と呼ばれます。図 3 と同様)。

SignalR サービスは両方のパターンに対応できます。主な違いはアプリ サーバーの導入方法です。
アプリ サーバーがアクティブ/パッシブである場合、SignalR サービスもアクティブ/パッシブになります (プライマリのアプリ サーバーから返されるのはそのプライマリ SignalR サービス インスタンスのみであるため)。
アプリ サーバーがアクティブ/アクティブである場合、SignalR サービスもアクティブ/アクティブになります (すべてのアプリ サーバーから、それぞれのプライマリ SignalR インスタンスが返されるので、そのすべてのインスタンスでトラフィックを受けることができる)。

どちらのパターンを使用するにしても、アプリ サーバーには、それぞれの SignalR サービス インスタンスをプライマリとして接続する必要がある点に注意してください。

また、SignalR 接続 (長時間接続) の性質上、障害とフェールオーバーが発生すると、クライアントでは接続の切断が生じます。
そのようなケースはクライアント側で処理して、エンド ユーザーからは見えないようにする必要があります。 たとえば、接続が閉じられた後で再接続を行うことが考えられます。

## <a name="next-steps"></a>次のステップ

この記事では、SignalR サービスに回復性を持たせるためのアプリケーションの構成方法について説明しました。 SignalR サービスにおける接続のルーティングとサーバー/クライアント接続の詳細については、SignalR サービスの内部について説明した[こちらの記事](signalr-concept-internals.md)を参照してください。

大量の接続を処理するために複数のインスタンスを同時に使用するスケーリング シナリオ (シャーディングなど) については、[複数のインスタンスをスケーリングする方法](signalr-howto-scale-multi-instances.md)に関するページを参照してください。
