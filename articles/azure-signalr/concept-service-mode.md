---
title: Azure SignalR Service のサービス モード
description: Azure SignalR Service のさまざまなサービス モードの概要と、それらの相違点および適用可能なユーザー シナリオについて説明します
author: chenkennt
ms.service: signalr
ms.topic: conceptual
ms.date: 08/19/2020
ms.author: kenchen
ms.openlocfilehash: 60f1ab0440120cb9a96e6c05a4fc1987ead29188
ms.sourcegitcommit: f28ebb95ae9aaaff3f87d8388a09b41e0b3445b5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/29/2021
ms.locfileid: "92143258"
---
# <a name="service-mode-in-azure-signalr-service"></a>Azure SignalR Service のサービス モード

サービス モードは、Azure SignalR Service での重要な概念です。 新しい SignalR リソースを作成するとき、サービス モードを指定するように求められます。

:::image type="content" source="media/concept-service-mode/create.png" alt-text="作成時にサービス モードを選択する":::

後で [設定] メニューでそれを変更することもできます。

:::image type="content" source="media/concept-service-mode/update.png" alt-text="サービス モードを更新する":::

Azure SignalR サービスでは現在、**既定**、**サーバーレス**、**クラシック** の 3 つのサービス モードがサポートされています。 SignalR リソースの動作はモードによって異なります。 この記事では、それらの違いと、シナリオに基づいて適切なサービス モードを選択する方法について説明します。

## <a name="default-mode"></a>既定モード

既定モードは、新しい SignalR リソースを作成するときのサービス モードの既定値です。 このモードでは、アプリケーションは通常の ASP.NET Core (または ASP.NET) SignalR アプリケーションとして動作します。ハブは Web サーバー (以下ではハブ サーバーと呼びます) でホストされ、クライアントとハブ サーバーの間ではリアルタイムの二重通信を行うことができます。 唯一の違いは、クライアントとサーバーは直接接続するのではなく、クライアントとサーバーの両方が SignalR Service に接続し、サービスをプロキシとして使用することです。 次の図は、既定モードでの一般的なアプリケーション構造を示したものです。

:::image type="content" source="media/concept-service-mode/default.png" alt-text="既定モードでのアプリケーション構造":::

そのため、SignalR アプリケーションがあり、SignalR Service と統合する場合は、ほとんどの場合、既定モードが適切な選択になります。

### <a name="connection-routing-in-default-mode"></a>既定モードでの接続ルーティング

既定モードでは、ハブ サーバーと SignalR Service の間に WebSocket 接続が存在します (サーバー接続と呼ばれます)。 これらの接続は、サーバーとクライアントの間でメッセージを転送するために使用されます。 新しいクライアントが接続されると、SignalR Service により、既存のサーバー接続を使用して、クライアントは 1 つのハブ サーバーにルーティングされます (複数のサーバーがあると仮定)。 その後、クライアント接続は有効期間の間、同じハブ サーバーに固定されます。 クライアントによって送信されたメッセージは、常に同じハブ サーバーに送られます。 この動作により、ハブ サーバー上の個々の接続に対して状態を安全に維持できます。 たとえば、サーバーとクライアントの間で何かをストリーミングしたい場合、データ パケットが異なるサーバーに送信されることを考慮する必要はありません。

> [!IMPORTANT]
> これは、既定モードでは、最初にサーバーが接続されてからでないと、クライアントが接続できないことも意味します。 ネットワークの中断またはサーバーの再起動によってすべてのハブ サーバーが切断された場合、クライアント接続はエラーになり、サーバーが接続されていないことが示されます。 そのため、ユーザーは常に少なくとも 1 つのハブ サーバーが SignalR Service に接続されているようにする必要があります (たとえば、複数のハブ サーバーを用意し、メンテナンスなどのためにそれらが同時にオフラインにならないようにする)。

このルーティング モデルでは、ハブ サーバーがオフラインになると、そのサーバーにルーティングされる接続も削除されます。 そのため、ハブ サーバーがメンテナンスのためにオフラインになったら接続が切断されることを想定し、アプリケーションに悪影響がないように、再接続を正しく処理する必要があります。

## <a name="serverless-mode"></a>サーバーレス モード

サーバーレス モードは、その名前が示すとおり、ハブ サーバーを持つことができないモードです。 既定モードと比較すると、このモードでは、クライアントはハブ サーバーに接続する必要がありません。 すべての接続は "サーバーレス" モードでサービスに接続され、クライアントの ping の処理など、クライアントの接続の維持はサービスによって行われます (既定モードでは、これはハブ サーバーによって処理されます)。

また、このモードではサーバー接続はありません (サービス SDK を使用してサーバー接続を確立しようとすると、エラーが発生します)。 したがって、接続ルーティングおよびサーバーとクライアントの持続性もありません (既定モードに関するセクションで説明)。 ただし、それでもサーバー側アプリケーションでメッセージをクライアントにプッシュすることはできます。 これを行うには 2 つの方法があり、1 回限りの送信には [REST API](https://github.com/Azure/azure-signalr/blob/dev/docs/rest-api.md) が使用され、複数のメッセージをさらに効率的に送信するには WebSocket 接続が使用されます (この WebSocket 接続はサーバー接続とは異なることに注意してください)。

> [!NOTE]
> REST API と WebSocket のどちらの方法も、SignalR Service の[管理 SDK](https://github.com/Azure/azure-signalr/blob/dev/docs/management-sdk-guide.md) でサポートされています。 .NET 以外の言語を使用している場合でも、この[仕様](https://github.com/Azure/azure-signalr/blob/dev/docs/rest-api.md)に従って、REST API を手動で呼び出すことができます。
>
> Azure Functions を使用している場合は、[Azure Functions に対する SignalR Service のバインド](../azure-functions/functions-bindings-signalr-service.md) (以下では関数バインドと呼びます) を使用して、出力バインドとしてメッセージを送信できます。

また、サーバー アプリケーションでクライアントからメッセージと接続イベントを受信することもできます。 サービスでは、Webhook を使用して、構成済みのエンドポイント (アップストリームと呼ばれます) にメッセージと接続イベントが配信されます。 既定モードと比較すると、持続性が保証されず、HTTP 要求は WebSocket 接続より効率が劣る場合があります。

アップストリームを構成する方法の詳細については、こちらの[ドキュメント](./concept-upstream.md)を参照してください。

次の図は、サーバーレス モードの動作を示したものです。

:::image type="content" source="media/concept-service-mode/serverless.png" alt-text="サーバーレス モードでのアプリケーション構造":::

> [!NOTE]
> 既定モードでも、ハブ サーバーを経由したくない場合は、REST API と管理 SDK と関数バインドを使用して、クライアントにメッセージを直接送信できることに注意してください。 ただし、既定モードでは、クライアント接続はやはりハブ サーバーによって処理され、アップストリームはそのモードでは動作しません。

## <a name="classic-mode"></a>クラシック モード

クラシックは、既定モードとサーバーレス モードの混合モードです。 このモードでは、接続モードは、クライアント接続が確立されるときに、ハブ サーバーが接続されているかどうかによって決まります。 ハブ サーバーがある場合、クライアント接続はハブ サーバーにルーティングされます。 それ以外の場合は、サーバーレス モードになり、クライアントからサーバーへのメッセージをハブ サーバーに配信することはできません。 これにより、いくつかの違いが発生します。たとえば、すべてのハブ サーバーが短時間使用できない場合、その間に作成されるすべてのクライアント接続はサーバーレス モードになり、ハブ サーバーにメッセージを送信することはできません。

> [!NOTE]
> クラシック モードは、主に、既定モードとサーバーレス モードが存在するようになる前に作成されたアプリケーションとの下位互換性のために用意されています。 このモードはもう使用しないよう強くお勧めします。 新しいアプリケーションでは、シナリオに基づいて、既定またはサーバーレスを選択してください。 既存のアプリケーションについては、ユース ケースを確認し、適切なサービス モードを選択することもお勧めします。

クラシック モードでは、サーバーレス モードでのアップストリームなど、一部の新機能もサポートされていません。

## <a name="choose-the-right-service-mode"></a>適切なサービス モードを選択する

サービス モードの間にはどのような違いがあり、それらをどのように選択すればよいかわかったはずです。 前のセクションで学習したように、クラシック モードは推奨されません。既定とサーバーレスのどちらかだけを選択する必要があります。 ここでは、新しいアプリケーションで適切な選択を行ったり、既存のアプリケーションでクラシック モードの使用を止めたりする際に役立つヒントを紹介します。

* SignalR ライブラリの動作について既によく理解していて、セルフホステッドの SignalR から Azure SignalR Service の使用に移行したい場合は、既定モードを選択します。 既定モードはセルフホステッドの SignalR とまったく同じように機能し (SignalR ライブラリの同じプログラミング モデルを使用できます)、SignalR Service はクライアントとハブ サーバー間のプロキシとして機能します。

* 新しいアプリケーションを作成していて、ハブ サーバーとサーバーの接続を維持したくない場合は、サーバーレス モードを選択します。 通常、このモードは Azure Functions と連携して動作するため、サーバーを維持する必要はありません。 それでも (REST API、管理 SDK、関数バインドとアップストリームを使用して) 二重通信を行うことができますが、プログラミング モデルは SignalR ライブラリとは異なります。

* クライアント接続を提供するハブ サーバーと、クライアントにメッセージを直接プッシュするバックエンド アプリケーション (REST API など) の両方がある場合でも、既定モードを選択する必要があります。 既定モードとサーバーレス モードの主な違いは、ハブ サーバーがあるかどうかと、クライアント接続のルーティング方法であることに注意してください。 REST API、管理 SDK、関数バインドは、両方のモードで使用できます。

* たとえば、同じ SignalR リソースに 2 つの異なるハブがあり、1 つは従来の SignalR ハブとして使用され、もう 1 つは Azure Functions で使用されていて、ハブ サーバーがないような、本当の混合シナリオの場合は、それらを 2 つの SignalR リソース (1 つは既定モード、1 つはサーバーレス モード) に分けることを実際に検討する必要があります。

## <a name="next-steps"></a>次の手順

既定モードとサーバーレス モードの使用方法の詳細については、次の記事を参照してください。

* [Azure SignalR Service の内部](signalr-concept-internals.md)

* [Azure SignalR Service を使用した Azure Functions の開発と構成](signalr-concept-serverless-development-config.md)