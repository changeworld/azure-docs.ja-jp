---
title: "開発者向け Azure Batch の概要 | Microsoft Docs"
description: "開発の観点から、Batch サービスとその API の機能について説明します。"
services: batch
documentationcenter: .net
author: tamram
manager: timlt
editor: 
ms.assetid: 416b95f8-2d7b-4111-8012-679b0f60d204
ms.service: batch
ms.devlang: multiple
ms.topic: get-started-article
ms.tgt_pltfrm: na
ms.workload: big-compute
ms.date: 03/08/2017
ms.author: tamram
ms.custom: H1Hack27Feb2017
translationtype: Human Translation
ms.sourcegitcommit: eeb56316b337c90cc83455be11917674eba898a3
ms.openlocfilehash: f323afdea34e973f3ecdd54022f04b3f0d86afb1
ms.lasthandoff: 04/03/2017


---
# <a name="develop-large-scale-parallel-compute-solutions-with-batch"></a>Batch を使って大規模な並列コンピューティング ソリューションを開発する

ここでは、Azure Batch サービスの主要コンポーネントについて簡単に紹介し、Batch を使って大規模な並列コンピューティング ソリューションを開発する際に利用できる主な機能とリソースについて取り上げます。

[REST API][batch_rest_api] を直接呼び出す分散コンピューティング アプリケーションまたはサービスを開発する場合も、いずれかの [Batch SDK](batch-apis-tools.md#batch-development-apis) を使う場合も、この記事で紹介するさまざまなリソースや機能を活用することができます。

> [!TIP]
> Batch サービスの基本については、「 [Azure Batch の基礎](batch-technical-overview.md)」を参照してください。
>
>

## <a name="batch-service-workflow"></a>Batch サービスのワークフロー
以下に示したのは、Batch サービスを使って並列ワークロードを処理するアプリケーションやサービスでほぼ例外なく使用する基本的なワークフローです。

1. 処理対象の**データ ファイル**を [Azure Storage][azure_storage] アカウントにアップロードします。 Batch には、Azure Blob Storage へのアクセスのサポートが組み込まれており、これらのファイルは、タスクの実行時に [コンピューティング ノード](#compute-node) にダウンロードすることができます。
2. タスクで実行する**アプリケーション ファイル**をアップロードします。 たとえばジョブのタスクによって実行されるバイナリやスクリプト、さらには、その依存関係をアップロードできます。 これらのファイルは、タスクによって Storage アカウントからダウンロードできます。また、Batch の[アプリケーション パッケージ](#application-packages)機能をアプリケーションの管理とデプロイに利用することもできます。
3. コンピューティング ノードの [プール](#pool) を作成します。 プールを作成するときに、プールのコンピューティング ノードの数とサイズ、オペレーティング システムを指定します。 ジョブに含まれる各タスクは、その実行時に、プール内のいずれかのノードで実行されるように割り当てられます。
4. [ジョブ](#job)を作成します。 ジョブはタスクのコレクションを管理するものです。 各ジョブは、ジョブのタスクの実行場所とする特定のプールに関連付けて使用します。
5. ジョブに [タスク](#task) を追加します。 各タスクは、アップロードされたアプリケーション (またはスクリプト) を実行し、ストレージ アカウントからダウンロードしたデータ ファイルを処理します。 完了した各タスクは、その出力を Azure Storage にアップロードすることができます。
6. ジョブの進行状況を監視し、タスクの出力を Azure Storage から取得します。

次のセクションでは、これ以外にも、分散コンピューティングのシナリオを実現する Batch の各種リソースについて説明します。

> [!NOTE]
> Batch サービスを利用するには、[Batch アカウント](batch-account-create-portal.md)が必要です。 また、ほぼすべてのソリューションでファイルの保存と取得に [Azure Storage][azure_storage] アカウントが使用されています。 「[Azure ストレージ アカウントについて](../storage/storage-create-storage-account.md)」の手順 5.「[ストレージ アカウントの作成](../storage/storage-create-storage-account.md#create-a-storage-account)」で説明されているように、Batch では、現時点で**汎用**のストレージ アカウントの種類のみがサポートされています。
>
>

## <a name="batch-service-resources"></a>Batch サービスのリソース
以下に示すリソースのいくつか (アカウント、コンピューティング ノード、プール、ジョブ、タスク) は、Batch サービスを使用するすべてのソリューションで必須となります。 ジョブ スケジュールやアプリケーション パッケージなど、有用ながらオプションの機能もあります。

* [アカウント](#account)
* [コンピューティング ノード](#compute-node)
* [プール](#pool)
* [ジョブ](#job)

  * [ジョブ スケジュール](#scheduled-jobs)
* [タスク](#task)

  * [開始タスク](#start-task)
  * [ジョブ マネージャー タスク](#job-manager-task)
  * [ジョブ準備タスクおよびジョブ解放タスク](#job-preparation-and-release-tasks)
  * [マルチインスタンス タスク (MPI)](#multi-instance-tasks)
  * [Task dependencies](#task-dependencies)
* [アプリケーション パッケージ](#application-packages)

## <a name="account"></a>アカウント
Batch アカウントは、Batch サービス内で一意に識別されるエンティティです。 すべての処理は、Batch アカウントに関連付けられています。 Batch サービスで処理を実行するには、アカウント名とそのいずれかのアカウント キーの両方が必要です。 [Azure Portal を使用して Azure Batch アカウントを作成](batch-account-create-portal.md)できます。

## <a name="compute-node"></a>コンピューティング ノード
コンピューティング ノードは、アプリケーションのワークロードの処理に特化した Azure 仮想マシン (VM) です。 ノードのサイズによって、CPU コアの数、メモリ容量、およびノードに割り当てられるローカル ファイル システムのサイズが決まります。 Azure Cloud Services または Virtual Machines Marketplace イメージを使用して Windows ノードまたは Linux ノードのプールを作成することができます。 これらの各オプションの詳細については、以下の「 [プール](#pool) 」セクションを参照してください。

ノードは、そのオペレーティング システム環境が対応していれば、どのような実行可能ファイル (またはスクリプト) でも実行できます。 たとえば、Windows なら \*.exe、\*.cmd、\*.bat、PowerShell スクリプトを、Linux ならバイナリ、シェル、Python スクリプトを実行できます。

Batch のすべてのコンピューティング ノードには、次の要素が存在します。

* 標準的な[フォルダー構造](#files-and-directories)と、それに関連付けられた (タスクから参照できる) [環境変数](#environment-settings-for-tasks)。
* **ファイアウォール** 設定。
* [リモート アクセス](#connecting-to-compute-nodes) 。

## <a name="pool"></a>プール
プールは、アプリケーションが実行されるノードのコレクションです。 プールは手動で作成できるほか、実行する操作を指定した場合は Batch サービスによって自動的に作成されます。 アプリケーションのリソース要件を満たすプールを作成して管理することができます。 プールは、そのプールを作成した Batch アカウントのみが使用できます。 1 つの Batch アカウントで複数のプールを持つことができます。

Azure Batch プールは、コア Azure コンピューティング プラットフォームの上に構築されます。 Batch プールによって、大規模な割り当て、アプリケーションのインストール、データの分散、状態の監視、プール内のコンピューティング ノード数の柔軟な調整 ([スケーリング](#scaling-compute-resources)) が可能になります。

プールに追加されたすべてのノードに対し、一意の名前と IP アドレスが割り当てられます。 ノードがプールから削除されると、オペレーティング システムまたはファイルに加えられた変更は失われ、将来使用できるように名前と IP アドレスが解放されます。 ノードをプールから削除すると、その有効期間が終了します。

プールを作成するときに次の属性を指定できます。

* コンピューティング ノードの**オペレーティング システム**と**バージョン**

    プール内のノードに使用するオペレーティング システムには、**仮想マシンの構成**と **Cloud Services の構成**という 2 つの選択肢があります。

    **仮想マシンの構成**では、[Azure Virtual Machines Marketplace][vm_marketplace] から Linux と Windows の両方のコンピューティング ノード イメージが提供されます。
    仮想マシンの構成ノードを含むプールを作成する場合は、ノードのサイズだけでなく、ノードにインストールする**仮想マシン イメージの参照**と Batch **ノード エージェント SKU** も指定する必要があります。 プールに関するこれらのプロパティの指定の詳細については、「 [Azure Batch プールの Linux コンピューティング ノードのプロビジョニング](batch-linux-nodes.md)」を参照してください。

    **Cloud Services の構成** では、Windows コンピューティング ノード *のみ*が提供されます。 Cloud Services 構成プールで使用可能なオペレーティング システムは、「 [Azure ゲスト OS リリースと SDK の互換性対応表](../cloud-services/cloud-services-guestos-update-matrix.md)」に一覧が掲載されています。 Cloud Services ノードを含むプールを作成する場合は、ノード サイズとその *OS ファミリ*のみを指定する必要があります。 Windows コンピューティング ノードのプールを作成する場合は、Cloud Services が最もよく使用されます。

  * *OS ファミリ* によって、OS と同時にインストールされる .NET のバージョンも決まります。
  * Cloud Services 内の worker ロールと同様、"*OS バージョン*" を指定できます (worker ロールの詳細については、[Cloud Services の概要](../cloud-services/cloud-services-choose-me.md)に関するページの「[Cloud Services の概要](../cloud-services/cloud-services-choose-me.md#tell-me-about-cloud-services)」セクションを参照してください)。
  * worker ロールの場合と同様に、"*OS バージョン*" には `*` を指定することをお勧めします。これにより、ノードは自動的にアップグレードされ、新たにリリースされたバージョンに対応するための作業が不要になります。 特定の OS バージョンを選択するのは、主にアプリケーションの互換性を確保する必要がある場合です。こうすることで、バージョンの更新を許可する前に旧バージョンとの互換性をテストできます。 検証が終わると、プールの "*OS バージョン*" を更新して、新しい OS イメージをインストールできます。その際、実行中のタスクはすべて中断され、再びキューに置かれます。
* **ノードのサイズ**

    **Cloud Services の構成** のコンピューティング ノードのサイズについては、「 [Cloud Services のサイズ](../cloud-services/cloud-services-sizes-specs.md)」を参照してください。 Batch は、`ExtraSmall`、`STANDARD_A1_V2`、`STANDARD_A2_V2` を除くすべての Cloud Services サイズに対応しています。

    **仮想マシンの構成**のコンピューティング ノード サイズについては、「[Azure の仮想マシンのサイズ](../virtual-machines/linux/sizes.md)」(Linux) および「[Azure の仮想マシンのサイズ](../virtual-machines/windows/sizes.md)」(Windows) を参照してください。 Batch は、Premium Storage を使用する VM (`STANDARD_GS`、`STANDARD_DS`、`STANDARD_DSV2` シリーズ) と `STANDARD_A0` を除くすべての Azure VM サイズに対応しています。

    コンピューティング ノードのサイズを選択するときは、ノード上で実行するアプリケーションの特性と要件を考慮してください。 アプリケーションがマルチスレッドであるかどうかや、どのくらいのメモリが消費されるかという点が、最も適切でコスト効率の高いノード サイズを選ぶうえでのヒントになります。 ノードのサイズは、そこで一度に実行されるタスクが 1 つであるという想定で選択するのが一般的です。 しかしジョブの実行中には、コンピューティング ノードで複数のタスク (ひいては複数のアプリケーション インスタンス) が[並列実行](batch-parallel-node-tasks.md)される可能性もあります。 そのような場合は、タスクを並列に実行するという需要の増大に対応するために、より大きなノード サイズを選ぶことが基本です。 詳細については、「[タスクのスケジューリング ポリシー](#task-scheduling-policy)」を参照してください。

    同じプール内のノードはすべて同じサイズとなります。 システム要件や負荷水準の異なる複数のアプリケーションを実行する場合は、プールを分けることをお勧めします。
* **ターゲット ノード数**

    これは、プールにデプロイしたいと考えるコンピューティング ノードの数です。 " *ターゲット* " (目標) と呼ばれているのは、状況によってはプールのノード数がその目標に達しない可能性もあるためです。 目標とするノード数をプールが下回る原因としては、Batch アカウントの [コア クォータ](batch-quota-limit.md) に達していたり、そのプールに適用した自動スケール式によって最大ノード数が制限されていたりすることが考えられます (以下の「スケーリング ポリシー」セクションを参照)。
* **スケーリング ポリシー**

    動的ワークロードの場合には、プールに[自動スケール式](#scaling-compute-resources)を作成して適用できます。 Batch サービスが、その式を定期的に評価し、プール、ジョブ、タスクに関して指定されている各種パラメーターに基づいてプール内のノード数を調整します。
* **タスクのスケジューリング ポリシー**

    プール内の各コンピューティング ノードで並列実行できるタスク数は、 [ノードあたりの最大タスク数](batch-parallel-node-tasks.md) の構成オプションによって上限が決まります。

    既定の構成では、1 つのノードで一度に実行されるタスクは 1 つですが、1 つのノードで複数のタスクを同時に実行した方が都合のよい場合もあります。 1 つのノードで複数のタスクを実行することで得られる具体的なメリットについては、[ノードのタスクの同時実行](batch-parallel-node-tasks.md)に関する記事の「[サンプル シナリオ](batch-parallel-node-tasks.md#example-scenario)」を参照してください。

    Batch でプール内のすべてのノードにタスクを均等に配分するか、1 つのノードに最大数のタスクを割り当ててから次のノードにタスクを割り当てていくかを明示的に指定することもできます。これは "*フィルの種類*" を指定することによって行います。
* **通信ステータス** 

    ほとんどのシナリオでは、タスクは独立して動作し、相互に通信する必要はありません。 ただし、タスク間の通信が必要なアプリケーションも一部存在します ([MPI のシナリオ](batch-mpi.md)でのアプリケーションなど)。

    **ノード間通信**を許可するようにプールを構成し、実行時にプール内のノードが通信できるようにすることができます。 ノード間通信が有効であるとき、Cloud Services の構成のプール内のノードは、1100 を超える番号のポートで互いに通信を行うことができます。仮想マシンの構成のプールでは、いずれかのポートにトラフィックが制限されることはありません。

    ノード間通信を有効にすると、クラスター内のノードの配置にも影響が生じるので注意してください。デプロイの制限上、プール内の最大ノード数が制限される場合もあります。 アプリケーションがノード間の通信を必要としない場合、Batch サービスは多くの別のクラスターおよびデータ センターのプールに大量のノードを割り当てることにより、並列処理能力を向上させることができます。
* **開始タスク** 

    "*開始タスク*" (省略可) は、各ノードがプールに追加されたときにそれぞれのノードで実行されます。また、ノードが再起動されたり再イメージ化されたりするたびに、各ノードで開始タスクが実行されます。 開始タスクは、タスクの実行に使用するコンピューティング ノードを準備する (タスクによってコンピューティング ノードで実行されるアプリケーションをインストールするなど) 場合に特に有効です。
* **アプリケーション パッケージ**

    プール内のコンピューティング ノードにデプロイする[アプリケーション パッケージ](#application-packages)を指定できます。 アプリケーション パッケージにより、タスクによって実行されるアプリケーションのデプロイとバージョン管理がシンプルになります。 プールに指定したアプリケーション パッケージは、そのプールに参加しているすべてのノードにインストールされます。また、ノードが再起動または再イメージ化されるたびにインストールされます。 アプリケーション パッケージは、Linux コンピューティング ノードでは現在サポートされていません。
* **ネットワーク構成**

    プールのコンピューティング ノードを作成する必要のある Azure [仮想ネットワーク (VNet)](../virtual-network/virtual-networks-overview.md) の ID を指定できます。 詳細については、「[プール ネットワーク構成](#pool-network-configuration)」セクションを参照してください。

> [!IMPORTANT]
> すべての Batch アカウントには、1 つの Batch アカウントで使用できる**コア**数 (つまりコンピューティング ノード数) に上限を設ける既定の**クォータ**が割り当てられています。 既定のクォータと、[クォータを増やす](batch-quota-limit.md#increase-a-quota)手順 (Batch アカウントの最大コア数を増やす方法など) については、「[Azure Batch サービスのクォータと制限](batch-quota-limit.md)」を参照してください。 なぜかプール内のノードが一定数を超えない、と疑問を感じている場合、 このコア クォータが原因である可能性があります。
>
>

## <a name="job"></a>ジョブ
ジョブはタスクのコレクションです。 プール内のコンピューティング ノード上で行う計算をそれらのタスクでどのように実行するかを管理します。

* ジョブによって、作業が実行される**プール**を指定します。 ジョブごとに新しくプールを作成できるほか、多数のジョブに対して 1 つのプールを使用することもできます。 ジョブ スケジュールに関連付けられているジョブごとにプールを作成するか、ジョブ スケジュールに関連付けられているすべてのジョブに対してプールを作成してください。
* 必要に応じて **ジョブの優先順位**を指定できます。 現在処理中のジョブよりも優先順位の高いジョブが送信されると、優先順位の高いジョブのタスクが、優先順位の低いジョブのタスクよりも先のキューに挿入されます。 既に実行されている優先順位の低いジョブのタスクが、優先順位の高いタスクに入れ替わることはありません。
* ジョブに対する特定の制限は、ジョブの **制約** を使用して指定できます。

    **最大実時間**を設定できます。この場合、ジョブの実行時間が、指定された最大実時間を超えると、ジョブとそのすべてのタスクが強制的に終了されます。

    失敗したタスクは Batch によって検出され、再試行されます。 **タスク再試行の最大回数**を制約として指定できます。タスクを "*常に*" 再試行するように指定したり、再試行を "*禁止*" したりすることもできます。 タスクの再試行とは、タスクをもう一度実行するためにキューに置くことです。
* クライアント アプリケーションでジョブにタスクを追加するか、[ジョブ マネージャー タスク](#job-manager-task)を指定することができます。 ジョブ マネージャー タスクには、ジョブに必要なタスクを作成するための情報と、プール内のいずれかのコンピューティング ノードで実行されているジョブ マネージャー タスクが含まれます。 ジョブ マネージャー タスクは Batch によってのみ処理されます。ジョブが作成されるとすぐにキューに配置され、失敗すると再開されます。 [ジョブ スケジュール](#scheduled-jobs)によって作成されたジョブには、ジョブ マネージャー タスクが "*必要*" です。ジョブ マネージャー タスク以外では、ジョブがインスタンス化される前にタスクを定義できないためです。
* 既定では、ジョブ内のすべてのタスクが完了しても、ジョブはアクティブな状態のままとなります。 この動作は変更可能です。ジョブ内のすべてのタスクが完了したときにジョブが自動的に終了するように設定できます。 ジョブの **onAllTasksComplete** プロパティ (Batch .NET の [OnAllTasksComplete][net_onalltaskscomplete]) を *terminatejob* に変更することで、ジョブのすべてのタスクが完了状態になったときに、ジョブを自動的に終了することができます。

    Batch サービスは、タスクの " *ない* " ジョブを考慮して、そのすべてのタスクを完了させます。 したがって、このオプションは、 [ジョブ マネージャー タスク](#job-manager-task)で最も一般的に使用されます。 ジョブ マネージャーを使用せずにジョブの自動終了を使用するには、最初に新しいジョブの **onAllTasksComplete** プロパティを *noaction* に設定し、ジョブにタスクを追加し終えた後でのみ *terminatejob* に設定する必要があります。

### <a name="job-priority"></a>ジョブの優先順位
Batch で作成するジョブには、優先順位を割り当てることができます。 Batch サービスは、ジョブの優先順位値を使用して、アカウント内のジョブ スケジューリングの順序を決定します ([スケジュールされたジョブ](#scheduled-jobs)と混同しないでください)。 優先順位として、-1000 ～ 1000 の値を使用します。-1000 は最も低い優先順位を示し、1000 は最も高い優先順位を示します。 ジョブの優先順位を更新するには、[ジョブのプロパティの更新][rest_update_job]操作 (Batch REST) を呼び出すか、[CloudJob.Priority][net_cloudjob_priority] プロパティ (Batch .NET) を変更します。

同じアカウント内で、優先順位の高いジョブは優先順位の低いジョブよりも優先的にスケジュールされます。 あるアカウントの優先順位値が高いジョブが、異なるアカウントの優先順位値が低い別のジョブよりも優先的にスケジュールされることはありません。

複数のプールにわたるジョブ スケジューリングは、独立しています。 異なるプール間では、関連するそのプールでアイドル状態のノードが不足している場合、優先順位の高い方のジョブが最初にスケジュールされるとは限りません。 同じプール内のジョブの場合、優先順位が同じであれば、スケジュールされる可能性は等しくなります。

### <a name="scheduled-jobs"></a>スケジュールされたジョブ
[ジョブ スケジュール][rest_job_schedules]を使用すると、Batch サービス内に、繰り返し発生するジョブを作成することができます。 ジョブ スケジュールは、ジョブをいつ実行するかを指定し、実行されるジョブの仕様を持っています。 スケジュールがいつ有効になって、どのくらいの期間有効であるかというスケジュール期間と、その期間中にどのくらいの頻度でジョブを作成するかを指定することができます。

## <a name="task"></a>タスク
タスクは、ジョブに関連付けられた計算の単位です。 タスクはノードで実行されます。 タスクはノードに割り当てられて実行されるか、ノードが解放されるまでキューに格納されます。 つまりコンピューティング ノード上にある 1 つ以上のプログラム (またはスクリプト) をタスクが実行することによって、必要な作業が遂行されます。

タスクを作成するときに、次の情報を指定できます。

* タスクの**コマンド ライン**。 コンピューティング ノード上のアプリケーションまたはスクリプトを実行するコマンド ラインとして使用されます。

    実際にシェルでコマンド ラインが実行されるわけではないので注意してください。 そのため、`PATH` を含む[環境変数](#environment-settings-for-tasks)の展開など、シェルの機能をネイティブに利用することはできません。 こうした機能を利用するには、コマンド ラインでシェルを呼び出す必要があります。たとえば、次のように Windows ノードでは `cmd.exe` を、Linux では `/bin/sh` を起動します。

    `cmd /c MyTaskApplication.exe %MY_ENV_VAR%`

    `/bin/sh -c MyTaskApplication $MY_ENV_VAR`

    ノードの `PATH` や参照用の環境変数に存在しないアプリケーションまたはスクリプトをタスクで実行する必要がある場合は、タスクのコマンド ラインからシェルを明示的に呼び出してください。
* **リソース ファイル** 。 これらのファイルは、タスクのコマンド ラインが実行される前に、汎用の Azure Storage アカウントの Blob Storage からノードに自動的にコピーされます。 詳細については、「[開始タスク](#start-task)」と「[ファイルとディレクトリ](#files-and-directories)」の各セクションを参照してください。
* アプリケーションで必要な **環境変数** 。 詳細については、「 [タスクの環境設定](#environment-settings-for-tasks) 」セクションを参照してください。
* タスクを実行する際の **制約** 。 この制約には、タスクの実行が許可される最大時間、タスクが失敗した場合に再試行する最大回数、タスクの作業ディレクトリにファイルを保持する最大時間などがあります。
* タスクの実行がスケジュールされているコンピューティング ノードにデプロイする**アプリケーション パッケージ**。 [アプリケーション パッケージ](#application-packages)により、タスクによって実行されるアプリケーションのデプロイとバージョン管理がシンプルになります。 タスクレベルのアプリケーション パッケージは共有プール環境では特に便利です。この環境では、さまざまなジョブが 1 つのプールで実行され、ジョブが完了してもプールは削除されません。 ジョブ内のタスクがプール内のノードよりも少ない場合は、タスクのアプリケーション パッケージによりデータ転送を最小限に抑えることができます。アプリケーションはタスクが実行されるノードにのみデプロイされるためです。

Batch サービスには、ノードで計算を実行するために定義するタスクに加えて、次のような特殊なタスクも用意されています。

* [開始タスク](#start-task)
* [ジョブ マネージャー タスク](#job-manager-task)
* [ジョブ準備タスクおよびジョブ解放タスク](#job-preparation-and-release-tasks)
* [マルチインスタンス タスク (MPI)](#multi-instance-tasks)
* [Task dependencies](#task-dependencies)

### <a name="start-task"></a>開始タスク
**開始タスク**をプールに関連付けることによって、ノードの動作環境を準備できます。 たとえば、タスクで実行するアプリケーションのインストールやバックグラウンド プロセスの開始などのアクションを実行できます。 開始タスクは、プール内に保持されている限り、ノードが起動されるたびに実行されます。ノードが最初にプールに追加されたときや、ノードが再起動されたとき、ノードが再イメージ化されたときにも実行されます。

開始タスクの主な利点は、タスクの実行に不可欠なコンピューティング ノードの構成とアプリケーションのインストールを行うために、必要なすべての情報をそこに集約できることです。 このため、新しいターゲット ノードの数を指定するのと同じくらい簡単にプール内のノードの数を増やすことができます。 新しいノードを構成し、ノードにタスクを受け取る準備を整えるうえで必要な情報は、開始タスクから Batch サービスに提供されます。

すべての Azure Batch タスクと同様、実行する**コマンド ライン**のほかに、[Azure Storage][azure_storage] 内の**リソース ファイル**の一覧を指定できます。 Batch サービスは、リソース ファイルを Azure Storage からノードにコピーした後でコマンド ラインを実行します。 プールの開始タスクの場合、このファイル一覧にはタスクのアプリケーションとその依存関係を含めるのが一般的です。

ただし、開始タスクにはコンピューティング ノードで実行されるすべてのタスク用の参照データを含めることもできます。 たとえば、開始タスクのコマンド ラインで `robocopy` 操作を実行し、(リソース ファイルとして指定され、ノードにダウンロードされた) アプリケーション ファイルを開始タスクの[作業ディレクトリ](#files-and-directories)から[共有フォルダー](#files-and-directories)にコピーしたうえで、MSI または `setup.exe` を実行することができます。

> [!IMPORTANT]
> 「[Azure ストレージ アカウントについて](../storage/storage-create-storage-account.md)」の手順 5.「[ストレージ アカウントの作成](../storage/storage-create-storage-account.md#create-a-storage-account)」で説明されているように、Batch では、現時点で**汎用**のストレージ アカウントの種類 "*のみ*" がサポートされています。 Batch タスク (標準タスク、開始タスク、ジョブ準備タスク、ジョブ解放タスクなど) では、 *汎用* のストレージ アカウント " **のみ** " に存在するリソース ファイルを指定する必要があります。
>
>

一般的には、Batch サービスが開始タスクの完了まで待ってから、タスクを割り当てられる状態になっているノードを判断することが望ましいものの、これは構成可能です。

コンピューティング ノードで開始タスクが失敗した場合、そのノードはエラーを表す状態に更新され、そのノードには一切タスクが割り当てられなくなります。 ストレージからのリソース ファイルのコピーに問題があったり、コマンド ラインで実行されたプロセスからゼロ以外の終了コードが返されたりした場合に、開始タスクは失敗することがあります。

" *既存* " のプールの開始タスクを追加または更新するには、そのコンピューティング ノードを再起動して、開始タスクがノードに適用されるようにする必要があります。

### <a name="job-manager-task"></a>ジョブ マネージャー タスク
**ジョブ マネージャー タスク** の通常の用途は、ジョブの実行の制御や監視です。 たとえば、ジョブに対してタスクを作成および送信する場合や、追加で実行するタスクを決める場合、どの時点で作業が完了するかを決める場合などに使用します。 ただし、ジョブ マネージャー タスクはこのようなアクティビティだけに限定されるものではなく、ジョブに必要なすべてのアクションを実行できる、高機能タスクです。 たとえば、ジョブ マネージャー タスクでは、パラメーターとして指定されたファイルをダウンロードし、ファイルの内容を分析して、その内容に基づいた追加のタスクを送信することができます。

ジョブ マネージャー タスクは、他のすべてのタスクの前に開始されます。 また、以下のような特徴があります。

* ジョブの作成時に Batch サービスによって自動的にタスクとして送信されます。
* ジョブ内の他のタスクより先に実行されるようにスケジュールされます。
* ジョブ マネージャー タスクに関連付けられたノードは、プールが縮小される際、プールから最後に削除されます。
* ジョブ マネージャー タスクの終了を、ジョブ内のすべてのタスクの終了に関連付けることができます。
* ジョブ マネージャー タスクを再起動する必要がある場合は、最も高い優先順位が割り当てられます。 アイドル状態のノードを使用できない場合、Batch サービスはジョブ マネージャー タスクを実行する余地を確保するために、プール内のいずれかの実行中のタスクを終了する場合があります。
* あるジョブ内のジョブ マネージャー タスクに、他のジョブのタスクに対して高い優先順位が割り当てられることはありません。 ジョブ間では、ジョブ レベルの優先順位のみが適用されます。

### <a name="job-preparation-and-release-tasks"></a>ジョブ準備タスクおよびジョブ解放タスク
Batch には、ジョブ実行前の設定用にジョブ準備タスク、 ジョブ実行後のメンテナンスやクリーンアップ用にジョブ解放タスクが用意されています。

* **ジョブ準備タスク**: ジョブ準備タスクは、タスクの実行がスケジュールされているすべてのコンピューティング ノードで、他のジョブ タスクの実行前に実行されます。 たとえば、ジョブごとに異なるものの、すべてのタスクによって共有されるデータをコピーするために、ジョブ準備タスクを使用することができます。
* **ジョブ解放タスク**: ジョブが完了すると、少なくとも 1 つのタスクを実行したプールの各ノードでジョブ解放タスクが実行されます。 たとえば、ジョブ準備タスクによってコピーされたデータを削除したり、診断ログ データを圧縮してアップロードしたりするために、ジョブ解放タスクを使用することができます。

ジョブ準備タスクとジョブ解放タスクのどちらでも、タスクの呼び出し時に実行するコマンド ラインを指定できます。 これらのタスクは、ファイルのダウンロード、管理者特権での実行、カスタム環境変数、最大実行期間、再試行回数、ファイルのリテンション期間などの機能を備えています。

ジョブ準備タスクとジョブ解放タスクの詳細については、「 [Azure Batch コンピューティング ノードでのジョブ準備タスクとジョブ完了タスクの実行](batch-job-prep-release.md)」を参照してください。

### <a name="multi-instance-task"></a>マルチインスタンス タスク
[マルチインスタンス タスク](batch-mpi.md) は、複数のコンピューティング ノードで同時に実行するように構成されたタスクです。 複数のコンピューティング ノードをまとめて 1 つのワークロードの処理に割り当てる Message Passing Interface (MPI) など、ハイ パフォーマンス コンピューティングが要求されるシナリオには、マルチインスタンス タスクを使って対応することができます。

Batch .NET ライブラリを使用して MPI ジョブを Batch で実行する方法の詳細な説明については、「 [Azure Batch でのマルチインスタンス タスクを使用した Message Passing Interface (MPI) アプリケーションの実行](batch-mpi.md)」を参照してください。

### <a name="task-dependencies"></a>Task dependencies
[タスクの依存関係](batch-task-dependencies.md)は、名前が示すとおり、あるタスクを実行するには、事前にその他のタスクが完了している必要があることを指定できる機能です。 この機能は、"下流" のタスクが "上流" のタスクの出力を使用するような状況や、下流のタスクで必要になる初期化を上流のタスクで実行するような状況に対応できます。 この機能を使用するには、まず Batch ジョブでタスクの依存関係を有効にする必要があります。 その後、別のタスク (または他の複数のタスク) に依存するタスクごとに、どのタスクに依存するかを指定します。

タスクの依存関係がある場合、シナリオを次のように構成できます。

* *taskB* が *taskA* に依存する (*taskB* の実行は *taskA* が完了するまで開始されない)。
* *taskC* は *taskA* と *taskB* の両方に依存。
* *taskD* が、実行されるまで特定の範囲のタスク (タスク *1* ～ *10* など) に依存する。

この機能の詳細については、「[Azure Batch におけるタスクの依存関係](batch-task-dependencies.md)」と、[azure-batch-samples][github_samples] GitHub リポジトリの [TaskDependencies][github_sample_taskdeps] コード サンプルを参照してください。

## <a name="environment-settings-for-tasks"></a>タスクの環境設定
Batch サービスによって実行されるすべてのタスクは、コンピューティング ノード上に設定されている環境変数を利用することができます。 これには、Batch サービスによって定義された ([サービス定義][msdn_env_vars]の) 環境変数のほか、ユーザーがタスクに対して定義するカスタム環境変数が含まれます。 これらの環境変数は、タスクによって実行されるアプリケーションやスクリプトから実行中に利用することができます。

カスタム環境変数は、タスクまたはジョブの *環境設定* プロパティを設定することで、タスク レベルまたはジョブ レベルで設定できます。 その例については、[ジョブへのタスクの追加][rest_add_task]操作 (Batch REST API) に関するページ、または [CloudTask.EnvironmentSettings][net_cloudtask_env] プロパティと [CloudJob.CommonEnvironmentSettings][net_job_env] プロパティ (Batch .NET) に関するページを参照してください。

クライアント アプリケーションまたはサービスからタスクのサービス定義またはカスタムの環境変数を取得するには、[タスクに関する情報の取得][rest_get_task_info]操作 (Batch REST) を使用するか、[CloudTask.EnvironmentSettings][net_cloudtask_env] プロパティ (Batch .NET) にアクセスします。 コンピューティング ノードで実行されるプロセスは、たとえば `%VARIABLE_NAME%` (Windows) や `$VARIABLE_NAME` (Linux) という一般的な構文を使用して、ノード上のこうしたさまざまな環境変数を利用することができます。

サービス定義の環境変数をすべて網羅した一覧を、[コンピューティング ノードの環境変数][msdn_env_vars]に関するページで確認できます。

## <a name="files-and-directories"></a>ファイルとディレクトリ
各タスクには "*作業ディレクトリ*" があります。そこに、タスクがファルやディレクトリを作成します。 この作業ディレクトリは、タスクによって実行されるプログラム、処理されるデータ、実行される処理の出力を格納するために使用できます。 タスクのすべてのファイルとディレクトリは、タスクのユーザーが所有者になります。

Batch サービスは、ノード上のファイル システムの一部を " *ルート ディレクトリ*" として公開します。 このルート ディレクトリには、タスクから `AZ_BATCH_NODE_ROOT_DIR` 環境変数を参照することでアクセスできます。 環境変数の使用に関する詳細については、「 [タスクの環境設定](#environment-settings-for-tasks)」を参照してください。

ルート ディレクトリには、次のディレクトリ構造が含まれています。

![コンピューティング ノードのディレクトリ構造][1]

* **shared**: ノードで実行される " *すべて* " のタスクに、このディレクトリへの読み取り/書き込みアクセス権が与えられます。 ノード上で実行されるすべてのタスクは、このディレクトリのファイルを作成、読み取り、更新、削除することができます。 このディレクトリには、タスクから `AZ_BATCH_NODE_SHARED_DIR` 環境変数を参照することでアクセスできます。
* **startup**: この場所は、開始タスクの作業ディレクトリとして使用されます。 開始タスクによってノードにダウンロードされるすべてのファイルは、ここに格納されます。 開始タスクは、このディレクトリの下で、ファイルを作成、読み取り、更新、削除できます。 このディレクトリには、タスクから `AZ_BATCH_NODE_STARTUP_DIR` 環境変数を参照することでアクセスできます。
* **タスク**: ノード上で実行されるタスクごとに、ディレクトリが作成されます。 このディレクトリには、 `AZ_BATCH_TASK_DIR` 環境変数を参照することでアクセスできます。

    各タスク ディレクトリ内に、Batch サービスによって作業ディレクトリ (`wd`) が作成されます。その一意のパスは、`AZ_BATCH_TASK_WORKING_DIR` 環境変数によって指定されます。 このディレクトリは、タスクに読み取り/書き込みアクセスを提供します。 タスクは、このディレクトリの下で、ファイルを作成、読み取り、更新、および削除できます。 このディレクトリは、タスクに対して指定された *RetentionTime* 制約に基づいて保持されます。

    `stdout.txt` および `stderr.txt`: これらのファイルは、タスクの実行中にタスク フォルダーに書き込まれます。

> [!IMPORTANT]
> ノードをプールから削除すると、ノードに格納されている " *すべて* " のファイルが削除されます。
>
>

## <a name="application-packages"></a>アプリケーション パッケージ
[アプリケーション パッケージ](batch-application-packages.md) 機能は、プール内のコンピューティング ノードにアプリケーションを簡単にデプロイして管理できる機能です。 バイナリやサポート ファイルも含め、タスクによって実行される複数のバージョンのアプリケーションをアップロードして管理できます。 また、アップロードしたアプリケーションのうち 1 つ以上をプール内のコンピューティング ノードに自動的にデプロイできます。

アプリケーション パッケージはプール レベルおよびタスク レベルで指定できます。 プールのアプリケーション パッケージを指定した場合、アプリケーションはプール内のすべてのノードにデプロイされます。 タスクのアプリケーション パッケージを指定した場合、タスクのコマンド ラインが実行される直前に、ジョブのタスクのうち、少なくとも 1 つの実行がスケジュールされているノードにのみ、アプリケーションがデプロイされます。

Batch は Azure Storage との細かいやり取りを処理し、アプリケーション パッケージを格納してコンピューティング ノードにデプロイするため、コードと管理オーバーヘッドの両方を簡略化できます。

アプリケーション パッケージ機能の詳細については、「 [Azure Batch アプリケーション パッケージを使用したアプリケーションのデプロイ](batch-application-packages.md)」を参照してください。

> [!NOTE]
> プールのアプリケーション パッケージを " *既存* " のプールに追加した場合は、そのコンピューティング ノードを再起動して、アプリケーション パッケージをノードにデプロイする必要があります。
>
>

## <a name="pool-and-compute-node-lifetime"></a>プールとコンピューティング ノードの有効期間
Azure Batch ソリューションを設計するときは、いつ、どのようにプールを作成するかと、それらのプール内のコンピューティング ノードをどのくらいの期間利用できるようにしておくかを考慮する必要があります。

1 つの方法として、送信する各ジョブについてプールを作成し、対応するタスクが実行を終えた直後にそのプールを削除することができます。 必要なときにのみノードが割り当てられ、ノードがアイドル状態になるとすぐにシャットダウンされるので、使用効率はきわめて高くなります。 ジョブはノードが割り当てられるまで待機する必要がありますが、ノードが個別に使用可能になって割り当てられ、開始タスクが完了するとすぐに、タスクの実行がスケジュール設定されることに注意してください。 つまり、プール内のすべてのノードが使用可能になるまで Batch がタスクをノードに割り当てずに待機するようなことは "*ありません*"。 そのため、使用可能なすべてのノードで使用率が最大になります。

もう一方の極端な例としては、ジョブをすぐに開始することが最優先事項であるような場合、プールを事前に作成し、ジョブが送信される前にノードを使用可能にしておくという方法があります。 この場合はタスクをすぐに開始できますが、ノードはタスクが割り当てられるまでアイドル状態で待機する可能性があります。

変動の大きい継続的な負荷に対応するために、通常はこれらを組み合わせた方法が採用されます。 この場合は複数のジョブの送信先とするプールを用意することができますが、ジョブの負荷に応じてノードの数を増減することもできます (以下のセクションの「[コンピューティング リソースのスケーリング](#scaling-compute-resources)」を参照)。 この方法では、現在の負荷に応じて事後的に対応できます。また、負荷を予測できる場合は事前に対応することもできます。

## <a name="pool-network-configuration"></a>プール ネットワーク構成

Azure Batch でコンピューティング ノードのプールを作成すると、プールのコンピューティング ノードを作成する必要のある Azure [仮想ネットワーク (VNet)](https://azure.microsoft.com/documentation/articles/virtual-networks-overview/) の ID を指定できます。

* VNet に割り当てられるのは、**Cloud Services の構成**のプールのみです。

* VNet は次の要件を満たす必要があります。

   * Azure Batch アカウントと同じ Azure **リージョン**に存在する。
   * Azure Batch アカウントと同じ**サブスクリプション**に存在する。
   * **クラシック** VNet である。 Azure Resource Manager デプロイメント モデルで作成した VNet はサポートされていません。

* VNet には、プールの `targetDedicated` プロパティに対応できるよう十分な空き **IP アドレス**が必要です。 サブネットの空き IP アドレスが十分でない場合、Batch サービスによってプールのコンピューティング ノードが部分的に割り当てられ、サイズ変更のエラーが返されます。
* *MicrosoftAzureBatch* サービス プリンシパルは、指定の VNet に関して[従来の仮想マシン共同作業者](../active-directory/role-based-access-built-in-roles.md#classic-virtual-machine-contributor)というロールベースのアクセス制御 (RBAC) のロールを付与されている必要があります。 Azure Portal で次の操作を行います。

  * **VNet** を選択してから、**[アクセス制御 (IAM)]** > **[ロール]** > **[従来の仮想マシン共同作業者]** > **[追加]** の順に選択します。
  * **検索**ボックスに「MicrosoftAzureBatch」と入力します。
  * **[MicrosoftAzureBatch]** チェック ボックスをオンにします。
  * **[選択]** ボタンをクリックします。

* VNet に関連付けられた**ネットワーク セキュリティ グループ (NSG)** によってコンピューティング ノードとの通信が拒否された場合、コンピューティング ノードの状態は Batch サービスによって**使用不可**に設定されます。 コンピューティング ノードのタスクのスケジュールを設定できるように、Azure Batch サービスからの通信をサブネットで許可する必要があります。

## <a name="scaling-compute-resources"></a>コンピューティング リソースのスケーリング
[自動スケール](batch-automatic-scaling.md)を使用すると、現在のコンピューティング環境のワークロードとリソース使用量に応じて、Batch サービスでプール内のコンピューティング ノードの数を動的に調整できます。 これにより、必要なリソースのみを使用し、不要なリソースを解放することで、アプリケーションの全体的な実行コストを削減することができます。

自動スケールを有効にするには、 [自動スケール式](batch-automatic-scaling.md#automatic-scaling-formulas) を作成してプールに関連付けます。 Batch サービスは、この式を使用して、次のスケール間隔 (構成可能な間隔) におけるプール内のノードの目標数を決定します。 プールの自動スケール設定は、プールの作成時に指定できるほか、後からプールに対してスケーリングを有効にすることもできます。 スケーリングが有効にされたプールのスケーリング設定を更新することもできます。

たとえばジョブによっては、膨大な数のタスクを実行対象として送信することが要求されることも考えられます。 この場合、現在キューに格納されているタスクの数とジョブ内のタスクの完了率に基づいてプール内のノード数を調整するスケール式をプールに割り当てることができます。 Batch サービスは、定期的に式を評価し、ワークロードと他の式の設定に基づいてプールのサイズを変更します。 このサービスでは、キュー内のタスクの数が多くなるとそれに応じて必要なノードが追加され、キュー内のタスクや実行中のタスクがなくなるとノードが削除されます。 

スケーリング式には、次のメトリックを使用できます。

* **時間メトリック** : 指定した時間数内で 5 分おきに収集された統計情報に基づきます。
* **リソース メトリック** : CPU 使用量、帯域幅使用量、メモリ使用量、およびノードの数に基づきます。
* **タスク メトリック**: "*アクティブ*" (キューに登録済み)、"*実行中*"、"*完了*" などのタスクの状態に基づきます。

プール内のコンピューティング ノードの数が自動スケールによって縮小される場合、その縮小操作のタイミングで実行されているタスクの扱いを考慮に入れる必要があります。 その点に対応するために、Batch には " *ノードの割り当て解除オプション* " が用意されていて、それを式に含めることができます。 たとえば、実行中のタスクを即座に停止するか、即座に停止したうえで再度キューに登録して別のノードで実行するか、または、完了するまで待ってノードをプールから削除するかを指定できます。

アプリケーションの自動的なスケーリングの詳細については、「 [Azure Batch プール内のコンピューティング ノードの自動スケール](batch-automatic-scaling.md)」を参照してください。

> [!TIP]
> コンピューティング リソースの使用率を最大にするには、ジョブ完了時のノードの目標個数を 0 に設定し、実行中のタスクは完了するまで実行するようにします。
>
>

## <a name="security-with-certificates"></a>証明書によるセキュリティ
証明書を使用する必要があるのは、通常、[Azure Storage アカウント][azure_storage]のキーなど、タスクの機密情報を暗号化または復号化するときです。 このようなときは、ノードに証明書をインストールすることで対応できます。 暗号化された機密情報は、コマンド ライン パラメーターを通じてタスクに渡されるか、タスク リソースの 1 つに埋め込まれます。インストールされた証明書を使用して、機密情報を復号化できます。

[証明書の追加][rest_add_cert]操作 (Batch REST) または [CertificateOperations.CreateCertificate][net_create_cert] メソッド (Batch .NET) を使用して、Batch アカウントに証明書を追加できます。 次に、新規または既存のプールに証明書を関連付けることができます。 証明書がプールに関連付けられると、Batch サービスは、プール内の各ノードに証明書をインストールします。 Batch サービスは、ノードの起動時に、いずれかのタスク (開始タスク、ジョブ マネージャー タスクも含まれます) を起動する前に、適切な証明書をインストールします。

証明書を " *既存* " のプールに追加した場合は、そのコンピューティング ノードを再起動して、証明書をノードに適用する必要があります。

## <a name="error-handling"></a>エラー処理
Batch ソリューション内でタスク エラーとアプリケーション エラーを処理することが必要になる場合があります。

### <a name="task-failure-handling"></a>タスクのエラー処理
タスク エラーは、以下のカテゴリに分類されます。

* **スケジュール エラー**

    タスク用に指定されたファイルの転送がなんらかの理由で失敗すると、タスクに "*スケジュール エラー*" が設定されます。

    スケジュール エラーの原因には、タスクのリソース ファイルが移動された、Storage アカウントが利用できなくなった、ノードへのコピーを失敗させるようなその他の問題が発生した、などがあります。
* **アプリケーション エラー**

    タスクのコマンド ラインで指定されたプロセスも失敗することがあります。 タスクで実行されたプロセスによってゼロ以外の終了コードが返された場合、プロセスが失敗したと見なされます (次のセクションの「 *タスクの終了コード* 」を参照)。

    アプリケーション エラーについては、指定された回数まで自動的にタスクを再試行するように Batch を構成することができます。
* **制約エラー**

    ジョブまたはタスクの最大実行期間を指定する制約である *maxWallClockTime*を設定することができます。 これは、処理に失敗したタスクを終了させる場合に便利です。

    最大実行時間を超過したタスクは "*完了*" としてマークされますが、終了コードは `0xC000013A` に設定され、*schedulingError* フィールドは `{ category:"ServerError", code="TaskEnded"}` としてマークされます。

### <a name="debugging-application-failures"></a>アプリケーション エラーのデバッグ
* `stderr` と `stdout`

    アプリケーションの実行中に、問題のトラブルシューティングに利用できる診断情報が生成される場合があります。 前述の「[ファイルとディレクトリ](#files-and-directories)」セクションで説明したように、Batch サービスは、コンピューティング ノードのタスク ディレクトリにある `stdout.txt` ファイルと `stderr.txt` ファイルに標準出力と標準エラー出力を書き込みます。 これらのファイルは Azure ポータルまたはいずれかの Batch SDK を使用してダウンロードすることができます。 たとえば、Batch .NET ライブラリの [ComputeNode.GetNodeFile][net_getfile_node] や [CloudTask.GetNodeFile][net_getfile_task] でこれらのファイルを取得して、トラブルシューティングに利用できます。
* **タスクの終了コード**

    前述したように、タスクによって実行されたプロセスからゼロ以外の終了コードが返された場合、そのタスクには、失敗したことを示すマークが Batch サービスによって設定されます。 タスクでプロセスが実行されると、Batch によって、そのタスクの終了コード プロパティに "*プロセスのリターン コード*" が設定されます。 タスクの終了コードを決めるのは Batch サービスでは**ない**ことに注意してください。 タスクの終了コードは、プロセス自体またはそのプロセスを実行したオペレーティング システムによって決定されます。

### <a name="accounting-for-task-failures-or-interruptions"></a>タスクのエラーや中断の理由
タスクは、エラーが発生したり中断されたりする場合があります。 タスク アプリケーション自体でエラーが発生したり、タスクが実行されているノードが再起動したりすることがあります。また、プールの割り当て解除ポリシーがタスクの完了を待たずに直ちにノードを削除するように設定されている場合は、サイズ変更操作中にノードがプールから削除されることもあります。 どのようなケースでも、Batch によってタスクを自動的にキューに戻し、別のノードで実行することができます。

断続的に発生する問題によって、タスクが応答を停止したり、実行に長い時間がかかるようになる場合もあります。 このような場合は、タスクに最大実行間隔を設定することができます。 最大実効間隔を超過すると、Batch サービスによってタスク アプリケーションが中断されます。

### <a name="connecting-to-compute-nodes"></a>コンピューティング ノードへの接続
リモートからコンピューティング ノードにサインインすることによって、さらに踏み込んだデバッグやトラブルシューティングを実行できます。 Azure ポータルを使用して、Windows ノードのリモート デスクトップ プロトコル (RDP) ファイルをダウンロードしたり、Linux ノードの Secure Shell (SSH) 接続情報を取得したりすることができます。 このような操作は、Batch API ([Batch .NET][net_rdpfile]、[Batch Python](batch-linux-nodes.md#connect-to-linux-nodes) など) で実行することもできます。

> [!IMPORTANT]
> RDP や SSH を通じてノードに接続するには、まず、ノード上にユーザーを作成する必要があります。 Azure Portal から Batch REST API を使用して[ユーザー アカウントをノードに追加][rest_create_user]し、Batch .NET の [ComputeNode.CreateComputeNodeUser][net_create_user] メソッドを呼び出すか、Batch Python モジュールの [add_user][py_add_user] メソッドを呼び出してください。
>
>

### <a name="troubleshooting-problematic-compute-nodes"></a>問題のあるコンピューティング ノードのトラブルシューティング
一部のタスクが失敗する場合は、Batch クライアント アプリケーションまたはサービスで、失敗したタスクのメタデータを調べて、正常に動作していないノードを特定できます。 プール内のノードにはそれぞれ一意の ID があり、タスクが実行されるノードはタスクのメタデータに含まれています。 問題のあるノードが特定できたら、そのノードで以下に示すいくつかの対策を実行します。

* **ノードを再起動する** ([REST][rest_reboot] | [.NET][net_reboot])

    ノードを再起動すると、途中で停止したプロセスやクラッシュしたプロセスなどの潜在的な問題が解決することがあります。 プールで開始タスクを使用している場合や、ジョブでジョブ準備タスクを使用している場合、それらのタスクはノードの再起動時に実行されます。
* **ノードを再イメージ化する** ([REST][rest_reimage] | [.NET][net_reimage])

    この操作では、ノード上のオペレーティング システムが再インストールされます。 ノードの再起動と同様、開始タスクとジョブ準備タスクはノードの再イメージ化後に再実行されます。
* **プールからノードを削除する** ([REST][rest_remove] | [.NET][net_remove])

    場合によっては、プールからノードを完全に削除する必要があります。
* **ノードでタスク スケジュールを無効にする** ([REST][rest_offline] | [.NET][net_offline])

    この操作では、ノードが実質的にオフラインになります。そのため、これ以上タスクが割り当てられなくなりますが、ノードをプール内で稼働したままにできます。 これにより、失敗したタスクのデータが失われず、これ以上ノードでタスクが失敗することもなくなり、エラーの原因を詳しく調査できます。 たとえば、ノードでタスク スケジュールを無効にした後、[リモートでサインイン](#connecting-to-compute-nodes)して、ノードのイベント ログを確認したり、他のトラブルシューティングを実行したりできます。 調査が完了したら、タスク スケジュールを有効にする ([REST][rest_online] | [.NET][net_online]) ことで、ノードをオンラインに戻すことができます。また、前述した他のいずれかのアクションを実行することもできます。

> [!IMPORTANT]
> このセクションで説明した各アクション (再起動、再イメージ化、削除、タスク スケジュールの無効化) では、アクションを実行するときに、ノードで現在実行中のタスクの処理方法を指定できます。 たとえば、Batch .NET クライアント ライブラリを使用してノードでタスク スケジュールを無効にする際に、[DisableComputeNodeSchedulingOption][net_offline_option] 列挙値を指定して、実行中のタスクを終了するか (**Terminate**)、他のノードでスケジュールするためにキューに再登録するか (**Requeue**)、実行中のタスクが完了してからアクションを実行するか (**TaskCompletion**) を指定できます。
>
>

## <a name="next-steps"></a>次のステップ
* Batch ソリューションの構築に使用できる [Batch API とツール](batch-apis-tools.md)について学習します。
* 「 [.NET 向け Azure Batch ライブラリの概要](batch-dotnet-get-started.md)」で紹介されているサンプル Batch アプリケーションの作成手順を参照します。 Linux コンピューティング ノードでワークロードを実行する [Python バージョン](batch-python-tutorial.md) のチュートリアルも用意されています。
* Batch ソリューションを開発するときに使用する [Batch Explorer][github_batchexplorer] サンプル プロジェクトをダウンロードしてビルドする。 Batch Explorer を使用すると、次のようなことを実行できます。

  * Batch アカウント内のプール、ジョブ、およびタスクの監視と操作
  * ノードからの `stdout.txt`、`stderr.txt` などのファイルのダウンロード
  * ノードでのユーザーの作成と、リモート ログインのための RDP ファイルのダウンロード
* [Linux コンピューティング ノードのプールを作成する方法](batch-linux-nodes.md)を確認します。
* MSDN の [Azure Batch フォーラム][batch_forum]にアクセスします。 初心者の方でも上級者の方でも、Batch についてわからないことがあれば、ぜひフォーラムをご利用ください。

[1]: ./media/batch-api-basics/node-folder-structure.png

[azure_storage]: https://azure.microsoft.com/services/storage/
[batch_forum]: https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurebatch
[cloud_service_sizes]: ../cloud-services/cloud-services-sizes-specs.md
[msmpi]: https://msdn.microsoft.com/library/bb524831.aspx
[github_samples]: https://github.com/Azure/azure-batch-samples
[github_sample_taskdeps]:  https://github.com/Azure/azure-batch-samples/tree/master/CSharp/ArticleProjects/TaskDependencies
[github_batchexplorer]: https://github.com/Azure/azure-batch-samples/tree/master/CSharp/BatchExplorer
[batch_net_api]: https://msdn.microsoft.com/library/azure/mt348682.aspx
[msdn_env_vars]: https://msdn.microsoft.com/library/azure/mt743623.aspx
[net_cloudjob_jobmanagertask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.jobmanagertask.aspx
[net_cloudjob_priority]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.priority.aspx
[net_cloudpool_starttask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.starttask.aspx
[net_cloudtask_env]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.environmentsettings.aspx
[net_create_cert]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.certificateoperations.createcertificate.aspx
[net_create_user]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.createcomputenodeuser.aspx
[net_getfile_node]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.getnodefile.aspx
[net_getfile_task]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.getnodefile.aspx
[net_job_env]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.commonenvironmentsettings.aspx
[net_multiinstancesettings]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.multiinstancesettings.aspx
[net_onalltaskscomplete]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.onalltaskscomplete.aspx
[net_rdp]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.getrdpfile.aspx
[net_reboot]: https://msdn.microsoft.com/library/azure/mt631495.aspx
[net_reimage]: https://msdn.microsoft.com/library/azure/mt631496.aspx
[net_remove]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.removefrompoolasync.aspx
[net_offline]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.disableschedulingasync.aspx
[net_online]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.enableschedulingasync.aspx
[net_offline_option]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.common.disablecomputenodeschedulingoption.aspx
[net_rdpfile]: https://msdn.microsoft.com/library/azure/Mt272127.aspx
[vnet]: https://msdn.microsoft.com/library/azure/dn820174.aspx#bk_netconf

[py_add_user]: http://azure-sdk-for-python.readthedocs.io/en/latest/ref/azure.batch.operations.html#azure.batch.operations.ComputeNodeOperations.add_user

[batch_rest_api]: https://msdn.microsoft.com/library/azure/Dn820158.aspx
[rest_add_job]: https://msdn.microsoft.com/library/azure/mt282178.aspx
[rest_add_pool]: https://msdn.microsoft.com/library/azure/dn820174.aspx
[rest_add_cert]: https://msdn.microsoft.com/library/azure/dn820169.aspx
[rest_add_task]: https://msdn.microsoft.com/library/azure/dn820105.aspx
[rest_create_user]: https://msdn.microsoft.com/library/azure/dn820137.aspx
[rest_get_task_info]: https://msdn.microsoft.com/library/azure/dn820133.aspx
[rest_job_schedules]: https://msdn.microsoft.com/library/azure/mt282179.aspx
[rest_multiinstance]: https://msdn.microsoft.com/library/azure/mt637905.aspx
[rest_multiinstancesettings]: https://msdn.microsoft.com/library/azure/dn820105.aspx#multiInstanceSettings
[rest_update_job]: https://msdn.microsoft.com/library/azure/dn820162.aspx
[rest_rdp]: https://msdn.microsoft.com/library/azure/dn820120.aspx
[rest_reboot]: https://msdn.microsoft.com/library/azure/dn820171.aspx
[rest_reimage]: https://msdn.microsoft.com/library/azure/dn820157.aspx
[rest_remove]: https://msdn.microsoft.com/library/azure/dn820194.aspx
[rest_offline]: https://msdn.microsoft.com/library/azure/mt637904.aspx
[rest_online]: https://msdn.microsoft.com/library/azure/mt637907.aspx

[vm_marketplace]: https://azure.microsoft.com/marketplace/virtual-machines/

